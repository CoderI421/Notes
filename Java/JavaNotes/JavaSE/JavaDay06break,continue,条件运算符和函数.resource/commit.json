{"compress":true,"commitItems":[["dad9394b-80fa-422c-8c8c-b97b6dbfdbef",1556157281680,"## break关键字\n    字面意思：打破\n    代码中的含义是：跳出(跳出当前的某些结构)\n    只能跳出【循环结构】还有【switch - case】\n    \n    如果程序运行到break，就会跳出当前的分支【switch】或者循环【while，do-while，for】,直接执行到\n    结构之后的代码\n\n## continue关键字\n    字面意思：继续 go on\n    代码中的含义：结束当前次循环，进入下一次循环\n    \n    【注意】\n        1. 在while或者do-while循环中使用continue关键字，要注意continue关键字的位置和循环条件变更\n        语句的位置关系，一定要保证continue关键字在循环条件变更之后\n        \n        2.在for循环和，continue关键字不会影响for语句中的循环条件变更\n    \n    【建议】\n        如果业务逻辑中需要使用continue关键字，那么请和for循环连用\n\n## 条件运算符(三目运算符)\n    条件 ? 语句1 : 语句2;\n    \n    类似于if - else 结构\n    \n    执行流程：\n        条件如果为true 执行语句1 ，如果为false 执行语句2\n\n## 聊一聊函数\n    函数：方法 Method Function\n    遇到的问题：\n        代码中，可以用一些代码块来完成任务，但是发现某些代码块会不断地重复使用，如果是用CV大法，会遇到以下问题\n        \n        1. 代码过于臃肿\n        2. 阅读性极差\n        3. 维护性极差\n    \n    就类似于调用nextInt() System.out.println()\n    \n    这就是函数的由来，用来解决以上问题\n    \n    封装：\n        包装，糖衣炮弹\n        把需要重复利用的功能代码，封装成一个函数的过程，做成一个工具。\n    \n    先来看看main函数\n    public static void main(String[] args)  {\n        //函数体\n        //功能代码\n    }\n   \n    public static ：修饰符 (不要问)\n    void ：返回值 (void 表示没有返回值)\n    main ：函数名 (符合标识符规则，动宾结构，见名知意)\n    (参数列表) ： 参数列表\n    \n    格式：\n    修饰符(public static) 返回值类型  函数名(形式参数列表) {\n        //函数体\n    }\n    \n    返回值：\n        1. 这个返回值类型表示当前函数运行的结果返回的类型\n        2. 返回值是通过在函数体【return关键字】返回的\n        3. 如果返回值为void，表示这个函数没有返回值\n    \n    函数名：\n        1. 符合动宾结构，见名知意\n        2. 函数名是【调用】函数的方式，要求调用函数是 格式 函数名(实际参数列表)\n        3. 函数是条狗，哪里需要哪里吼\n        \n    参数列表：\n        1. 可以为空，表示该函数不需要借助于外部的数据来完成操作\n        2. 参数列表可以放入多个参数，参数直接用，逗号隔开\n            例如:\n                (int num1, int num2)\n        3. 形式参数列表的顺序，决定了实际参数传入的顺序\n            例如:\n                (int num1, float num2, double num2, short num4)\n            正确方式:\n                (5, 1.4f, 2.5, 1)\n        \n    函数体：\n        封装的功能代码\n        \n    函数调用的时候经历了什么？？？\n        1. 从调用函数的位置开始，直接更具函数名跳转到函数的实现位置\n        2. 给函数的形式参数传入数据，这个数据就是实际参数，这里存在一个赋值的操作\n        3. 执行函数体代码\n        4. 执行完函数中的代码，如果遇到return 或者当前函数的大括号，运行结束\n        5. 调回到调用函数的位置，继续执行下面的代码\n    \n    函数的经验：\n        1. 需求分析\n            需要参数吗？需要返回值吗？返回值类型是什么？运行的结果是什么？函数的名字如何表示？\n        2. 思考函数的流程\n            用【注释】的方式，把每一步函数需要做的事情，尽量细化\n        3. 按照【注释】的提示，一步一步完成代码，在完成这一步代码的时候，不要考虑下一步\n        4. 测试\n            不要总想着好事情，也要思考异常情况，测试代码的健壮性\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ",[[1556157245718,["GJX@GJXAIOU",[[1,54,"**"],[1,81,"**"]],[54,81],[54,85]]],[1556157259022,["GJX@GJXAIOU",[[-1,155,"\n    "]],[155,160],[155,155]]],[1556157378647,["GJX@GJXAIOU",[[-1,231,"  "],[-1,238,"  "],[-1,313,"  "],[-1,349,"  "],[-1,364,"  "],[-1,407,"  "],[-1,410,"  "],[-1,419,"  "]],[229,461],[229,445]]],[1556157379066,["GJX@GJXAIOU",[[-1,229,"  "],[-1,236,"  "],[-1,307,"  "],[-1,343,"  "],[-1,354,"  "],[-1,395,"  "],[-1,398,"  "],[-1,405,"  "]],[229,445],[229,429]]],[1556157389025,["GJX@GJXAIOU",[[-1,298,"\n   "]],[298,302],[298,298]]],[1556157403509,["GJX@GJXAIOU",[[-1,666,"  "],[-1,684,"  "],[-1,695,"  "]],[667,711],[665,705]]],[1556157403833,["GJX@GJXAIOU",[[-1,664,"  "],[-1,676," "],[-1,681," "],[-1,691,"  "]],[665,705],[663,699]]],[1556157404183,["GJX@GJXAIOU",[[-1,662,"  "],[-1,674," "],[-1,677," "],[-1,687,"  "]],[663,699],[661,693]]],[1556157404662,["GJX@GJXAIOU",[[-1,660,"  "],[-1,672,"  "],[-1,683,"  "]],[661,693],[660,687]]],[1556157406151,["GJX@GJXAIOU",[[1,659,"  "]],[657,657],[659,659]]],[1556157409139,["GJX@GJXAIOU",[[-1,653,"        "]],[659,659],[651,651]]],[1556157409523,["GJX@GJXAIOU",[[-1,650,"\n"]],[651,651],[650,650]]],[1556157459199,["GJX@GJXAIOU",[[-1,1122,"  "],[-1,1129,"  "],[-1,1164," "],[-1,1171," "],[-1,1206,"  "],[-1,1234,"  "],[-1,1241,"  "],[-1,1248,"  "],[-1,1271," "],[-1,1278," "],[-1,1325,"  "],[-1,1344,"  "],[-1,1355,"  "],[-1,1363,"  "],[-1,1401," "],[-1,1408," "],[-1,1446,"  "],[-1,1452,"  "],[-1,1495,"  "],[-1,1533,"  "],[-1,1539,"  "],[-1,1613,"  "],[-1,1621,"  "]],[1123,1654],[1121,1614]]],[1556157459735,["GJX@GJXAIOU",[[-1,1120,"  "],[-1,1127,"  "],[-1,1160," "],[-1,1165," "],[-1,1198,"  "],[-1,1226,"  "],[-1,1229,"  "],[-1,1236,"  "],[-1,1257," "],[-1,1262," "],[-1,1307,"  "],[-1,1326,"  "],[-1,1333,"  "],[-1,1341,"  "],[-1,1377," "],[-1,1382," "],[-1,1418,"  "],[-1,1424,"  "],[-1,1463,"  "],[-1,1499,"  "],[-1,1505,"  "],[-1,1575,"  "],[-1,1583,"  "]],[1121,1614],[1120,1574]]],[1556157567521,["GJX@GJXAIOU",[[-1,1395,"\n            "]],[1408,1408],[1395,1395]]],[1556157589200,["GJX@GJXAIOU",[[-1,1607,"  "],[-1,1625,"  "],[-1,1671,"  "],[-1,1712,"  "],[-1,1737,"  "],[-1,1785,"  "],[-1,1813,"  "],[-1,1816," "],[-1,1819," "],[-1,1827,"  "],[-1,1843,"  "],[-1,1903,"  "],[-1,1916," "],[-1,1927," "],[-1,1955,"  "],[-1,2011,"  "],[-1,2019,"  "]],[1608,2057],[1606,2027]]],[1556157589697,["GJX@GJXAIOU",[[-1,1605,"  "],[-1,1623,"  "],[-1,1665,"  "],[-1,1706,"  "],[-1,1727,"  "],[-1,1773,"  "],[-1,1799,"  "],[-1,1802,"  "],[-1,1811,"  "],[-1,1825,"  "],[-1,1881,"  "],[-1,1894," "],[-1,1903," "],[-1,1931,"  "],[-1,1983,"  "],[-1,1991,"  "]],[1606,2027],[1605,1997]]],[1556157597904,["GJX@GJXAIOU",[[-1,1571,"    "]],[1575,1575],[1571,1571]]],[1556157646435,["GJX@GJXAIOU",[[-1,1637,"更具"]],[1639,1639],[1637,1637]]],[1556157648217,["GJX@GJXAIOU",[[1,1637,"gengju"]],[1637,1637],[1643,1643]]],[1556157649254,["GJX@GJXAIOU",[[-1,1637,"gengju"]],[1643,1643],[1637,1637]]],[1556157651032,["GJX@GJXAIOU",[[1,1637,"根据"]],[1637,1637],[1639,1639]]],[1556157768136,["GJX@GJXAIOU",[[1,1784,"**"],[1,1790,"**"]],[1784,1790],[1784,1794]]]],null,"GJX@GJXAIOU"],["c12b8348-c2c4-47ba-96ed-ffe57860b78c",1563153375586,"## break关键字\n    字面意思：打破\n    代码中的含义是：跳出(跳出当前的某些结构)\n    **只能跳出【循环结构】还有【switch - case】**\n    \n    如果程序运行到break，就会跳出当前的分支【switch】或者循环【while，do-while，for】,直接执行到结构之后的代码\n\n## continue关键字\n    字面意思：继续 go on\n    代码中的含义：结束当前次循环，进入下一次循环\n    \n【注意】\n    1. 在while或者do-while循环中使用continue关键字，要注意continue关键字的位置和循环条件变更 语句的位置关系，一定要保证continue关键字在循环条件变更之后\n    \n    2.在for循环和，continue关键字不会影响for语句中的循环条件变更\n\n【建议】\n    如果业务逻辑中需要使用continue关键字，那么请和for循环连用\n\n## 条件运算符(三目运算符)\n    条件 ? 语句1 : 语句2;\n    \n    类似于if - else 结构\n    \n    执行流程：\n        条件如果为true 执行语句1 ，如果为false 执行语句2\n\n## 聊一聊函数\n    函数：方法 Method Function\n    遇到的问题：\n        代码中，可以用一些代码块来完成任务，但是发现某些代码块会不断地重复使用，如果是用CV大法，会遇到以下问题  \n1. 代码过于臃肿\n2. 阅读性极差\n3. 维护性极差\n    \n    就类似于调用nextInt() System.out.println()\n    \n    这就是函数的由来，用来解决以上问题\n    \n    封装：\n        包装，糖衣炮弹\n        把需要重复利用的功能代码，封装成一个函数的过程，做成一个工具。\n    \n    先来看看main函数\n    public static void main(String[] args)  {\n        //函数体\n        //功能代码\n    }\n   \n    public static ：修饰符 (不要问)\n    void ：返回值 (void 表示没有返回值)\n    main ：函数名 (符合标识符规则，动宾结构，见名知意)\n    (参数列表) ： 参数列表\n    \n    格式：\n    修饰符(public static) 返回值类型  函数名(形式参数列表) {\n        //函数体\n    }\n    \n返回值：\n    1. 这个返回值类型表示当前函数运行的结果返回的类型\n    2. 返回值是通过在函数体【return关键字】返回的\n    3. 如果返回值为void，表示这个函数没有返回值\n\n函数名：\n    1. 符合动宾结构，见名知意\n    2. 函数名是【调用】函数的方式，要求调用函数是 格式 函数名(实际参数列表)\n    3. 函数是条狗，哪里需要哪里吼\n    \n参数列表：\n    1. 可以为空，表示该函数不需要借助于外部的数据来完成操作\n    2. 参数列表可以放入多个参数，参数直接用，逗号隔开\n        例如:(int num1, int num2)\n    3. 形式参数列表的顺序，决定了实际参数传入的顺序\n        例如:\n            (int num1, float num2, double num2, short num4)\n        正确方式:\n            (5, 1.4f, 2.5, 1)\n        \n函数体：\n        封装的功能代码\n        \n函数调用的时候经历了什么？？？\n    1. 从调用函数的位置开始，直接根据函数名跳转到函数的实现位置\n    2. 给函数的形式参数传入数据，这个数据就是实际参数，这里存在一个赋值的操作\n    3. 执行函数体代码\n    4. 执行完函数中的代码，如果遇到return 或者当前函数的大括号，运行结束\n    5. 调回到调用函数的位置，继续执行下面的代码\n\n**函数的经验：**\n    1. 需求分析\n        需要参数吗？需要返回值吗？返回值类型是什么？运行的结果是什么？函数的名字如何表示？\n    2. 思考函数的流程\n        用【注释】的方式，把每一步函数需要做的事情，尽量细化\n    3. 按照【注释】的提示，一步一步完成代码，在完成这一步代码的时候，不要考虑下一步\n    4. 测试\n        不要总想着好事情，也要思考异常情况，测试代码的健壮性\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ",[[1563153369210,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1563153369954,["GJX@GJXAIOU",[[1,0,"---\ntags : \n- java基础\n\nflag: blue\n---"]],[0,0],[36,36]]],[1563153372082,["GJX@GJXAIOU",[[1,37,"\n"]],[36,36],[37,37]]],[1563153374949,["GJX@GJXAIOU",[[1,37,"# Ja"]],[37,37],[41,41]]],[1563153385947,["GJX@GJXAIOU",[[1,41,"vaDay06 bra"]],[41,41],[52,52]]],[1563153386723,["GJX@GJXAIOU",[[-1,51,"a"]],[52,52],[51,51]]],[1563153388781,["GJX@GJXAIOU",[[1,51,"eak/co"]],[51,51],[57,57]]],[1563153389877,["GJX@GJXAIOU",[[-1,54,"/co"]],[57,57],[54,54]]],[1563153396555,["GJX@GJXAIOU",[[1,54,"、continue/"]],[54,54],[64,64]]],[1563153397578,["GJX@GJXAIOU",[[-1,63,"/"]],[64,64],[63,63]]],[1563153398283,["GJX@GJXAIOU",[[1,63,"/"]],[63,63],[64,64]]],[1563153398850,["GJX@GJXAIOU",[[-1,63,"/"]],[64,64],[63,63]]],[1563153399555,["GJX@GJXAIOU",[[1,63,"/"]],[63,63],[64,64]]],[1563153400028,["GJX@GJXAIOU",[[-1,63,"/"]],[64,64],[63,63]]],[1563153401971,["GJX@GJXAIOU",[[1,63,"、tiao"]],[63,63],[68,68]]],[1563153403309,["GJX@GJXAIOU",[[-1,64,"tiao"]],[68,68],[64,64]]],[1563153406645,["GJX@GJXAIOU",[[1,64,"条件运算符"]],[64,64],[69,69]]],[1563153409282,["GJX@GJXAIOU",[[1,37,"\n"]],[37,37],[38,38]]],[1563153410754,["GJX@GJXAIOU",[[1,71,"\n"]],[71,71],[72,72]]],[1563153413608,["GJX@GJXAIOU",[[1,75,"一 "]],[75,75],[76,76]]],[1563153413951,["GJX@GJXAIOU",[[1,76,"、"]],[76,76],[77,77]]],[1563153418394,["GJX@GJXAIOU",[[1,242,"二 "]],[242,242],[243,243]]],[1563153418748,["GJX@GJXAIOU",[[1,243,"、"]],[243,243],[244,244]]],[1563153423140,["GJX@GJXAIOU",[[1,508,"三、"]],[508,508],[510,510]]]],null,"GJX@GJXAIOU"],["cba2d542-2422-4871-a88e-74068f2fbea3",1563284359339,"---\ntags : \n- java基础\n\nflag: blue\n---\n\n# JavaDay06 break、continue、条件运算符\n\n## 一、 break关键字\n    字面意思：打破\n    代码中的含义是：跳出(跳出当前的某些结构)\n    **只能跳出【循环结构】还有【switch - case】**\n    \n    如果程序运行到break，就会跳出当前的分支【switch】或者循环【while，do-while，for】,直接执行到结构之后的代码\n\n## 二、 continue关键字\n    字面意思：继续 go on\n    代码中的含义：结束当前次循环，进入下一次循环\n    \n【注意】\n    1. 在while或者do-while循环中使用continue关键字，要注意continue关键字的位置和循环条件变更 语句的位置关系，一定要保证continue关键字在循环条件变更之后\n    \n    2.在for循环和，continue关键字不会影响for语句中的循环条件变更\n\n【建议】\n    如果业务逻辑中需要使用continue关键字，那么请和for循环连用\n\n## 三、条件运算符(三目运算符)\n    条件 ? 语句1 : 语句2;\n    \n    类似于if - else 结构\n    \n    执行流程：\n        条件如果为true 执行语句1 ，如果为false 执行语句2\n\n## 聊一聊函数\n    函数：方法 Method Function\n    遇到的问题：\n        代码中，可以用一些代码块来完成任务，但是发现某些代码块会不断地重复使用，如果是用CV大法，会遇到以下问题  \n1. 代码过于臃肿\n2. 阅读性极差\n3. 维护性极差\n    \n    就类似于调用nextInt() System.out.println()\n    \n    这就是函数的由来，用来解决以上问题\n    \n    封装：\n        包装，糖衣炮弹\n        把需要重复利用的功能代码，封装成一个函数的过程，做成一个工具。\n    \n    先来看看main函数\n    public static void main(String[] args)  {\n        //函数体\n        //功能代码\n    }\n   \n    public static ：修饰符 (不要问)\n    void ：返回值 (void 表示没有返回值)\n    main ：函数名 (符合标识符规则，动宾结构，见名知意)\n    (参数列表) ： 参数列表\n    \n    格式：\n    修饰符(public static) 返回值类型  函数名(形式参数列表) {\n        //函数体\n    }\n    \n返回值：\n    1. 这个返回值类型表示当前函数运行的结果返回的类型\n    2. 返回值是通过在函数体【return关键字】返回的\n    3. 如果返回值为void，表示这个函数没有返回值\n\n函数名：\n    1. 符合动宾结构，见名知意\n    2. 函数名是【调用】函数的方式，要求调用函数是 格式 函数名(实际参数列表)\n    3. 函数是条狗，哪里需要哪里吼\n    \n参数列表：\n    1. 可以为空，表示该函数不需要借助于外部的数据来完成操作\n    2. 参数列表可以放入多个参数，参数直接用，逗号隔开\n        例如:(int num1, int num2)\n    3. 形式参数列表的顺序，决定了实际参数传入的顺序\n        例如:\n            (int num1, float num2, double num2, short num4)\n        正确方式:\n            (5, 1.4f, 2.5, 1)\n        \n函数体：\n        封装的功能代码\n        \n函数调用的时候经历了什么？？？\n    1. 从调用函数的位置开始，直接根据函数名跳转到函数的实现位置\n    2. 给函数的形式参数传入数据，这个数据就是实际参数，这里存在一个赋值的操作\n    3. 执行函数体代码\n    4. 执行完函数中的代码，如果遇到return 或者当前函数的大括号，运行结束\n    5. 调回到调用函数的位置，继续执行下面的代码\n\n**函数的经验：**\n    1. 需求分析\n        需要参数吗？需要返回值吗？返回值类型是什么？运行的结果是什么？函数的名字如何表示？\n    2. 思考函数的流程\n        用【注释】的方式，把每一步函数需要做的事情，尽量细化\n    3. 按照【注释】的提示，一步一步完成代码，在完成这一步代码的时候，不要考虑下一步\n    4. 测试\n        不要总想着好事情，也要思考异常情况，测试代码的健壮性\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ",[[1563284328945,["GJX@GJXAIOU",[[1,38,"@toc\n\n\n"]],[37,37],[44,44]]]],null,"GJX@GJXAIOU"]]}