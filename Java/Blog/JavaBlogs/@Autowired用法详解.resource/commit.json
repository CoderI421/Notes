{"compress":true,"commitItems":[["c6dde586-2af3-4c22-931e-52b6b9791e22",1563099529006,"# @Autowired用法详解\n\n置顶 2016年08月25日 13:26:17 [阿文施瓦辛格](https://me.csdn.net/u013257679) 阅读数 115773 标签： [Autowired](https://so.csdn.net/so/search/s.do?q=Autowired&t=blog)[default](https://so.csdn.net/so/search/s.do?q=default&t=blog)[autowire](https://so.csdn.net/so/search/s.do?q=autowire&t=blog)[xml](https://so.csdn.net/so/search/s.do?q=xml&t=blog) 更多\n\n个人分类： [Java Web](https://blog.csdn.net/u013257679/article/category/5714705)\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u013257679/article/details/52295106\n\n*   首先要知道另一个东西，default-autowire，它是在xml文件中进行配置的，可以设置为byName、byType、constructor和autodetect；比如byName，不用显式的在bean中写出依赖的对象，它会自动的匹配其它bean中id名与本bean的set**相同的，并自动装载。\n*   @Autowired是用在JavaBean中的注解，通过byType形式，用来给指定的字段或方法注入所需的外部资源。\n*   两者的功能是一样的，就是能**减少或者消除属性或构造器参数的设置**，只是配置地方不一样而已。\n*   autowire四种模式的区别： \n    ![这里写图片描述](https://img-blog.csdn.net/20160824172800163)\n*   先看一下bean实例化和@Autowired装配过程：\n\n    1.  一切都是从bean工厂的getBean方法开始的，一旦该方法调用总会返回一个bean实例，无论当前是否存在，不存在就实例化一个并装配，否则直接返回。（Spring MVC是在什么时候开始执行bean的实例化过程的呢？其实就在组件扫描完成之后）\n\n    2.  实例化和装配过程中会多次递归调用getBean方法来解决类之间的依赖。\n\n    3.  Spring几乎考虑了所有可能性，所以方法特别复杂但完整有条理。\n\n    4.  @Autowired最终是根据类型来查找和装配元素的，但是我们设置了`<beans default-autowire=\"byName\"/>`后会影响最终的类型匹配查找。因为在前面有根据BeanDefinition的autowire类型设置PropertyValue值得一步，其中会有新实例的创建和注册。就是那个autowireByName方法。\n\n*   下面通过@Autowired来说明一下用法\n\n*   Setter 方法中的 @Autowired \n    你可以在 JavaBean中的 setter 方法中使用 @Autowired 注解。当 Spring遇到一个在 setter 方法中使用的 @Autowired 注解，它会在方法中执行 byType 自动装配。 \n    这里是 TextEditor.java 文件的内容：\n\n```\npackage com.tutorialspoint;\nimport org.springframework.beans.factory.annotation.Autowired;\npublic class TextEditor {\n   private SpellChecker spellChecker;\n   @Autowired\n   public void setSpellChecker( SpellChecker spellChecker ){\n      this.spellChecker = spellChecker;\n   }\n   public SpellChecker getSpellChecker( ) {\n      return spellChecker;\n   }\n   public void spellCheck() {\n      spellChecker.checkSpelling();\n   }\n}\n```\n\n下面是另一个依赖的类文件 SpellChecker.java 的内容：\n\n```\npackage com.tutorialspoint;\npublic class SpellChecker {\n   public SpellChecker(){\n      System.out.println(\"Inside SpellChecker constructor.\" );\n   }\n   public void checkSpelling(){\n      System.out.println(\"Inside checkSpelling.\" );\n   }  \n}\n```\n\n下面是 MainApp.java 文件的内容：\n\n```\npackage com.tutorialspoint;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\npublic class MainApp {\n   public static void main(String[] args) {\n      ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\");\n      TextEditor te = (TextEditor) context.getBean(\"textEditor\");\n      te.spellCheck();\n   }\n}\n```\n\n下面是配置文件 Beans.xml：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context-3.0.xsd\">\n\n   <context:annotation-config/>\n\n   <!-- Definition for textEditor bean without constructor-arg  -->\n   <bean id=\"textEditor\" class=\"com.tutorialspoint.TextEditor\">\n   </bean>\n\n   <!-- Definition for spellChecker bean -->\n   <bean id=\"spellChecker\" class=\"com.tutorialspoint.SpellChecker\">\n   </bean>\n\n</beans>\n```\n\n一旦你已经完成的创建了源文件和 bean 配置文件，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：\n\nInside SpellChecker constructor. \nInside checkSpelling.\n\n*   属性中的 @Autowired \n    你可以在属性中使用 @Autowired 注解来除去 setter 方法。当时使用 为自动连接属性传递的时候，Spring 会将这些传递过来的值或者引用自动分配给那些属性。所以利用在属性中 @Autowired 的用法，你的 TextEditor.java 文件将变成如下所示：\n\n```\npackage com.tutorialspoint;\nimport org.springframework.beans.factory.annotation.Autowired;\npublic class TextEditor {\n   @Autowired\n   private SpellChecker spellChecker;\n   public TextEditor() {\n      System.out.println(\"Inside TextEditor constructor.\" );\n   }  \n   public SpellChecker getSpellChecker( ){\n      return spellChecker;\n   }  \n   public void spellCheck(){\n      spellChecker.checkSpelling();\n   }\n}\n```\n\n下面是配置文件 Beans.xml：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context-3.0.xsd\">\n\n   <context:annotation-config/>\n\n   <!-- Definition for textEditor bean -->\n   <bean id=\"textEditor\" class=\"com.tutorialspoint.TextEditor\">\n   </bean>\n\n   <!-- Definition for spellChecker bean -->\n   <bean id=\"spellChecker\" class=\"com.tutorialspoint.SpellChecker\">\n   </bean>\n\n</beans>\n```\n\n一旦你在源文件和 bean 配置文件中完成了上面两处改变，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：\n\nInside TextEditor constructor. \nInside SpellChecker constructor. \nInside checkSpelling.\n\n*   构造函数中的 @Autowired \n    你也可以在构造函数中使用 @Autowired。一个构造函数 @Autowired 说明当创建 bean 时，即使在 XML 文件中没有使用 元素配置 bean ，构造函数也会被自动连接。让我们检查一下下面的示例。\n\n这里是 TextEditor.java 文件的内容：\n\n```\npackage com.tutorialspoint;\nimport org.springframework.beans.factory.annotation.Autowired;\npublic class TextEditor {\n   private SpellChecker spellChecker;\n   @Autowired\n   public TextEditor(SpellChecker spellChecker){\n      System.out.println(\"Inside TextEditor constructor.\" );\n      this.spellChecker = spellChecker;\n   }\n   public void spellCheck(){\n      spellChecker.checkSpelling();\n   }\n}\n```\n\n下面是配置文件 Beans.xml：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context-3.0.xsd\">\n\n   <context:annotation-config/>\n\n   <!-- Definition for textEditor bean without constructor-arg  -->\n   <bean id=\"textEditor\" class=\"com.tutorialspoint.TextEditor\">\n   </bean>\n\n   <!-- Definition for spellChecker bean -->\n   <bean id=\"spellChecker\" class=\"com.tutorialspoint.SpellChecker\">\n   </bean>\n\n</beans>\n```\n\n一旦你在源文件和 bean 配置文件中完成了上面两处改变，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：\n\nInside TextEditor constructor. \nInside SpellChecker constructor. \nInside checkSpelling.\n\n*   @Autowired 的（required=false）选项 \n    默认情况下，@Autowired 注解意味着依赖是必须的，它类似于 @Required 注解，然而，你可以使用 @Autowired 的 （required=false） 选项关闭默认行为。\n\n即使你不为 age 属性传递任何参数，下面的示例也会成功运行，但是对于 name 属性则需要一个参数。你可以自己尝试一下这个示例，因为除了只有 Student.java 文件被修改以外，它和 @Required 注解示例是相似的。\n\n```\npackage com.tutorialspoint;\nimport org.springframework.beans.factory.annotation.Autowired;\npublic class Student {\n   private Integer age;\n   private String name;\n   @Autowired(required=false)\n   public void setAge(Integer age) {\n      this.age = age;\n   }  \n   public Integer getAge() {\n      return age;\n   }\n   @Autowired\n   public void setName(String name) {\n      this.name = name;\n   }   \n   public String getName() {\n      return name;\n   }\n}\n```",[[1563099482483,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1563099484376,["GJX@GJXAIOU",[[-1,0,""],[1,0,"-"],[-1,21," "],[1,22," "],[-1,42," "],[1,43," "],[-1,83," "],[1,84," "],[-1,94," 标签： "],[1,99," 标签： "],[-1,345," "],[1,346," "],[-1,355," "],[1,356," "],[-1,805," "],[1,806," "],[-1,1353," "],[1,1354," "],[-1,1465," "],[1,1466," "],[-1,3584," "],[1,3585," "],[-1,3628," "],[1,3629," "],[-1,5095," "],[1,5096," "],[-1,5129," "],[1,5130," "],[-1,5175," "],[1,5176," "],[-1,6648," "],[1,6649," "],[-1,6682," "],[1,6683," "],[-1,6741," "],[1,6742," "]],[0,0],[1,1]]],[1563099484502,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1563099484604,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1563099484635,["GJX@GJXAIOU",[[1,4,"\n---\n\n"]],[3,3],[4,4]]],[1563099488967,["GJX@GJXAIOU",[[1,4,"tags："]],[4,4],[9,9]]],[1563099489578,["GJX@GJXAIOU",[[1,10,"\n"]],[9,9],[10,10]]],[1563099497614,["GJX@GJXAIOU",[[1,10,"- JavaWeb"]],[10,10],[19,19]]],[1563099502889,["GJX@GJXAIOU",[[-1,8,"："]],[9,9],[8,8]]],[1563099504372,["GJX@GJXAIOU",[[1,8,":"]],[8,8],[9,9]]],[1563099513265,["GJX@GJXAIOU",[[1,20,"\n"]],[19,19],[20,20]]],[1563099516084,["GJX@GJXAIOU",[[1,20,"Auyto"]],[20,20],[25,25]]],[1563099517097,["GJX@GJXAIOU",[[-1,20,"Auyto"]],[25,25],[20,20]]],[1563099517211,["GJX@GJXAIOU",[[-1,20,"\n"]],[20,20],[19,19]]],[1563099518093,["GJX@GJXAIOU",[[1,19,"-"]],[19,19],[20,20]]],[1563099518722,["GJX@GJXAIOU",[[-1,19,"-"]],[20,20],[19,19]]],[1563099519420,["GJX@GJXAIOU",[[1,20,"\n"]],[19,19],[20,20]]],[1563099526258,["GJX@GJXAIOU",[[1,20,"- Autowired"]],[20,20],[31,31]]],[1563099527306,["GJX@GJXAIOU",[[1,32,"\n"]],[31,31],[32,32]]],[1563099528475,["GJX@GJXAIOU",[[1,32,"- "]],[32,32],[34,34]]],[1563099531813,["GJX@GJXAIOU",[[1,34,"default"]],[34,34],[41,41]]],[1563099541595,["GJX@GJXAIOU",[[-1,34,"default"]],[41,41],[34,34]]],[1563099543435,["GJX@GJXAIOU",[[1,34,"xml"]],[34,34],[37,37]]],[1563099552009,["GJX@GJXAIOU",[[-1,61,"置顶 2016年08月25日 13:26:17 [阿文施瓦辛格](https://me.csdn.net/u013257679) 阅读数 115773 标签： [Autowired](https://so.csdn.net/so/search/s.do?q=Autowired&t=blog)[default](https://so.csdn.net/so/search/s.do?q=default&t=blog)[autowire](https://so.csdn.net/so/search/s.do?q=autowire&t=blog)[xml](https://so.csdn.net/so/search/s.do?q=xml&t=blog) 更多\n\n个人分类： [Java Web](https://blog.csdn.net/u013257679/article/category/5714705)\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u013257679/article/details/52295106"]],[61,553],[61,61]]],[1563099553984,["GJX@GJXAIOU",[[-1,62,"\n"]],[62,62],[61,61]]]],null,"GJX@GJXAIOU"]]}