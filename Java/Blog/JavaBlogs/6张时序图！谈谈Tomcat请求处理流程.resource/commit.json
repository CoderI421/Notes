{"compress":true,"commitItems":[["889b8306-1cb6-4222-be6f-c30c502133b8",1568210711288,"## 6张时序图！谈谈Tomcat请求处理流程\n\n[java思维导图](javascript:void(0);) _昨天_\n\n> 作者：c-rainstorm 链接：http://1t.click/afPw\n\n很多东西在时序图中体现的已经非常清楚了，没有必要再一步一步的作介绍，本文以图为主，然后对部分内容加以简单解释。\n\n*   绘制图形使用的工具是 PlantUML + Visual Studio Code + PlantUML Extension\n\n本文对 Tomcat 的介绍以 `Tomcat-9.0.0.M22` 为标准。\n\n`Tomcat-9.0.0.M22` 是 Tomcat 目前最新的版本，但尚未发布，它实现了 `Servlet4.0` 及 `JSP2.3` 并提供了很多新特性，需要 1.8 及以上的 JDK 支持等等，详情请查阅 Tomcat-9.0-doc\n\n*   Overview\n\n*   Connector Init and Start\n\n*   Requtst Process\n\n*   Acceptor\n\n*   Poller\n\n*   Worker\n\n*   Container\n\n*   At last\n\n## Overview\n\n![](https://mmbiz.qpic.cn/mmbiz_jpg/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYOibpLNnaMUbGxNJ4l1rAjqzhUW5Lrv5JFVnrI9QghYyibhLbSwDOcicMw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  Connector 启动以后会启动一组线程用于不同阶段的请求处理过程。\n\n2.  `Acceptor` 线程组。用于接受新连接，并将新连接封装一下，选择一个 `Poller` 将新连接添加到 `Poller` 的事件队列中。\n\n3.  `Poller` 线程组。用于监听 Socket 事件，当 Socket 可读或可写等等时，将 Socket 封装一下添加到 `worker` 线程池的任务队列中。\n\n4.  `worker` 线程组。用于对请求进行处理，包括分析请求报文并创建 Request 对象，调用容器的 pipeline 进行处理。\n\n*   `Acceptor`、 `Poller`、 `worker` 所在的 `ThreadPoolExecutor` 都维护在 `NioEndpoint` 中。\n\n## Connector Init and Start\n\n![](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYjpx17njMCqLx6tZlHrKicpr33MTcxoSHkIKOl5Hf1JT7yq4ZPjUpHwg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  `initServerSocket()`，通过 `ServerSocketChannel.open()` 打开一个 ServerSocket，默认绑定到 8080 端口，默认的连接等待队列长度是 100， 当超过 100 个时会拒绝服务。我们可以通过配置 `conf/server.xml` 中 `Connector` 的 `acceptCount` 属性对其进行定制。\n\n2.  `createExecutor()` 用于创建 `Worker` 线程池。默认会启动 10 个 `Worker` 线程，Tomcat 处理请求过程中，Woker 最多不超过 200 个。我们可以通过配置 `conf/server.xml` 中 `Connector` 的 `minSpareThreads` 和 `maxThreads` 对这两个属性进行定制。\n\n3.  `Pollor` 用于检测已就绪的 Socket。 默认最多不超过 2 个， `Math.min(2,Runtime.getRuntime().availableProcessors());`。我们可以通过配置 `pollerThreadCount` 来定制。\n\n4.  `Acceptor` 用于接受新连接。默认是 1 个。我们可以通过配置 `acceptorThreadCount` 对其进行定制。\n\n## Requtst Process\n\n### Acceptor\n\n![](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYKnEBYLY19ia3G1wtNoXQoYQN1qKTCGtJUIkXA4mUgk43caSUmg7WtSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  `Acceptor` 在启动后会阻塞在 `ServerSocketChannel.accept();` 方法处，当有新连接到达时，该方法返回一个 `SocketChannel`。\n\n2.  配置完 Socket 以后将 Socket 封装到 `NioChannel` 中，并注册到 `Poller`, 值的一提的是，我们一开始就启动了多个 `Poller` 线程，注册的时候，连接是公平的分配到每个 `Poller` 的。 `NioEndpoint` 维护了一个 `Poller` 数组，当一个连接分配给 `pollers[index]` 时，下一个连接就会分配给 `pollers[(index+1)%pollers.length]`.\n\n3.  `addEvent()` 方法会将 Socket 添加到该 `Poller` 的 `PollerEvent` 队列中。到此 `Acceptor` 的任务就完成了。\n\n### Poller\n\n![](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYCibLicIrUn3ibeCSUje17ibzVmub5Wh0iaTF9GiaicKSsgXVrWAicNxAtKHZgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  `selector.select(1000)`。当 `Poller` 启动后因为 selector 中并没有已注册的 `Channel`，所以当执行到该方法时只能阻塞。所有的 `Poller` 共用一个 Selector，其实现类是 `sun.nio.ch.EPollSelectorImpl`\n\n2.  `events()` 方法会将通过 `addEvent()` 方法添加到事件队列中的 Socket 注册到 `EPollSelectorImpl`，当 Socket 可读时， `Poller` 才对其进行处理\n\n3.  `createSocketProcessor()` 方法将 Socket 封装到 `SocketProcessor` 中， `SocketProcessor` 实现了 `Runnable` 接口。 `worker` 线程通过调用其 `run()` 方法来对 Socket 进行处理。\n\n4.  `execute(SocketProcessor)` 方法将 `SocketProcessor` 提交到线程池，放入线程池的 `workQueue` 中。 `workQueue` 是 `BlockingQueue` 的实例。到此 `Poller` 的任务就完成了。\n\n### Worker\n\n![](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYogOe1ezjEpia7T0yBJUibYVv2rtBGrTBNibH7EX0MxBvsFhKd21IZ7VJA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  `worker` 线程被创建以后就执行 `ThreadPoolExecutor` 的 `runWorker()` 方法，试图从 `workQueue` 中取待处理任务，但是一开始 `workQueue` 是空的，所以 `worker` 线程会阻塞在 `workQueue.take()` 方法。\n\n2.  当新任务添加到 `workQueue`后， `workQueue.take()` 方法会返回一个 `Runnable`，通常是 `SocketProcessor`, 然后 `worker` 线程调用 `SocketProcessor` 的 `run()` 方法对 Socket 进行处理。\n\n3.  `createProcessor()` 会创建一个 `Http11Processor`, 它用来解析 Socket，将 Socket 中的内容封装到 `Request` 中。注意这个 `Request` 是临时使用的一个类，它的全类名是 `org.apache.coyote.Request`，\n\n4.  `postParseRequest()` 方法封装一下 Request，并处理一下映射关系 (从 URL 映射到相应的 `Host`、 `Context`、 `Wrapper`)。\n\n5.  `CoyoteAdapter` 将 Rquest 提交给 `Container` 处理之前，并将 `org.apache.coyote.Request` 封装到 `org.apache.catalina.connector.Request`，传递给 `Container` 处理的 Request 是 `org.apache.catalina.connector.Request`。\n\n6.  `connector.getService().getMapper().map()`，用来在 `Mapper` 中查询 URL 的映射关系。映射关系会保留到 `org.apache.catalina.connector.Request` 中， `Container` 处理阶段 `request.getHost()` 是使用的就是这个阶段查询到的映射主机，以此类推 `request.getContext()`、 `request.getWrapper()` 都是。\n\n7.  `connector.getService().getContainer().getPipeline().getFirst().invoke()` 会将请求传递到 `Container` 处理，当然了 `Container` 处理也是在 `Worker` 线程中执行的，但是这是一个相对独立的模块，所以单独分出来一节。\n\n### Container\n\n![](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYZJVibLZGgFvzHCKsv0PbagJEGKTkb1cMR76oO8HT0l1ciceLLZaXdq2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  需要注意的是，基本上每一个容器的 `StandardPipeline` 上都会有多个已注册的 `Valve`，我们只关注每个容器的 Basic Valve。其他 Valve 都是在 Basic Valve 前执行。\n\n2.  `request.getHost().getPipeline().getFirst().invoke()` 先获取对应的 `StandardHost`，并执行其 pipeline。\n\n3.  `request.getContext().getPipeline().getFirst().invoke()` 先获取对应的 `StandardContext`, 并执行其 pipeline。\n\n4.  `request.getWrapper().getPipeline().getFirst().invoke()` 先获取对应的 `StandardWrapper`，并执行其 pipeline。\n\n5.  最值得说的就是 `StandardWrapper` 的 Basic Valve， `StandardWrapperValve`\n\n6.  `allocate()` 用来加载并初始化 `Servlet`，值的一提的是 Servlet 并不都是单例的，当 Servlet 实现了 `SingleThreadModel` 接口后， `StandardWrapper` 会维护一组 Servlet 实例，这是享元模式。当然了 `SingleThreadModel` 在 Servlet 2.4 以后就弃用了。\n\n7.  `createFilterChain()` 方法会从 `StandardContext` 中获取到所有的过滤器，然后将匹配 Request URL 的所有过滤器挑选出来添加到 `filterChain` 中。\n\n8.  `doFilter()` 执行过滤链, 当所有的过滤器都执行完毕后调用 Servlet 的 `service()` 方法。\n\n# Reference\n\n1.  《How Tomcat works》\n\n2.  《Tomcat 架构解析》-- 刘光瑞\n\n3.  Tomcat-9.0-doc\n\n4.  apache-tomcat-9.0.0.M22-src\n\n5.  tomcat 架构分析 (connector NIO 实现)",[[1568210654354,["GJX@GJXAIOU",[[-1,25,"[java思维导图](javascript:void(0);) _昨天_\n\n> 作者：c-rainstorm 链接：http://1t.click/afPw"]],[25,103],[25,25]]]],null,"GJX@GJXAIOU"],["c9d275de-b05b-4e84-9dba-c98fc73ce235",1573954762192,"## 6张时序图！谈谈Tomcat请求处理流程\n\n\n\n很多东西在时序图中体现的已经非常清楚了，没有必要再一步一步的作介绍，本文以图为主，然后对部分内容加以简单解释。\n\n*   绘制图形使用的工具是 PlantUML + Visual Studio Code + PlantUML Extension\n\n本文对 Tomcat 的介绍以 `Tomcat-9.0.0.M22` 为标准。\n\n`Tomcat-9.0.0.M22` 是 Tomcat 目前最新的版本，但尚未发布，它实现了 `Servlet4.0` 及 `JSP2.3` 并提供了很多新特性，需要 1.8 及以上的 JDK 支持等等，详情请查阅 Tomcat-9.0-doc\n\n*   Overview\n\n*   Connector Init and Start\n\n*   Requtst Process\n\n*   Acceptor\n\n*   Poller\n\n*   Worker\n\n*   Container\n\n*   At last\n\n## Overview\n\n![](https://mmbiz.qpic.cn/mmbiz_jpg/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYOibpLNnaMUbGxNJ4l1rAjqzhUW5Lrv5JFVnrI9QghYyibhLbSwDOcicMw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  Connector 启动以后会启动一组线程用于不同阶段的请求处理过程。\n\n2.  `Acceptor` 线程组。用于接受新连接，并将新连接封装一下，选择一个 `Poller` 将新连接添加到 `Poller` 的事件队列中。\n\n3.  `Poller` 线程组。用于监听 Socket 事件，当 Socket 可读或可写等等时，将 Socket 封装一下添加到 `worker` 线程池的任务队列中。\n\n4.  `worker` 线程组。用于对请求进行处理，包括分析请求报文并创建 Request 对象，调用容器的 pipeline 进行处理。\n\n*   `Acceptor`、 `Poller`、 `worker` 所在的 `ThreadPoolExecutor` 都维护在 `NioEndpoint` 中。\n\n## Connector Init and Start\n\n![](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYjpx17njMCqLx6tZlHrKicpr33MTcxoSHkIKOl5Hf1JT7yq4ZPjUpHwg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  `initServerSocket()`，通过 `ServerSocketChannel.open()` 打开一个 ServerSocket，默认绑定到 8080 端口，默认的连接等待队列长度是 100， 当超过 100 个时会拒绝服务。我们可以通过配置 `conf/server.xml` 中 `Connector` 的 `acceptCount` 属性对其进行定制。\n\n2.  `createExecutor()` 用于创建 `Worker` 线程池。默认会启动 10 个 `Worker` 线程，Tomcat 处理请求过程中，Woker 最多不超过 200 个。我们可以通过配置 `conf/server.xml` 中 `Connector` 的 `minSpareThreads` 和 `maxThreads` 对这两个属性进行定制。\n\n3.  `Pollor` 用于检测已就绪的 Socket。 默认最多不超过 2 个， `Math.min(2,Runtime.getRuntime().availableProcessors());`。我们可以通过配置 `pollerThreadCount` 来定制。\n\n4.  `Acceptor` 用于接受新连接。默认是 1 个。我们可以通过配置 `acceptorThreadCount` 对其进行定制。\n\n## Requtst Process\n\n### Acceptor\n\n![](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYKnEBYLY19ia3G1wtNoXQoYQN1qKTCGtJUIkXA4mUgk43caSUmg7WtSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  `Acceptor` 在启动后会阻塞在 `ServerSocketChannel.accept();` 方法处，当有新连接到达时，该方法返回一个 `SocketChannel`。\n\n2.  配置完 Socket 以后将 Socket 封装到 `NioChannel` 中，并注册到 `Poller`, 值的一提的是，我们一开始就启动了多个 `Poller` 线程，注册的时候，连接是公平的分配到每个 `Poller` 的。 `NioEndpoint` 维护了一个 `Poller` 数组，当一个连接分配给 `pollers[index]` 时，下一个连接就会分配给 `pollers[(index+1)%pollers.length]`.\n\n3.  `addEvent()` 方法会将 Socket 添加到该 `Poller` 的 `PollerEvent` 队列中。到此 `Acceptor` 的任务就完成了。\n\n### Poller\n\n![](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYCibLicIrUn3ibeCSUje17ibzVmub5Wh0iaTF9GiaicKSsgXVrWAicNxAtKHZgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  `selector.select(1000)`。当 `Poller` 启动后因为 selector 中并没有已注册的 `Channel`，所以当执行到该方法时只能阻塞。所有的 `Poller` 共用一个 Selector，其实现类是 `sun.nio.ch.EPollSelectorImpl`\n\n2.  `events()` 方法会将通过 `addEvent()` 方法添加到事件队列中的 Socket 注册到 `EPollSelectorImpl`，当 Socket 可读时， `Poller` 才对其进行处理\n\n3.  `createSocketProcessor()` 方法将 Socket 封装到 `SocketProcessor` 中， `SocketProcessor` 实现了 `Runnable` 接口。 `worker` 线程通过调用其 `run()` 方法来对 Socket 进行处理。\n\n4.  `execute(SocketProcessor)` 方法将 `SocketProcessor` 提交到线程池，放入线程池的 `workQueue` 中。 `workQueue` 是 `BlockingQueue` 的实例。到此 `Poller` 的任务就完成了。\n\n### Worker\n\n![](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYogOe1ezjEpia7T0yBJUibYVv2rtBGrTBNibH7EX0MxBvsFhKd21IZ7VJA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  `worker` 线程被创建以后就执行 `ThreadPoolExecutor` 的 `runWorker()` 方法，试图从 `workQueue` 中取待处理任务，但是一开始 `workQueue` 是空的，所以 `worker` 线程会阻塞在 `workQueue.take()` 方法。\n\n2.  当新任务添加到 `workQueue`后， `workQueue.take()` 方法会返回一个 `Runnable`，通常是 `SocketProcessor`, 然后 `worker` 线程调用 `SocketProcessor` 的 `run()` 方法对 Socket 进行处理。\n\n3.  `createProcessor()` 会创建一个 `Http11Processor`, 它用来解析 Socket，将 Socket 中的内容封装到 `Request` 中。注意这个 `Request` 是临时使用的一个类，它的全类名是 `org.apache.coyote.Request`，\n\n4.  `postParseRequest()` 方法封装一下 Request，并处理一下映射关系 (从 URL 映射到相应的 `Host`、 `Context`、 `Wrapper`)。\n\n5.  `CoyoteAdapter` 将 Rquest 提交给 `Container` 处理之前，并将 `org.apache.coyote.Request` 封装到 `org.apache.catalina.connector.Request`，传递给 `Container` 处理的 Request 是 `org.apache.catalina.connector.Request`。\n\n6.  `connector.getService().getMapper().map()`，用来在 `Mapper` 中查询 URL 的映射关系。映射关系会保留到 `org.apache.catalina.connector.Request` 中， `Container` 处理阶段 `request.getHost()` 是使用的就是这个阶段查询到的映射主机，以此类推 `request.getContext()`、 `request.getWrapper()` 都是。\n\n7.  `connector.getService().getContainer().getPipeline().getFirst().invoke()` 会将请求传递到 `Container` 处理，当然了 `Container` 处理也是在 `Worker` 线程中执行的，但是这是一个相对独立的模块，所以单独分出来一节。\n\n### Container\n\n![](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwsvKCxEiaMfzWiasqxLibu68HYZJVibLZGgFvzHCKsv0PbagJEGKTkb1cMR76oO8HT0l1ciceLLZaXdq2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n1.  需要注意的是，基本上每一个容器的 `StandardPipeline` 上都会有多个已注册的 `Valve`，我们只关注每个容器的 Basic Valve。其他 Valve 都是在 Basic Valve 前执行。\n\n2.  `request.getHost().getPipeline().getFirst().invoke()` 先获取对应的 `StandardHost`，并执行其 pipeline。\n\n3.  `request.getContext().getPipeline().getFirst().invoke()` 先获取对应的 `StandardContext`, 并执行其 pipeline。\n\n4.  `request.getWrapper().getPipeline().getFirst().invoke()` 先获取对应的 `StandardWrapper`，并执行其 pipeline。\n\n5.  最值得说的就是 `StandardWrapper` 的 Basic Valve， `StandardWrapperValve`\n\n6.  `allocate()` 用来加载并初始化 `Servlet`，值的一提的是 Servlet 并不都是单例的，当 Servlet 实现了 `SingleThreadModel` 接口后， `StandardWrapper` 会维护一组 Servlet 实例，这是享元模式。当然了 `SingleThreadModel` 在 Servlet 2.4 以后就弃用了。\n\n7.  `createFilterChain()` 方法会从 `StandardContext` 中获取到所有的过滤器，然后将匹配 Request URL 的所有过滤器挑选出来添加到 `filterChain` 中。\n\n8.  `doFilter()` 执行过滤链, 当所有的过滤器都执行完毕后调用 Servlet 的 `service()` 方法。\n\n# Reference\n\n1.  《How Tomcat works》\n\n2.  《Tomcat 架构解析》-- 刘光瑞\n\n3.  Tomcat-9.0-doc\n\n4.  apache-tomcat-9.0.0.M22-src\n\n5.  tomcat 架构分析 (connector NIO 实现)",[[1573954723242,["GJX@GJXAIOUPC",[[-1,0,"#"]],[1,1],[0,0]]],[1573954731882,["GJX@GJXAIOUPC",[[-1,2,"6张时序图！谈谈"]],[2,10],[2,2]]],[1573954758478,["GJX@GJXAIOUPC",[[-1,307,"*   Overview\n\n*   Connector Init and Start\n\n*   Requtst Process\n\n*   Acceptor\n\n*   Poller\n\n*   Worker\n\n*   Container\n\n*   At last"]],[307,436],[307,307]]],[1573954761814,["GJX@GJXAIOUPC",[[-1,89," "],[1,90," "],[-1,98," + "],[1,101," + "],[-1,119," + "],[1,122," + "],[-1,176," "],[1,177," "],[-1,201," "],[1,202," "],[-1,242," "],[1,243," "],[-1,253," "],[1,254," "],[-1,290," "],[1,291," "],[1,312,"y"],[-1,559," "],[1,560," "],[-1,586," "],[1,587," "],[-1,595," "],[1,596," "],[-1,603," "],[1,604," "],[-1,612," "],[1,613," "],[-1,634," "],[1,635," "],[-1,688," "],[1,689," "],[-1,697," "],[1,698," "],[-1,722," "],[1,723," "],[-1,797," "],[1,798," "],[-1,807," "],[1,808," "],[-1,816," 所在的 "],[1,821," 所在的 "],[-1,841," "],[1,842," "],[-1,846," "],[1,847," "],[-1,860," "],[1,861," "],[-1,1100," "],[1,1101," "],[-1,1129," "],[1,1130," "],[-1,1204," "],[1,1205," "],[-1,1222," 中 "],[1,1225," 中 "],[-1,1236," 的 "],[1,1239," 的 "],[-1,1252," "],[1,1253," "],[-1,1286," "],[1,1287," "],[-1,1291," "],[1,1292," "],[-1,1300," "],[1,1301," "],[-1,1315," "],[1,1316," "],[-1,1324," "],[1,1325," "],[-1,1369," "],[1,1370," "],[-1,1387," 中 "],[1,1390," 中 "],[-1,1401," 的 "],[1,1404," 的 "],[-1,1421," 和 "],[1,1424," 和 "],[-1,1436," "],[1,1437," "],[-1,1462," "],[1,1463," "],[-1,1479," "],[1,1480," "],[-1,1492," "],[1,1493," "],[-1,1559," "],[1,1560," "],[-1,1579," "],[1,1580," "],[-1,1600," "],[1,1601," "],[-1,1625," "],[1,1626," "],[-1,1647," "],[1,1648," "],[-1,1884," "],[1,1885," "],[-1,1893," "],[1,1894," "],[-1,1925," "],[1,1926," "],[-1,1946," "],[1,1947," "],[-1,1994," "],[1,1995," "],[-1,2007," "],[1,2008," "],[-1,2014," "],[1,2015," "],[-1,2043," "],[1,2044," "],[-1,2052," "],[1,2053," "],[-1,2073," "],[1,2074," "],[-1,2082," 的。 "],[1,2086," 的。 "],[-1,2099," "],[1,2100," "],[-1,2105," "],[1,2106," "],[-1,2114," "],[1,2115," "],[-1,2126," "],[1,2127," "],[-1,2143," "],[1,2144," "],[-1,2156," "],[1,2157," "],[-1,2211," "],[1,2212," "],[-1,2228," "],[1,2229," "],[-1,2237," 的 "],[1,2240," 的 "],[-1,2253," "],[1,2254," "],[-1,2260," "],[1,2261," "],[-1,2271," "],[1,2272," "],[-1,2509," "],[1,2510," "],[-1,2518," "],[1,2519," "],[-1,2542," "],[1,2543," "],[-1,2571," "],[1,2572," "],[-1,2580," "],[1,2581," "],[-1,2600," "],[1,2601," "],[-1,2647," "],[1,2648," "],[-1,2654," "],[1,2655," "],[-1,2667," "],[1,2668," "],[-1,2690," "],[1,2691," "],[-1,2724," "],[1,2725," "],[-1,2733," "],[1,2734," "],[-1,2772," "],[1,2773," "],[-1,2787," "],[1,2788," "],[-1,2805," 中， "],[1,2809," 中， "],[-1,2826," 实现了 "],[1,2831," 实现了 "],[-1,2841," 接口。 "],[1,2846," 接口。 "],[-1,2854," "],[1,2855," "],[-1,2862," "],[1,2863," "],[-1,2870," "],[1,2871," "],[-1,2920," 方法将 "],[1,2925," 方法将 "],[-1,2942," "],[1,2943," "],[-1,2956," "],[1,2957," "],[-1,2968," 中。 "],[1,2972," 中。 "],[-1,2983," 是 "],[1,2986," 是 "],[-1,3001," "],[1,3002," "],[-1,3008," "],[1,3009," "],[-1,3017," "],[1,3018," "],[-1,3233," "],[1,3234," "],[-1,3244," "],[1,3245," "],[-1,3265," 的 "],[1,3268," 的 "],[-1,3281," "],[1,3282," "],[-1,3288," "],[1,3289," "],[-1,3300," "],[1,3301," "],[-1,3314," "],[1,3315," "],[-1,3326," "],[1,3327," "],[-1,3333," "],[1,3334," "],[-1,3342," "],[1,3343," "],[-1,3349," "],[1,3350," "],[-1,3368," "],[1,3369," "],[-1,3385," "],[1,3386," "],[-1,3399," "],[1,3400," "],[-1,3418," "],[1,3419," "],[-1,3426," "],[1,3427," "],[-1,3441," "],[1,3442," "],[-1,3463," "],[1,3464," "],[-1,3472," "],[1,3473," "],[-1,3477," "],[1,3478," "],[-1,3495," 的 "],[1,3498," 的 "],[-1,3505," "],[1,3506," "],[-1,3547," "],[1,3548," "],[-1,3553," "],[1,3554," "],[-1,3602," "],[1,3603," "],[-1,3612," "],[1,3613," "],[-1,3619," "],[1,3620," "],[-1,3629," "],[1,3630," "],[-1,3646," "],[1,3647," "],[-1,3701," "],[1,3702," "],[-1,3740," "],[1,3741," "],[-1,3748," "],[1,3749," "],[-1,3759," "],[1,3760," "],[-1,3792," "],[1,3793," "],[-1,3805," "],[1,3806," "],[-1,3817," "],[1,3818," "],[-1,3825," "],[1,3826," "],[-1,3853," 封装到 "],[1,3858," 封装到 "],[-1,3901," "],[1,3902," "],[-1,3913," "],[1,3914," "],[-1,3927," "],[1,3928," "],[-1,4020," "],[1,4021," "],[-1,4029," "],[1,4030," "],[-1,4052," "],[1,4053," "],[-1,4092," 中， "],[1,4096," 中， "],[-1,4107," "],[1,4108," "],[-1,4112," "],[1,4113," "],[-1,4132," "],[1,4133," "],[-1,4156," "],[1,4157," "],[-1,4180," "],[1,4181," "],[-1,4203," "],[1,4204," "],[-1,4286," "],[1,4287," "],[-1,4294," "],[1,4295," "],[-1,4306," "],[1,4307," "],[-1,4313," "],[1,4314," "],[-1,4325," "],[1,4326," "],[-1,4331," "],[1,4332," "],[-1,4340," "],[1,4341," "],[-1,4589," "],[1,4590," "],[-1,4608," "],[1,4609," "],[-1,4619," "],[1,4620," "],[-1,4739," "],[1,4740," "],[-1,4746," "],[1,4747," "],[-1,4838," "],[1,4839," "],[-1,4845," "],[1,4846," "],[-1,4941," "],[1,4942," "],[-1,4948," "],[1,4949," "],[-1,4994," "],[1,4995," "],[-1,5012," "],[1,5013," "],[-1,5027," "],[1,5028," "],[-1,5068," "],[1,5069," "],[-1,5077," "],[1,5078," "],[-1,5124," "],[1,5125," "],[-1,5144," "],[1,5145," "],[-1,5149," "],[1,5150," "],[-1,5167," "],[1,5168," "],[-1,5195," "],[1,5196," "],[-1,5215," "],[1,5216," "],[-1,5264," "],[1,5265," "],[-1,5269," "],[1,5270," "],[-1,5287," "],[1,5288," "],[-1,5330," "],[1,5331," "],[-1,5344," "],[1,5345," "],[-1,5365," "],[1,5366," "],[-1,5398," "],[1,5399," "],[-1,5410," "],[1,5411," "]],[312,312],[313,313]]],[1573954761871,["GJX@GJXAIOUPC",[[1,313,"i"]],[313,313],[314,314]]],[1573954762710,["GJX@GJXAIOUPC",[[-1,312,"yi"]],[314,314],[312,312]]],[1573954763744,["GJX@GJXAIOUPC",[[1,312,"一 "]],[312,312],[313,313]]],[1573954763951,["GJX@GJXAIOUPC",[[1,313,"、"]],[313,313],[314,314]]]],null,"GJX@GJXAIOUPC"]]}