{"compress":true,"commitItems":[["ca620622-a099-4fed-ba64-0959d6322a52",1563797425441,"# Java 中的代理模式及动态代理\n\n置顶 2017年06月29日 22:08:55 [frank909](https://me.csdn.net/briblue) 阅读数 53287 标签： [java](https://so.csdn.net/so/search/s.do?q=java&t=blog)[动态代理](https://so.csdn.net/so/search/s.do?q=%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86&t=blog)[代理模式](https://so.csdn.net/so/search/s.do?q=%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F&t=blog)[静态代理](https://so.csdn.net/so/search/s.do?q=%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&t=blog) 更多\n\n个人分类： [Java 基础知识](https://blog.csdn.net/briblue/article/category/6874678)[Java 反射 3 板斧](https://blog.csdn.net/briblue/article/category/7012073)\n\n所属专栏： [Java 反射基础知识与实战](https://blog.csdn.net/column/details/16732.html)\n\n 版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/briblue/article/details/73928350\n\n前几天我写了[《秒懂，Java 注解 （Annotation）你可以这样学》](http://blog.csdn.net/briblue/article/details/73824058)，因为注解其实算反射技术中的一部分，然后我想了一下，反射技术中还有个常见的概念就是动态代理，于是索性再写一篇关于动态代理的博文好了。\n\n我们先来分析代理这个词。\n\n# 代理\n\n代理是英文 Proxy 翻译过来的。我们在生活中见到过的代理，大概最常见的就是朋友圈中卖面膜的同学了。\n\n她们从厂家拿货，然后在朋友圈中宣传，然后卖给熟人。\n\n![这里写图片描述](https://img-blog.csdn.net/20170629213911162?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n按理说，顾客可以直接从厂家购买产品，但是现实生活中，很少有这样的销售模式。一般都是厂家委托给代理商进行销售，顾客跟代理商打交道，而不直接与产品实际生产者进行关联。\n\n所以，代理就有一种中间人的味道。\n\n接下来，我们说说软件中的代理模式。\n\n# 代理模式\n\n代理模式是面向对象编程中比较常见的设计模式。\n![这里写图片描述](https://img-blog.csdn.net/20170629213938736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这是常见代理模式常见的 UML 示意图。\n\n需要注意的有下面几点：\n\n1.  用户只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。\n2.  接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。\n3.  代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。\n4.  用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。\n\n如果难于理解的话，我用事例说明好了。值得注意的是，代理可以分为静态代理和动态代理两种。先从静态代理讲起。\n\n# 静态代理\n\n我们平常去电影院看电影的时候，在电影开始的阶段是不是经常会放广告呢？\n\n电影是电影公司委托给影院进行播放的，但是影院可以在播放电影的时候，产生一些自己的经济收益，比如卖爆米花、可乐等，然后在影片开始结束时播放一些广告。\n\n现在用代码来进行模拟。\n\n首先得有一个接口，通用的接口是代理模式实现的基础。这个接口我们命名为 Movie，代表电影播放的能力。\n\n```java\n\npackage com.frank.test;\n\npublic interface Movie {\n\tvoid play();\n}\n\n1234567\n```\n\n然后，我们要有一个真正的实现这个 Movie 接口的类，和一个只是实现接口的代理类。\n\n```java\npackage com.frank.test;\n\npublic class RealMovie implements Movie {\n\n\t@Override\n\tpublic void play() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"您正在观看电影 《肖申克的救赎》\");\n\t}\n\n}\n1234567891011\n```\n\n这个表示真正的影片。它实现了 Movie 接口，play() 方法调用时，影片就开始播放。那么 Proxy 代理呢？\n\n```java\npackage com.frank.test;\n\npublic class Cinema implements Movie {\n\n\tRealMovie movie;\n\n\tpublic Cinema(RealMovie movie) {\n\t\tsuper();\n\t\tthis.movie = movie;\n\t}\n\n\t@Override\n\tpublic void play() {\n\n\t\tguanggao(true);\n\n\t\tmovie.play();\n\n\t\tguanggao(false);\n\t}\n\n\tpublic void guanggao(boolean isStart){\n\t\tif ( isStart ) {\n\t\t\tSystem.out.println(\"电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！\");\n\t\t} else {\n\t\t\tSystem.out.println(\"电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！\");\n\t\t}\n\t}\n\n}\n\n1234567891011121314151617181920212223242526272829303132\n```\n\nCinema 就是 Proxy 代理对象，它有一个 play() 方法。不过调用 play() 方法时，它进行了一些相关利益的处理，那就是广告。现在，我们编写测试代码。\n\n```java\npackage com.frank.test;\n\npublic class ProxyTest {\n\n\tpublic static void main(String[] args) {\n\n\t\tRealMovie realmovie = new RealMovie();\n\n\t\tMovie movie = new Cinema(realmovie);\n\n\t\tmovie.play();\n\n\t}\n\n}\n\n12345678910111213141516\n```\n\n然后观察结果：\n\n```\n电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！\n您正在观看电影 《肖申克的救赎》\n电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！\n\n```\n\n现在可以看到，**代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。**\n\n上面介绍的是静态代理的内容，为什么叫做静态呢？因为它的类型是事先预定好的，比如上面代码中的 Cinema 这个类。下面要介绍的内容就是动态代理。\n\n# 动态代理\n\n既然是代理，那么它与静态代理的功能与目的是没有区别的，唯一有区别的就是动态与静态的差别。\n\n那么在动态代理的中这个动态体现在什么地方？\n\n上一节代码中 Cinema 类是代理，我们需要手动编写代码让 Cinema 实现 Movie 接口，而在动态代理中，我们可以让程序在运行的时候自动在内存中创建一个实现 Movie 接口的代理，而不需要去定义 Cinema 这个类。这就是它被称为动态的原因。\n\n也许概念比较抽象。现在实例说明一下情况。\n\n假设有一个大商场，商场有很多的柜台，有一个柜台卖茅台酒。我们进行代码的模拟。\n\n```java\npackage com.frank.test;\n\npublic interface SellWine {\n\n\t void mainJiu();\n\n}\n1234567\n```\n\nSellWine 是一个接口，你可以理解它为卖酒的许可证。\n\n```java\npackage com.frank.test;\n\npublic class MaotaiJiu implements SellWine {\n\n\t@Override\n\tpublic void mainJiu() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"我卖得是茅台酒。\");\n\n\t}\n\n}\n\n12345678910111213\n```\n\n然后创建一个类 MaotaiJiu,对的，就是茅台酒的意思。\n\n我们还需要一个柜台来卖酒：\n\n```java\npackage com.frank.test;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class GuitaiA implements InvocationHandler {\n\n\tprivate Object pingpai;\n\n\tpublic GuitaiA(Object pingpai) {\n\t\tthis.pingpai = pingpai;\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"销售开始  柜台是： \"+this.getClass().getSimpleName());\n\t\tmethod.invoke(pingpai, args);\n\t\tSystem.out.println(\"销售结束\");\n\t\treturn null;\n\t}\n\n}\n\n12345678910111213141516171819202122232425262728\n```\n\nGuitaiA 实现了 InvocationHandler 这个类，这个类是什么意思呢？大家不要慌张，待会我会解释。\n\n然后，我们就可以卖酒了。\n\n```java\npackage com.frank.test;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tMaotaiJiu maotaijiu = new MaotaiJiu();\n\n\t\tInvocationHandler jingxiao1 = new GuitaiA(maotaijiu);\n\n\t\tSellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao1);\n\n\t\tdynamicProxy.mainJiu();\n\n\t}\n\n}\n\n1234567891011121314151617181920212223242526\n```\n\n这里，我们又接触到了一个新的概念，没有关系，先别管，先看结果。\n\n```\n销售开始  柜台是： GuitaiA\n我卖得是茅台酒。\n销售结束\n\n```\n\n看到没有，我并没有像静态代理那样为 SellWine 接口实现一个代理类，但最终它仍然实现了相同的功能，这其中的差别，就是之前讨论的动态代理所谓“动态”的原因。\n\n## 动态代理语法\n\n放轻松，下面我们开始讲解语法，语法非常简单。\n\n动态代码涉及了一个非常重要的类 Proxy。正是通过 Proxy 的静态方法 newProxyInstance 才会动态创建代理。\n\n### Proxy\n\n```java\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n\n1234\n```\n\n下面讲解它的 3 个参数意义。\n\n*   loader 自然是类加载器\n*   interfaces 代码要用来代理的接口\n*   h 一个 InvocationHandler 对象\n\n初学者应该对于 InvocationHandler 很陌生，我马上就讲到这一块。\n\n### InvocationHandler\n\nInvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。\n\n```java\npublic interface InvocationHandler {\n\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n\n123456\n```\n\nInvocationHandler 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。\n\n*   proxy 代理对象\n*   method 代理对象调用的方法\n*   args 调用的方法中的参数\n\n因为，Proxy 动态产生的代理会调用 InvocationHandler 实现类，所以 InvocationHandler 是实际执行者。\n\n```java\npublic class GuitaiA implements InvocationHandler {\n\n\tprivate Object pingpai;\n\n\tpublic GuitaiA(Object pingpai) {\n\t\tthis.pingpai = pingpai;\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"销售开始  柜台是： \"+this.getClass().getSimpleName());\n\t\tmethod.invoke(pingpai, args);\n\t\tSystem.out.println(\"销售结束\");\n\t\treturn null;\n\t}\n\n}\n\n1234567891011121314151617181920212223\n```\n\nGuitaiA 就是实际上卖酒的地方。\n\n现在，我们加大难度，我们不仅要卖**茅台酒**，还想卖**五粮液**。\n\n```java\npackage com.frank.test;\n\npublic class Wuliangye implements SellWine {\n\n\t@Override\n\tpublic void mainJiu() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"我卖得是五粮液。\");\n\n\t}\n\n}\n\n12345678910111213\n```\n\nWuliangye 这个类也实现了 SellWine 这个接口，说明它也拥有卖酒的许可证，同样把它放到 GuitaiA 上售卖。\n\n```java\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tMaotaiJiu maotaijiu = new MaotaiJiu();\n\n\t\tWuliangye wu = new Wuliangye();\n\n\t\tInvocationHandler jingxiao1 = new GuitaiA(maotaijiu);\n\t\tInvocationHandler jingxiao2 = new GuitaiA(wu);\n\n\t\tSellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao1);\n\t\tSellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao2);\n\n\t\tdynamicProxy.mainJiu();\n\n\t\tdynamicProxy1.mainJiu();\n\n\t}\n\n}\n\n12345678910111213141516171819202122232425\n```\n\n我们来看结果：\n\n```\n销售开始  柜台是： GuitaiA\n我卖得是茅台酒。\n销售结束\n销售开始  柜台是： GuitaiA\n我卖得是五粮液。\n销售结束\n\n```\n\n有人会问，dynamicProxy 和 dynamicProxy1 什么区别没有？他们都是动态产生的代理，都是售货员，都拥有卖酒的技术证书。\n\n我现在扩大商场的经营，除了卖酒之外，还要卖烟。\n\n首先，同样要创建一个接口，作为卖烟的许可证。\n\n```java\npackage com.frank.test;\n\npublic interface SellCigarette {\n\tvoid sell();\n}\n\n123456\n```\n\n然后，卖什么烟呢？我是湖南人，那就芙蓉王好了。\n\n```java\npublic class Furongwang implements SellCigarette {\n\n\t@Override\n\tpublic void sell() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"售卖的是正宗的芙蓉王，可以扫描条形码查证。\");\n\t}\n\n}\n\n12345678910\n```\n\n然后再次测试验证：\n\n```java\npackage com.frank.test;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tMaotaiJiu maotaijiu = new MaotaiJiu();\n\n\t\tWuliangye wu = new Wuliangye();\n\n\t\tFurongwang fu = new Furongwang();\n\n\t\tInvocationHandler jingxiao1 = new GuitaiA(maotaijiu);\n\t\tInvocationHandler jingxiao2 = new GuitaiA(wu);\n\n\t\tInvocationHandler jingxiao3 = new GuitaiA(fu);\n\n\t\tSellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao1);\n\t\tSellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao2);\n\n\t\tdynamicProxy.mainJiu();\n\n\t\tdynamicProxy1.mainJiu();\n\n\t\tSellCigarette dynamicProxy3 = (SellCigarette) Proxy.newProxyInstance(Furongwang.class.getClassLoader(),\n\t\t\t\tFurongwang.class.getInterfaces(), jingxiao3);\n\n\t\tdynamicProxy3.sell();\n\n\t}\n\n}\n\n123456789101112131415161718192021222324252627282930313233343536373839\n```\n\n然后，查看结果：\n\n```\n销售开始  柜台是： GuitaiA\n我卖得是茅台酒。\n销售结束\n销售开始  柜台是： GuitaiA\n我卖得是五粮液。\n销售结束\n销售开始  柜台是： GuitaiA\n售卖的是正宗的芙蓉王，可以扫描条形码查证。\n销售结束\n\n```\n\n结果符合预期。大家仔细观察一下代码，同样是通过 Proxy.newProxyInstance() 方法，却产生了 SellWine 和 SellCigarette 两种接口的实现类代理，这就是动态代理的魔力。\n\n## 动态代理的秘密\n\n一定有同学对于为什么 Proxy 能够动态产生不同接口类型的代理感兴趣，我的猜测是肯定通过传入进去的接口然后通过反射动态生成了一个接口实例。\n比如 SellWine 是一个接口，那么 Proxy.newProxyInstance() 内部肯定会有\n\n```java\n\nnew SellWine();\n12\n```\n\n这样相同作用的代码，不过它是通过反射机制创建的。那么事实是不是这样子呢？直接查看它们的源码好了。需要说明的是，我当前查看的源码是 1.8 版本。\n\n```java\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n\n        final Class<?>[] intfs = interfaces.clone();\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n\n            return cons.newInstance(new Object[]{h});\n\n        } catch (IllegalAccessException|InstantiationException e) {\n            throw new InternalError(e.toString(), e);\n        } catch (InvocationTargetException e) {\n            Throwable t = e.getCause();\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            } else {\n                throw new InternalError(t.toString(), t);\n            }\n        } catch (NoSuchMethodException e) {\n            throw new InternalError(e.toString(), e);\n        }\n    }\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849\n```\n\nnewProxyInstance 的确创建了一个实例，它是通过 cl 这个 Class 文件的构造方法反射生成。cl 由 getProxyClass0() 方法获取。\n\n```java\nprivate static Class<?> getProxyClass0(ClassLoader loader,\n                                       Class<?>... interfaces) {\n    if (interfaces.length > 65535) {\n        throw new IllegalArgumentException(\"interface limit exceeded\");\n    }\n\n    // If the proxy class defined by the given loader implementing\n    // the given interfaces exists, this will simply return the cached copy;\n    // otherwise, it will create the proxy class via the ProxyClassFactory\n    return proxyClassCache.get(loader, interfaces);\n}\n\n123456789101112\n```\n\n直接通过缓存获取，如果获取不到，注释说会通过 ProxyClassFactory 生成。\n\n```java\n/**\n     * A factory function that generates, defines and returns the proxy class given\n     * the ClassLoader and array of interfaces.\n     */\n    private static final class ProxyClassFactory\n        implements BiFunction<ClassLoader, Class<?>[], Class<?>>\n    {\n        // Proxy class 的前缀是 “$Proxy”，\n        private static final String proxyClassNamePrefix = \"$Proxy\";\n\n        // next number to use for generation of unique proxy class names\n        private static final AtomicLong nextUniqueNumber = new AtomicLong();\n\n        @Override\n        public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\n            Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n            for (Class<?> intf : interfaces) {\n                /*\n                 * Verify that the class loader resolves the name of this\n                 * interface to the same Class object.\n                 */\n                Class<?> interfaceClass = null;\n                try {\n                    interfaceClass = Class.forName(intf.getName(), false, loader);\n                } catch (ClassNotFoundException e) {\n                }\n                if (interfaceClass != intf) {\n                    throw new IllegalArgumentException(\n                        intf + \" is not visible from class loader\");\n                }\n                /*\n                 * Verify that the Class object actually represents an\n                 * interface.\n                 */\n                if (!interfaceClass.isInterface()) {\n                    throw new IllegalArgumentException(\n                        interfaceClass.getName() + \" is not an interface\");\n                }\n                /*\n                 * Verify that this interface is not a duplicate.\n                 */\n                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {\n                    throw new IllegalArgumentException(\n                        \"repeated interface: \" + interfaceClass.getName());\n                }\n            }\n\n            String proxyPkg = null;     // package to define proxy class in\n            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n\n            /*\n             * Record the package of a non-public proxy interface so that the\n             * proxy class will be defined in the same package.  Verify that\n             * all non-public proxy interfaces are in the same package.\n             */\n            for (Class<?> intf : interfaces) {\n                int flags = intf.getModifiers();\n                if (!Modifier.isPublic(flags)) {\n                    accessFlags = Modifier.FINAL;\n                    String name = intf.getName();\n                    int n = name.lastIndexOf('.');\n                    String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1));\n                    if (proxyPkg == null) {\n                        proxyPkg = pkg;\n                    } else if (!pkg.equals(proxyPkg)) {\n                        throw new IllegalArgumentException(\n                            \"non-public interfaces from different packages\");\n                    }\n                }\n            }\n\n            if (proxyPkg == null) {\n                // if no non-public proxy interfaces, use com.sun.proxy package\n                proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\";\n            }\n\n            /*\n             * Choose a name for the proxy class to generate.\n             */\n            long num = nextUniqueNumber.getAndIncrement();\n            String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n            /*\n             * Generate the specified proxy class.\n             */\n            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n                proxyName, interfaces, accessFlags);\n            try {\n                return defineClass0(loader, proxyName,\n                                    proxyClassFile, 0, proxyClassFile.length);\n            } catch (ClassFormatError e) {\n                /*\n                 * A ClassFormatError here means that (barring bugs in the\n                 * proxy class generation code) there was some other\n                 * invalid aspect of the arguments supplied to the proxy\n                 * class creation (such as virtual machine limitations\n                 * exceeded).\n                 */\n                throw new IllegalArgumentException(e.toString());\n            }\n        }\n    }\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105\n```\n\n这个类的注释说，通过指定的 ClassLoader 和 接口数组 用工厂方法生成 proxy class。 然后这个 proxy class 的名字是：\n\n```java\n\n// Proxy class 的前缀是 “$Proxy”，\nprivate static final String proxyClassNamePrefix = \"$Proxy\";\n\nlong num = nextUniqueNumber.getAndIncrement();\n\nString proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n12345678\n```\n\n所以，动态生成的代理类名称是**包名+$Proxy+id序号**。\n\n生成的过程，核心代码如下：\n\n```java\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n                proxyName, interfaces, accessFlags);\n\nreturn defineClass0(loader, proxyName,\n                    proxyClassFile, 0, proxyClassFile.length);\n\n1234567\n```\n\n这两个方法，我没有继续追踪下去，defineClass0() 甚至是一个 native 方法。我们只要知道，动态创建代理这回事就好了。\n\n现在我们还需要做一些验证，我要检测一下动态生成的代理类的名字是不是**包名+$Proxy+id序号**。\n\n```java\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tMaotaiJiu maotaijiu = new MaotaiJiu();\n\n\t\tWuliangye wu = new Wuliangye();\n\n\t\tFurongwang fu = new Furongwang();\n\n\t\tInvocationHandler jingxiao1 = new GuitaiA(maotaijiu);\n\t\tInvocationHandler jingxiao2 = new GuitaiA(wu);\n\n\t\tInvocationHandler jingxiao3 = new GuitaiA(fu);\n\n\t\tSellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao1);\n\t\tSellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao2);\n\n\t\tdynamicProxy.mainJiu();\n\n\t\tdynamicProxy1.mainJiu();\n\n\t\tSellCigarette dynamicProxy3 = (SellCigarette) Proxy.newProxyInstance(Furongwang.class.getClassLoader(),\n\t\t\t\tFurongwang.class.getInterfaces(), jingxiao3);\n\n\t\tdynamicProxy3.sell();\n\n\t\tSystem.out.println(\"dynamicProxy class name:\"+dynamicProxy.getClass().getName());\n\t\tSystem.out.println(\"dynamicProxy1 class name:\"+dynamicProxy1.getClass().getName());\n\t\tSystem.out.println(\"dynamicProxy3 class name:\"+dynamicProxy3.getClass().getName());\n\n\t}\n\n}\n\n1234567891011121314151617181920212223242526272829303132333435363738\n```\n\n结果如下：\n\n```\n销售开始  柜台是： GuitaiA\n我卖得是茅台酒。\n销售结束\n销售开始  柜台是： GuitaiA\n我卖得是五粮液。\n销售结束\n销售开始  柜台是： GuitaiA\n售卖的是正宗的芙蓉王，可以扫描条形码查证。\n销售结束\n\ndynamicProxy class name:com.sun.proxy.$Proxy0\ndynamicProxy1 class name:com.sun.proxy.$Proxy0\ndynamicProxy3 class name:com.sun.proxy.$Proxy1\n\n```\n\nSellWine 接口的代理类名是：`com.sun.proxy.$Proxy0`\nSellCigarette 接口的代理类名是：`com.sun.proxy.$Proxy1`\n\n这说明动态生成的 proxy class 与 Proxy 这个类同一个包。\n\n下面用一张图让大家记住动态代理涉及到的角色。\n![这里写图片描述](https://img-blog.csdn.net/20170629220323673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n红框中 `$Proxy0`就是通过 Proxy 动态生成的。\n`$Proxy0`实现了要代理的接口。\n`$Proxy0`通过调用 `InvocationHandler`来执行任务。\n\n# 代理的作用\n\n可能有同学会问，已经学习了代理的知识，但是，它们有什么用呢？\n\n主要作用，还是在不修改被代理对象的源码上，进行功能的增强。\n\n这在 AOP 面向切面编程领域经常见。\n\n> 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n> 主要功能\n> 日志记录，性能统计，安全控制，事务处理，异常处理等等。\n\n上面的引用是百度百科对于 AOP 的解释，至于，如何通过代理来进行日志记录功能、性能统计等等，这个大家可以参考 AOP 的相关源码，然后仔细琢磨。\n\n同注解一样，很多同学可能会有疑惑，我什么时候用代理呢？\n\n这取决于你自己想干什么。你已经学会了语法了，其他的看业务需求。对于实现日志记录功能的框架来说，正合适。\n\n至此，静态代理和动态代理者讲完了。\n\n# 总结\n\n1.  代理分为静态代理和动态代理两种。\n2.  静态代理，代理类需要自己编写代码写成。\n3.  动态代理，代理类通过 Proxy.newInstance() 方法生成。\n4.  不管是静态代理还是动态代理，代理与被代理者都要实现两样接口，它们的实质是面向接口编程。\n5.  静态代理和动态代理的区别是在于要不要开发者自己定义 Proxy 类。\n6.  动态代理通过 Proxy 动态生成 proxy class，但是它也指定了一个 InvocationHandler 的实现类。\n7.  代理模式本质上的目的是为了增强现有代码的功能。",[[1563797414420,["GJX@GJXAIOU",[[-1,20,"置顶 2017年06月29日 22:08:55 [frank909](https://me.csdn.net/briblue) 阅读数 53287 标签： [java](https://so.csdn.net/so/search/s.do?q=java&t=blog)[动态代理](https://so.csdn.net/so/search/s.do?q=%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86&t=blog)[代理模式](https://so.csdn.net/so/search/s.do?q=%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F&t=blog)[静态代理](https://so.csdn.net/so/search/s.do?q=%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&t=blog) 更多\n\n个人分类： [Java 基础知识](https://blog.csdn.net/briblue/article/category/6874678)[Java 反射 3 板斧](https://blog.csdn.net/briblue/article/category/7012073)\n\n所属专栏： [Java 反射基础知识与实战](https://blog.csdn.net/column/details/16732.html)\n\n 版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/briblue/article/details/73928350\n\n前几天我写了[《秒懂，Java 注解 （Annotation）你可以这样学》](http://blog.csdn.net/briblue/article/details/73824058)，因为注解其实算反射技术中的一部分，然后我想了一下，反射技术中还有个常见的概念就是动态代理，于是索性再写一篇关于动态代理的博文好了。\n\n我们先来分析代理这个词。"]],[20,899],[20,20]]],[1563797436520,["GJX@GJXAIOU",[[1,20,"[原文地址链接](https://blog.csdn.net/briblue/article/details/73928350)"]],[20,20],[84,84]]],[1563797456849,["GJX@GJXAIOU",[[-1,1524,"1234567891011"]],[1524,1537],[1524,1524]]],[1563797459298,["GJX@GJXAIOU",[[-1,1273,"1234567"]],[1273,1280],[1273,1273]]],[1563797459850,["GJX@GJXAIOU",[[-1,1273,"\n"]],[1273,1273],[1272,1272]]],[1563797461706,["GJX@GJXAIOU",[[-1,1205,"\n"]],[1205,1205],[1204,1204]]],[1563797481611,["GJX@GJXAIOU",[[-1,2029,"1234567891011121314151617181920212223242526272829303132"]],[2029,2084],[2029,2029]]],[1563797482483,["GJX@GJXAIOU",[[-1,2029,"\n"]],[2029,2029],[2028,2028]]],[1563797491316,["GJX@GJXAIOU",[[1,1652," "],[-1,18756," "],[1,18757," "],[-1,18817," "],[1,18818," "]],[1652,1652],[1653,1653]]],[1563797492076,["GJX@GJXAIOU",[[1,1653,"。"]],[1653,1653],[1654,1654]]],[1563797492908,["GJX@GJXAIOU",[[-1,1653,"。"]],[1654,1654],[1653,1653]]],[1563797494024,["GJX@GJXAIOU",[[1,1653,"./."]],[1653,1653],[1656,1656]]],[1563797495928,["GJX@GJXAIOU",[[-1,1653,"./."]],[1656,1656],[1653,1653]]],[1563797504271,["GJX@GJXAIOU",[[1,1653,"//同样实现接口的功能"]],[1653,1653],[1664,1664]]],[1563797508218,["GJX@GJXAIOU",[[-1,1665,"\n"]],[1665,1665],[1664,1664]]],[1563797510504,["GJX@GJXAIOU",[[-1,1788,"\n"]],[1788,1788],[1787,1787]]],[1563797511377,["GJX@GJXAIOU",[[-1,1806,"\n"]],[1806,1806],[1805,1805]]],[1563797512202,["GJX@GJXAIOU",[[-1,1822,"\n"]],[1822,1822],[1821,1821]]],[1563797522154,["GJX@GJXAIOU",[[-1,2229,"\n"]],[2229,2229],[2228,2228]]],[1563797523890,["GJX@GJXAIOU",[[-1,2186,"\n"]],[2186,2186],[2185,2185]]],[1563797533072,["GJX@GJXAIOU",[[-1,2269,"\n"]],[2269,2269],[2268,2268]]],[1563797533906,["GJX@GJXAIOU",[[-1,2308,"\n"]],[2308,2308],[2307,2307]]],[1563797535257,["GJX@GJXAIOU",[[-1,2332,"12345678910111213141516"]],[2332,2355],[2332,2332]]],[1563797536417,["GJX@GJXAIOU",[[-1,2328,"\n"]],[2328,2328],[2327,2327]]],[1563797537218,["GJX@GJXAIOU",[[-1,2324,"\n"]],[2324,2324],[2323,2323]]],[1563797538313,["GJX@GJXAIOU",[[-1,2330,"\n"]],[2330,2330],[2329,2329]]],[1563797538744,["GJX@GJXAIOU",[[-1,2329,"\n"]],[2329,2329],[2328,2328]]],[1563797541064,["GJX@GJXAIOU",[[-1,2342,"\n"]],[2342,2342],[2341,2341]]],[1563797551562,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1563797553284,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1563797553432,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1563797553586,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1563797553758,["GJX@GJXAIOU",[[1,4,"\n---\n\n"]],[3,3],[4,4]]],[1563797562317,["GJX@GJXAIOU",[[1,4,"style："]],[4,4],[10,10]]],[1563797563539,["GJX@GJXAIOU",[[-1,8,"e："]],[10,10],[8,8]]],[1563797567538,["GJX@GJXAIOU",[[1,8,"e: sume"]],[8,8],[15,15]]],[1563797568897,["GJX@GJXAIOU",[[-1,14,"e"]],[15,15],[14,14]]],[1563797570686,["GJX@GJXAIOU",[[1,14,"mer"]],[14,14],[17,17]]],[1563797571041,["GJX@GJXAIOU",[[1,18,"\n"]],[17,17],[18,18]]],[1563797626475,["GJX@GJXAIOU",[[1,18,"fls"]],[18,18],[21,21]]],[1563797627399,["GJX@GJXAIOU",[[-1,20,"s"]],[21,21],[20,20]]],[1563797627937,["GJX@GJXAIOU",[[1,20,"agf"]],[20,20],[23,23]]],[1563797628920,["GJX@GJXAIOU",[[-1,22,"f"]],[23,23],[22,22]]],[1563797633963,["GJX@GJXAIOU",[[1,22,": yellow"]],[22,22],[30,30]]],[1563797637671,["GJX@GJXAIOU",[[-1,24,"yellow"]],[30,30],[24,24]]],[1563797638810,["GJX@GJXAIOU",[[1,24,"red"]],[24,24],[27,27]]],[1563797646784,["GJX@GJXAIOU",[[1,28,"\n"]],[27,27],[28,28]]],[1563797649915,["GJX@GJXAIOU",[[1,28,"tags: "]],[28,28],[34,34]]],[1563797650320,["GJX@GJXAIOU",[[1,35,"\n"]],[34,34],[35,35]]],[1563797652790,["GJX@GJXAIOU",[[1,35,"- weikan"]],[35,35],[43,43]]],[1563797654842,["GJX@GJXAIOU",[[-1,37,"weikan"]],[43,43],[37,37]]],[1563797656700,["GJX@GJXAIOU",[[1,37,"代理"]],[37,37],[39,39]]],[1563797657345,["GJX@GJXAIOU",[[1,40,"\n"]],[39,39],[40,40]]],[1563797659800,["GJX@GJXAIOU",[[1,40,"未看完"]],[40,40],[43,43]]],[1563797662759,["GJX@GJXAIOU",[[1,40,"- "]],[40,40],[42,42]]],[1563797675825,["GJX@GJXAIOU",[[-1,3234,"12345678910111213"]],[3234,3251],[3234,3234]]],[1563797680359,["GJX@GJXAIOU",[[-1,2996,"1234567"]],[3003,3003],[2996,2996]]],[1563797680992,["GJX@GJXAIOU",[[-1,2996,"\n"]],[2996,2996],[2995,2995]]],[1563797682816,["GJX@GJXAIOU",[[-1,3222,"\n"]],[3222,3222],[3221,3221]]],[1563797683800,["GJX@GJXAIOU",[[-1,3225,"\n"]],[3224,3224],[3223,3223]]],[1563797684762,["GJX@GJXAIOU",[[-1,3224,"\n"]],[3224,3224],[3223,3223]]],[1563797690008,["GJX@GJXAIOU",[[-1,3818,"12345678910111213141516171819202122232425262728"]],[3818,3865],[3818,3818]]],[1563797690609,["GJX@GJXAIOU",[[-1,3818,"\n"]],[3818,3818],[3817,3817]]],[1563797691328,["GJX@GJXAIOU",[[-1,3817,"\n"]],[3817,3817],[3816,3816]]],[1563797694999,["GJX@GJXAIOU",[[-1,4383,"1234567891011121314151617181920212223242526\n"]],[4382,4426],[4382,4382]]],[1563797695587,["GJX@GJXAIOU",[[-1,4382,"\n"]],[4382,4382],[4381,4381]]],[1563797698640,["GJX@GJXAIOU",[[-1,4457,"\n"]],[4457,4457],[4456,4456]]],[1563797702056,["GJX@GJXAIOU",[[-1,4852,"1234"]],[4852,4856],[4852,4852]]],[1563797702986,["GJX@GJXAIOU",[[-1,4852,"\n"]],[4851,4851],[4850,4850]]],[1563797704056,["GJX@GJXAIOU",[[-1,4830,"I"]],[4831,4831],[4830,4830]]],[1563797706224,["GJX@GJXAIOU",[[1,4830,"I"]],[4830,4830],[4831,4831]]],[1563797709224,["GJX@GJXAIOU",[[-1,4827,"   "]],[4791,4791],[4788,4788]]],[1563797709776,["GJX@GJXAIOU",[[-1,4787,"\n"]],[4788,4788],[4787,4787]]],[1563797711601,["GJX@GJXAIOU",[[-1,4763,"  "]],[4725,4725],[4723,4723]]],[1563797712266,["GJX@GJXAIOU",[[-1,4722,"\n"]],[4723,4723],[4722,4722]]],[1563797722320,["GJX@GJXAIOU",[[-1,5281,"123456"]],[5281,5287],[5281,5281]]],[1563797727530,["GJX@GJXAIOU",[[-1,5920,"1234567891011121314151617181920212223"]],[5920,5957],[5920,5920]]],[1563797728207,["GJX@GJXAIOU",[[-1,5920,"\n"]],[5920,5920],[5919,5919]]],[1563797728680,["GJX@GJXAIOU",[[-1,5919,"\n"]],[5919,5919],[5918,5918]]],[1563797731185,["GJX@GJXAIOU",[[-1,6176,"12345678910111213"]],[6176,6193],[6176,6176]]],[1563797731545,["GJX@GJXAIOU",[[-1,6176,"\n"]],[6176,6176],[6175,6175]]],[1563797735455,["GJX@GJXAIOU",[[-1,6889,"12345678910111213141516171819202122232425"]],[6889,6930],[6889,6889]]],[1563797736384,["GJX@GJXAIOU",[[-1,6889,"\n"]],[6889,6889],[6888,6888]]],[1563797736929,["GJX@GJXAIOU",[[-1,6888,"\n"]],[6888,6888],[6887,6887]]],[1563797739224,["GJX@GJXAIOU",[[-1,6972,"\n"]],[6972,6972],[6971,6971]]],[1563797741384,["GJX@GJXAIOU",[[-1,7180,"\n"]],[7180,7180],[7179,7179]]],[1563797742808,["GJX@GJXAIOU",[[-1,7180,"123456"]],[7180,7186],[7180,7180]]],[1563797743337,["GJX@GJXAIOU",[[-1,7180,"\n"]],[7180,7180],[7179,7179]]],[1563797745799,["GJX@GJXAIOU",[[-1,7394,"12345678910\n"]],[7393,7405],[7393,7393]]],[1563797746250,["GJX@GJXAIOU",[[-1,7393,"\n"]],[7393,7393],[7392,7392]]],[1563797750696,["GJX@GJXAIOU",[[-1,8421,"123456789101112131415161718192021222324252627282930313233343536373839\n"]],[8420,8490],[8420,8420]]],[1563797751234,["GJX@GJXAIOU",[[-1,8420,"\n"]],[8420,8420],[8419,8419]]],[1563797754545,["GJX@GJXAIOU",[[-1,8825,"12"]],[8825,8827],[8825,8825]]],[1563797755463,["GJX@GJXAIOU",[[-1,8825,"\n"]],[8825,8825],[8824,8824]]],[1563797757103,["GJX@GJXAIOU",[[-1,8808,"\n"]],[8808,8808],[8807,8807]]],[1563797763368,["GJX@GJXAIOU",[[-1,11189,"123456789101112"]],[11189,11204],[11189,11189]]],[1563797763984,["GJX@GJXAIOU",[[-1,11189,"\n"]],[11189,11189],[11188,11188]]],[1563797764472,["GJX@GJXAIOU",[[-1,11188,"\n"]],[11188,11188],[11187,11187]]],[1563797771217,["GJX@GJXAIOU",[[-1,15650,"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105\n"]],[15649,15857],[15649,15649]]],[1563797771760,["GJX@GJXAIOU",[[-1,15649,"\n"]],[15649,15649],[15648,15648]]],[1563797773823,["GJX@GJXAIOU",[[-1,15940,"12345678"]],[15940,15948],[15940,15940]]],[1563797774207,["GJX@GJXAIOU",[[-1,15940,"\n"]],[15940,15940],[15939,15939]]],[1563797776288,["GJX@GJXAIOU",[[-1,16219,"1234567\n"]],[16218,16226],[16218,16218]]],[1563797776641,["GJX@GJXAIOU",[[-1,16218,"\n"]],[16218,16218],[16217,16217]]],[1563797781233,["GJX@GJXAIOU",[[-1,17514,"1234567891011121314151617181920212223242526272829303132333435363738"]],[17514,17581],[17514,17514]]],[1563797781594,["GJX@GJXAIOU",[[-1,17514,"\n"]],[17514,17514],[17513,17513]]],[1563797782031,["GJX@GJXAIOU",[[-1,17513,"\n"]],[17513,17513],[17512,17512]]],[1563797788848,["GJX@GJXAIOU",[[-1,18314,">"]],[18315,18315],[18314,18314]]],[1563797791368,["GJX@GJXAIOU",[[-1,18518,">"]],[18519,18519],[18518,18518]]],[1563797793056,["GJX@GJXAIOU",[[-1,18524,">"]],[18525,18525],[18524,18524]]]],null,"GJX@GJXAIOU"],["81f8d4c5-be80-43f3-9ea8-1caaeb9d0c74",1570753932452,"---\nstyle: summer\nflag: red\ntags: \n- 代理\n- 未看完\n---\n\n# Java 中的代理模式及动态代理\n\n[原文地址链接](https://blog.csdn.net/briblue/article/details/73928350)\n\n# 代理\n\n代理是英文 Proxy 翻译过来的。我们在生活中见到过的代理，大概最常见的就是朋友圈中卖面膜的同学了。\n\n她们从厂家拿货，然后在朋友圈中宣传，然后卖给熟人。\n\n![这里写图片描述](https://img-blog.csdn.net/20170629213911162?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n按理说，顾客可以直接从厂家购买产品，但是现实生活中，很少有这样的销售模式。一般都是厂家委托给代理商进行销售，顾客跟代理商打交道，而不直接与产品实际生产者进行关联。\n\n所以，代理就有一种中间人的味道。\n\n接下来，我们说说软件中的代理模式。\n\n# 代理模式\n\n代理模式是面向对象编程中比较常见的设计模式。\n![这里写图片描述](https://img-blog.csdn.net/20170629213938736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这是常见代理模式常见的 UML 示意图。\n\n需要注意的有下面几点：\n\n1.  用户只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。\n2.  接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。\n3.  代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。\n4.  用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。\n\n如果难于理解的话，我用事例说明好了。值得注意的是，代理可以分为静态代理和动态代理两种。先从静态代理讲起。\n\n# 静态代理\n\n我们平常去电影院看电影的时候，在电影开始的阶段是不是经常会放广告呢？\n\n电影是电影公司委托给影院进行播放的，但是影院可以在播放电影的时候，产生一些自己的经济收益，比如卖爆米花、可乐等，然后在影片开始结束时播放一些广告。\n\n现在用代码来进行模拟。\n\n首先得有一个接口，通用的接口是代理模式实现的基础。这个接口我们命名为 Movie，代表电影播放的能力。\n\n```java\npackage com.frank.test;\n\npublic interface Movie {\n\tvoid play();\n}\n\n```\n\n然后，我们要有一个真正的实现这个 Movie 接口的类，和一个只是实现接口的代理类。\n\n```java\npackage com.frank.test;\n\npublic class RealMovie implements Movie {\n\n\t@Override\n\tpublic void play() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"您正在观看电影 《肖申克的救赎》\");\n\t}\n\n}\n\n```\n\n这个表示真正的影片。它实现了 Movie 接口，play() 方法调用时，影片就开始播放。那么 Proxy 代理呢？\n\n```java\npackage com.frank.test;\n\npublic class Cinema implements Movie { //同样实现接口的功能\n\tRealMovie movie;\n\n\tpublic Cinema(RealMovie movie) {\n\t\tsuper();\n\t\tthis.movie = movie;\n\t}\n\n\t@Override\n\tpublic void play() {\n\t\tguanggao(true);\n\t\tmovie.play();\n\t\tguanggao(false);\n\t}\n\n\tpublic void guanggao(boolean isStart){\n\t\tif ( isStart ) {\n\t\t\tSystem.out.println(\"电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！\");\n\t\t} else {\n\t\t\tSystem.out.println(\"电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！\");\n\t\t}\n\t}\n\n}\n\n```\n\nCinema 就是 Proxy 代理对象，它有一个 play() 方法。不过调用 play() 方法时，它进行了一些相关利益的处理，那就是广告。现在，我们编写测试代码。\n\n```java\npackage com.frank.test;\n\npublic class ProxyTest {\n\tpublic static void main(String[] args) {\n\t\tRealMovie realmovie = new RealMovie();\n\t\tMovie movie = new Cinema(realmovie);\n\t\tmovie.play();\n\t}\n}\n```\n\n然后观察结果：\n```\n电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！\n您正在观看电影 《肖申克的救赎》\n电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！\n\n```\n\n现在可以看到，**代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。**\n\n上面介绍的是静态代理的内容，为什么叫做静态呢？因为它的类型是事先预定好的，比如上面代码中的 Cinema 这个类。下面要介绍的内容就是动态代理。\n\n# 动态代理\n\n既然是代理，那么它与静态代理的功能与目的是没有区别的，唯一有区别的就是动态与静态的差别。\n\n那么在动态代理的中这个动态体现在什么地方？\n\n上一节代码中 Cinema 类是代理，我们需要手动编写代码让 Cinema 实现 Movie 接口，而在动态代理中，我们可以让程序在运行的时候自动在内存中创建一个实现 Movie 接口的代理，而不需要去定义 Cinema 这个类。这就是它被称为动态的原因。\n\n也许概念比较抽象。现在实例说明一下情况。\n\n假设有一个大商场，商场有很多的柜台，有一个柜台卖茅台酒。我们进行代码的模拟。\n\n```java\npackage com.frank.test;\n\npublic interface SellWine {\n\n\t void mainJiu();\n\n}\n```\n\nSellWine 是一个接口，你可以理解它为卖酒的许可证。\n\n```java\npackage com.frank.test;\n\npublic class MaotaiJiu implements SellWine {\n\n\t@Override\n\tpublic void mainJiu() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"我卖得是茅台酒。\");\n\n\t}\n}\n```\n\n然后创建一个类 MaotaiJiu,对的，就是茅台酒的意思。\n\n我们还需要一个柜台来卖酒：\n\n```java\npackage com.frank.test;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class GuitaiA implements InvocationHandler {\n\n\tprivate Object pingpai;\n\n\tpublic GuitaiA(Object pingpai) {\n\t\tthis.pingpai = pingpai;\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"销售开始  柜台是： \"+this.getClass().getSimpleName());\n\t\tmethod.invoke(pingpai, args);\n\t\tSystem.out.println(\"销售结束\");\n\t\treturn null;\n\t}\n\n}\n```\n\nGuitaiA 实现了 InvocationHandler 这个类，这个类是什么意思呢？大家不要慌张，待会我会解释。\n\n然后，我们就可以卖酒了。\n\n```java\npackage com.frank.test;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tMaotaiJiu maotaijiu = new MaotaiJiu();\n\n\t\tInvocationHandler jingxiao1 = new GuitaiA(maotaijiu);\n\n\t\tSellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao1);\n\n\t\tdynamicProxy.mainJiu();\n\n\t}\n\n}\n```\n\n这里，我们又接触到了一个新的概念，没有关系，先别管，先看结果。\n\n```\n销售开始  柜台是： GuitaiA\n我卖得是茅台酒。\n销售结束\n```\n\n看到没有，我并没有像静态代理那样为 SellWine 接口实现一个代理类，但最终它仍然实现了相同的功能，这其中的差别，就是之前讨论的动态代理所谓“动态”的原因。\n\n## 动态代理语法\n\n放轻松，下面我们开始讲解语法，语法非常简单。\n\n动态代码涉及了一个非常重要的类 Proxy。正是通过 Proxy 的静态方法 newProxyInstance 才会动态创建代理。\n\n### Proxy\n\n```java\npublic static Object newProxyInstance(ClassLoader loader,                                        Class<?>[] interfaces,                                       InvocationHandler h)\n\n```\n\n下面讲解它的 3 个参数意义。\n\n*   loader 自然是类加载器\n*   interfaces 代码要用来代理的接口\n*   h 一个 InvocationHandler 对象\n\n初学者应该对于 InvocationHandler 很陌生，我马上就讲到这一块。\n\n### InvocationHandler\n\nInvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。\n\n```java\npublic interface InvocationHandler {\n\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n\n\n```\n\nInvocationHandler 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。\n\n*   proxy 代理对象\n*   method 代理对象调用的方法\n*   args 调用的方法中的参数\n\n因为，Proxy 动态产生的代理会调用 InvocationHandler 实现类，所以 InvocationHandler 是实际执行者。\n\n```java\npublic class GuitaiA implements InvocationHandler {\n\n\tprivate Object pingpai;\n\n\tpublic GuitaiA(Object pingpai) {\n\t\tthis.pingpai = pingpai;\n\t}\n\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"销售开始  柜台是： \"+this.getClass().getSimpleName());\n\t\tmethod.invoke(pingpai, args);\n\t\tSystem.out.println(\"销售结束\");\n\t\treturn null;\n\t}\n\n}\n```\n\nGuitaiA 就是实际上卖酒的地方。\n\n现在，我们加大难度，我们不仅要卖**茅台酒**，还想卖**五粮液**。\n\n```java\npackage com.frank.test;\n\npublic class Wuliangye implements SellWine {\n\n\t@Override\n\tpublic void mainJiu() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"我卖得是五粮液。\");\n\n\t}\n\n}\n\n```\n\nWuliangye 这个类也实现了 SellWine 这个接口，说明它也拥有卖酒的许可证，同样把它放到 GuitaiA 上售卖。\n\n```java\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tMaotaiJiu maotaijiu = new MaotaiJiu();\n\n\t\tWuliangye wu = new Wuliangye();\n\n\t\tInvocationHandler jingxiao1 = new GuitaiA(maotaijiu);\n\t\tInvocationHandler jingxiao2 = new GuitaiA(wu);\n\n\t\tSellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao1);\n\t\tSellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao2);\n\n\t\tdynamicProxy.mainJiu();\n\n\t\tdynamicProxy1.mainJiu();\n\n\t}\n\n}\n```\n\n我们来看结果：\n\n```\n销售开始  柜台是： GuitaiA\n我卖得是茅台酒。\n销售结束\n销售开始  柜台是： GuitaiA\n我卖得是五粮液。\n销售结束\n```\n\n有人会问，dynamicProxy 和 dynamicProxy1 什么区别没有？他们都是动态产生的代理，都是售货员，都拥有卖酒的技术证书。\n\n我现在扩大商场的经营，除了卖酒之外，还要卖烟。\n\n首先，同样要创建一个接口，作为卖烟的许可证。\n\n```java\npackage com.frank.test;\n\npublic interface SellCigarette {\n\tvoid sell();\n}\n```\n\n然后，卖什么烟呢？我是湖南人，那就芙蓉王好了。\n\n```java\npublic class Furongwang implements SellCigarette {\n\n\t@Override\n\tpublic void sell() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"售卖的是正宗的芙蓉王，可以扫描条形码查证。\");\n\t}\n\n}\n```\n\n然后再次测试验证：\n\n```java\npackage com.frank.test;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tMaotaiJiu maotaijiu = new MaotaiJiu();\n\n\t\tWuliangye wu = new Wuliangye();\n\n\t\tFurongwang fu = new Furongwang();\n\n\t\tInvocationHandler jingxiao1 = new GuitaiA(maotaijiu);\n\t\tInvocationHandler jingxiao2 = new GuitaiA(wu);\n\n\t\tInvocationHandler jingxiao3 = new GuitaiA(fu);\n\n\t\tSellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao1);\n\t\tSellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao2);\n\n\t\tdynamicProxy.mainJiu();\n\n\t\tdynamicProxy1.mainJiu();\n\n\t\tSellCigarette dynamicProxy3 = (SellCigarette) Proxy.newProxyInstance(Furongwang.class.getClassLoader(),\n\t\t\t\tFurongwang.class.getInterfaces(), jingxiao3);\n\n\t\tdynamicProxy3.sell();\n\n\t}\n\n}\n```\n\n然后，查看结果：\n\n```\n销售开始  柜台是： GuitaiA\n我卖得是茅台酒。\n销售结束\n销售开始  柜台是： GuitaiA\n我卖得是五粮液。\n销售结束\n销售开始  柜台是： GuitaiA\n售卖的是正宗的芙蓉王，可以扫描条形码查证。\n销售结束\n\n```\n\n结果符合预期。大家仔细观察一下代码，同样是通过 Proxy.newProxyInstance() 方法，却产生了 SellWine 和 SellCigarette 两种接口的实现类代理，这就是动态代理的魔力。\n\n## 动态代理的秘密\n\n一定有同学对于为什么 Proxy 能够动态产生不同接口类型的代理感兴趣，我的猜测是肯定通过传入进去的接口然后通过反射动态生成了一个接口实例。\n比如 SellWine 是一个接口，那么 Proxy.newProxyInstance() 内部肯定会有\n\n```java\nnew SellWine();\n```\n\n这样相同作用的代码，不过它是通过反射机制创建的。那么事实是不是这样子呢？直接查看它们的源码好了。需要说明的是，我当前查看的源码是 1.8 版本。\n\n```java\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n\n        final Class<?>[] intfs = interfaces.clone();\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n\n            return cons.newInstance(new Object[]{h});\n\n        } catch (IllegalAccessException|InstantiationException e) {\n            throw new InternalError(e.toString(), e);\n        } catch (InvocationTargetException e) {\n            Throwable t = e.getCause();\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            } else {\n                throw new InternalError(t.toString(), t);\n            }\n        } catch (NoSuchMethodException e) {\n            throw new InternalError(e.toString(), e);\n        }\n    }\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849\n```\n\nnewProxyInstance 的确创建了一个实例，它是通过 cl 这个 Class 文件的构造方法反射生成。cl 由 getProxyClass0() 方法获取。\n\n```java\nprivate static Class<?> getProxyClass0(ClassLoader loader,\n                                       Class<?>... interfaces) {\n    if (interfaces.length > 65535) {\n        throw new IllegalArgumentException(\"interface limit exceeded\");\n    }\n\n    // If the proxy class defined by the given loader implementing\n    // the given interfaces exists, this will simply return the cached copy;\n    // otherwise, it will create the proxy class via the ProxyClassFactory\n    return proxyClassCache.get(loader, interfaces);\n}\n```\n\n直接通过缓存获取，如果获取不到，注释说会通过 ProxyClassFactory 生成。\n\n```java\n/**\n     * A factory function that generates, defines and returns the proxy class given\n     * the ClassLoader and array of interfaces.\n     */\n    private static final class ProxyClassFactory\n        implements BiFunction<ClassLoader, Class<?>[], Class<?>>\n    {\n        // Proxy class 的前缀是 “$Proxy”，\n        private static final String proxyClassNamePrefix = \"$Proxy\";\n\n        // next number to use for generation of unique proxy class names\n        private static final AtomicLong nextUniqueNumber = new AtomicLong();\n\n        @Override\n        public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\n            Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n            for (Class<?> intf : interfaces) {\n                /*\n                 * Verify that the class loader resolves the name of this\n                 * interface to the same Class object.\n                 */\n                Class<?> interfaceClass = null;\n                try {\n                    interfaceClass = Class.forName(intf.getName(), false, loader);\n                } catch (ClassNotFoundException e) {\n                }\n                if (interfaceClass != intf) {\n                    throw new IllegalArgumentException(\n                        intf + \" is not visible from class loader\");\n                }\n                /*\n                 * Verify that the Class object actually represents an\n                 * interface.\n                 */\n                if (!interfaceClass.isInterface()) {\n                    throw new IllegalArgumentException(\n                        interfaceClass.getName() + \" is not an interface\");\n                }\n                /*\n                 * Verify that this interface is not a duplicate.\n                 */\n                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {\n                    throw new IllegalArgumentException(\n                        \"repeated interface: \" + interfaceClass.getName());\n                }\n            }\n\n            String proxyPkg = null;     // package to define proxy class in\n            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n\n            /*\n             * Record the package of a non-public proxy interface so that the\n             * proxy class will be defined in the same package.  Verify that\n             * all non-public proxy interfaces are in the same package.\n             */\n            for (Class<?> intf : interfaces) {\n                int flags = intf.getModifiers();\n                if (!Modifier.isPublic(flags)) {\n                    accessFlags = Modifier.FINAL;\n                    String name = intf.getName();\n                    int n = name.lastIndexOf('.');\n                    String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1));\n                    if (proxyPkg == null) {\n                        proxyPkg = pkg;\n                    } else if (!pkg.equals(proxyPkg)) {\n                        throw new IllegalArgumentException(\n                            \"non-public interfaces from different packages\");\n                    }\n                }\n            }\n\n            if (proxyPkg == null) {\n                // if no non-public proxy interfaces, use com.sun.proxy package\n                proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\";\n            }\n\n            /*\n             * Choose a name for the proxy class to generate.\n             */\n            long num = nextUniqueNumber.getAndIncrement();\n            String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n            /*\n             * Generate the specified proxy class.\n             */\n            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n                proxyName, interfaces, accessFlags);\n            try {\n                return defineClass0(loader, proxyName,\n                                    proxyClassFile, 0, proxyClassFile.length);\n            } catch (ClassFormatError e) {\n                /*\n                 * A ClassFormatError here means that (barring bugs in the\n                 * proxy class generation code) there was some other\n                 * invalid aspect of the arguments supplied to the proxy\n                 * class creation (such as virtual machine limitations\n                 * exceeded).\n                 */\n                throw new IllegalArgumentException(e.toString());\n            }\n        }\n    }\n```\n\n这个类的注释说，通过指定的 ClassLoader 和 接口数组 用工厂方法生成 proxy class。 然后这个 proxy class 的名字是：\n\n```java\n\n// Proxy class 的前缀是 “$Proxy”，\nprivate static final String proxyClassNamePrefix = \"$Proxy\";\n\nlong num = nextUniqueNumber.getAndIncrement();\n\nString proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n```\n\n所以，动态生成的代理类名称是**包名+$Proxy+id序号**。\n\n生成的过程，核心代码如下：\n\n```java\nbyte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n                proxyName, interfaces, accessFlags);\n\nreturn defineClass0(loader, proxyName,\n                    proxyClassFile, 0, proxyClassFile.length);\n```\n\n这两个方法，我没有继续追踪下去，defineClass0() 甚至是一个 native 方法。我们只要知道，动态创建代理这回事就好了。\n\n现在我们还需要做一些验证，我要检测一下动态生成的代理类的名字是不是**包名+$Proxy+id序号**。\n\n```java\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tMaotaiJiu maotaijiu = new MaotaiJiu();\n\n\t\tWuliangye wu = new Wuliangye();\n\n\t\tFurongwang fu = new Furongwang();\n\n\t\tInvocationHandler jingxiao1 = new GuitaiA(maotaijiu);\n\t\tInvocationHandler jingxiao2 = new GuitaiA(wu);\n\n\t\tInvocationHandler jingxiao3 = new GuitaiA(fu);\n\n\t\tSellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao1);\n\t\tSellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),\n\t\t\t\tMaotaiJiu.class.getInterfaces(), jingxiao2);\n\n\t\tdynamicProxy.mainJiu();\n\n\t\tdynamicProxy1.mainJiu();\n\n\t\tSellCigarette dynamicProxy3 = (SellCigarette) Proxy.newProxyInstance(Furongwang.class.getClassLoader(),\n\t\t\t\tFurongwang.class.getInterfaces(), jingxiao3);\n\n\t\tdynamicProxy3.sell();\n\n\t\tSystem.out.println(\"dynamicProxy class name:\"+dynamicProxy.getClass().getName());\n\t\tSystem.out.println(\"dynamicProxy1 class name:\"+dynamicProxy1.getClass().getName());\n\t\tSystem.out.println(\"dynamicProxy3 class name:\"+dynamicProxy3.getClass().getName());\n\n\t}\n\n}\n```\n\n结果如下：\n\n```\n销售开始  柜台是： GuitaiA\n我卖得是茅台酒。\n销售结束\n销售开始  柜台是： GuitaiA\n我卖得是五粮液。\n销售结束\n销售开始  柜台是： GuitaiA\n售卖的是正宗的芙蓉王，可以扫描条形码查证。\n销售结束\n\ndynamicProxy class name:com.sun.proxy.$Proxy0\ndynamicProxy1 class name:com.sun.proxy.$Proxy0\ndynamicProxy3 class name:com.sun.proxy.$Proxy1\n\n```\n\nSellWine 接口的代理类名是：`com.sun.proxy.$Proxy0`\nSellCigarette 接口的代理类名是：`com.sun.proxy.$Proxy1`\n\n这说明动态生成的 proxy class 与 Proxy 这个类同一个包。\n\n下面用一张图让大家记住动态代理涉及到的角色。\n![这里写图片描述](https://img-blog.csdn.net/20170629220323673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n红框中 `$Proxy0`就是通过 Proxy 动态生成的。\n`$Proxy0`实现了要代理的接口。\n`$Proxy0`通过调用 `InvocationHandler`来执行任务。\n\n# 代理的作用\n\n可能有同学会问，已经学习了代理的知识，但是，它们有什么用呢？\n\n主要作用，还是在不修改被代理对象的源码上，进行功能的增强。\n\n这在 AOP 面向切面编程领域经常见。\n\n 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n 主要功能\n 日志记录，性能统计，安全控制，事务处理，异常处理等等。\n\n上面的引用是百度百科对于 AOP 的解释，至于，如何通过代理来进行日志记录功能、性能统计等等，这个大家可以参考 AOP 的相关源码，然后仔细琢磨。\n\n同注解一样，很多同学可能会有疑惑，我什么时候用代理呢？\n\n这取决于你自己想干什么。你已经学会了语法了，其他的看业务需求。对于实现日志记录功能的框架来说，正合适。\n\n至此，静态代理和动态代理者讲完了。\n\n# 总结\n\n1.  代理分为静态代理和动态代理两种。\n2.  静态代理，代理类需要自己编写代码写成。\n3.  动态代理，代理类通过 Proxy.newInstance() 方法生成。\n4.  不管是静态代理还是动态代理，代理与被代理者都要实现两样接口，它们的实质是面向接口编程。\n5.  静态代理和动态代理的区别是在于要不要开发者自己定义 Proxy 类。\n6.  动态代理通过 Proxy 动态生成 proxy class，但是它也指定了一个 InvocationHandler 的实现类。\n7.  代理模式本质上的目的是为了增强现有代码的功能。",[[1570753886483,["GJX@GJXAIOU",[[1,1334,"**"],[1,1369,"**"]],[1334,1369],[1334,1373]]],[1570753907109,["GJX@GJXAIOU",[[-1,1485,"\t\t// TODO Auto-generated method stub"]],[1485,1521],[1485,1485]]],[1570753907614,["GJX@GJXAIOU",[[-1,1485,"\n"]],[1485,1485],[1484,1484]]],[1570753908781,["GJX@GJXAIOU",[[-1,1451,"\n"]],[1451,1451],[1450,1450]]],[1570753912678,["GJX@GJXAIOU",[[-1,1529,"\n"]],[1529,1529],[1528,1528]]],[1570753914871,["GJX@GJXAIOU",[[-1,1531,"\n"]],[1531,1531],[1530,1530]]],[1570754156511,["GJX@GJXAIOU",[[1,2735,"**"],[1,2812,"**"]],[2735,2812],[2735,2816]]]],null,"GJX@GJXAIOU"]]}