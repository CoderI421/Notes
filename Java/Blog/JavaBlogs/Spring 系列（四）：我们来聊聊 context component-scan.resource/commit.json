{"compress":true,"commitItems":[["4219a125-cccf-48be-bbad-2083f7002cc4",1573954295251,"# Spring 系列（四）：我们来聊聊<context:component-scan/>\n\n## 1.背景\n\n[上篇](https://juejin.im/post/5cbeadb96fb9a031ff0d18b5)最后给大家了一个建议，建议配置bean扫描包时使用如下写法：\n\nspring-mvc.xml\n\n```\n<!-- 只扫描@Controller注解 -->\n<context:component-scan base-package=\"com.xxx.controller\" use-default-filters=\"false\"\n >\n    <context:include-filter type=\"annotation\"\n        expression=\"org.springframework.stereotype.Controller\" />\n</context:component-scan>\n复制代码\n```\n\nspring.xml\n\n```\n<!-- 配置扫描注解,不扫描@Controller注解 -->\n<context:component-scan base-package=\"com.xxx\">\n    <context:exclude-filter type=\"annotation\"\n        expression=\"org.springframework.stereotype.Controller\" />\n</context:component-scan>\n复制代码\n```\n\n文中提到通过以上配置，就可以在Spring MVC容器中只注册有@Controller注解的bean,Spring容器注册除了@Controller的其它bean。\n\n有的同学留言问为什么这样写就达到这种效果了呢？\n\n也有人可能认为我是无脑从网上抄来的，我有什么依据，凭什么这么说？经过ISO 9000认证了吗？\n\n为了维护文章的权威性以及我的脸面，本篇我就继续带大家从官网和源码两方面进行分析。\n\n## 2\\. < context:component-scan/>流程分析\n\n### 2.1 Java注解\n\n不是说好的讲< context:component-scan>吗，怎么注解乱入了。\n\n放心，虽然看源码累，写让大家看懂的文章更累，但是我还没疯。\n\n为什么讲注解，因为Spring中很多地方用到注解，本文及前几篇文章大家或多或少也都有看到。\n\n因此在这里加个小灶，和大家一起回顾一下注解的知识点。\n\n先查看[官方文档](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html)：\n\n```\nAnnotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.\nAnnotations have a number of uses, among them:\n*  Information for the compiler — Annotations can be used by the compiler to detect errors or suppress warnings.\n*  Compile-time and deployment-time processing — Software tools can process annotation information to generate code, XML files, and so forth.\n*  Runtime processing — Some annotations are available to be examined at runtime.\n复制代码\n```\n\n上面一段话翻译过来：\n\n```\n注解是原数据的一种形式，对标注的代码逻辑上没有直接的影响，只是用来提供程序的一些信息。\n主要用处如下：\n*  为编译器提供信息，比如错误检测或者警告提示。\n*  在编译和部署期处理期，程序可以根据注解信息生成代码、xml文件。\n*  在程序运行期用来做一些检查。\n复制代码\n```\n\n### 2.2 Java元注解\n\nJAVA为了开发者能够灵活定义自己的注解，因此在java.lang.annotation包中提供了4种元注解，用来注解其它注解。\n\n查看[官方文档](https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html)对这4种元注解的介绍：\n\n*   1.  @Retention\n\n```\n@Retention annotation specifies how the marked annotation is stored:\n*   RetentionPolicy.SOURCE – The marked annotation is retained only in the source level and is ignored by the compiler.\n*   RetentionPolicy.CLASS – The marked annotation is retained by the compiler at compile time, but is ignored by the Java Virtual Machine (JVM).\n*   RetentionPolicy.RUNTIME – The marked annotation is retained by the JVM so it can be used by the runtime environment.\n复制代码\n```\n\n翻译：指定标记的注解存储范围。可选范围是原文件、class文件、运行期。\n\n*   1.  @Documented\n\n```\n@Documented annotation indicates that whenever the specified annotation is used those elements should be documented using the Javadoc tool. (By default, annotations are not included in Javadoc.) For more information, see the Javadoc tools page.\n复制代码\n```\n\n翻译：因为注解默认是不会被JavaDoc工具处理的，因此@Documented用来要求注解能被JavaDoc工具处理并生成到API文档中 。\n\n*   1.  @Target\n\n```\n@Target annotation marks another annotation to restrict what kind of Java elements the annotation can be applied to. A target annotation specifies one of the following element types as its value:\n*   ElementType.ANNOTATION_TYPE can be applied to an annotation type.\n*   ElementType.CONSTRUCTOR can be applied to a constructor.\n*   ElementType.FIELD can be applied to a field or property.\n*   ElementType.LOCAL_VARIABLE can be applied to a local variable.\n*   ElementType.METHOD can be applied to a method-level annotation.\n*   ElementType.PACKAGE can be applied to a package declaration.\n*   ElementType.PARAMETER can be applied to the parameters of a method.\n*   ElementType.TYPE can be applied to any element of a class.\n\n复制代码\n```\n\n翻译：用来标识注解的应用范围。可选的范围是注解、构造函数、类属性、局部变量、包、参数、类的任意元素。\n\n*   1.  @Inherited\n\n```\n @Inherited annotation indicates that the annotation type can be inherited from the super class. (This is not true by default.) When the user queries the annotation type and the class has no annotation for this type, the class' superclass is queried for the annotation type. This annotation applies only to class declarations.\n复制代码\n```\n\n翻译：默认情况下注解不会被子类继承，被@Inherited标示的注解可以被子类继承。\n\n上面就是对4种元注解的介绍，其实大部分同学都知道，这里只是一起做个回顾，接下来进入正体。\n\n### 2.3 @Controller介绍\n\n查看[官方文档](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html)\n\n```\nIndicates that an annotated class is a \"Controller\" (e.g. a web controller).\nThis annotation serves as a specialization of @Component, allowing for implementation classes to be autodetected through classpath scanning. It is typically used in combination with annotated handler methods based on the RequestMapping annotation.\n复制代码\n```\n\n翻译一下： @Controller注解用来标明一个类是Controller，使用该注解的类可以在扫描过程中被检测到。通常@Controller和@RequestMapping注解一起使用来创建handler函数。\n\n我们在来看看源码，在org.springframework.stereotype包下找到Controller类。\n\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface Controller {\n   String value() default \"\";\n}\n复制代码\n```\n\n可以看到Controller声明为注解类型，类上的@Target({ElementType.TYPE}) 注解表明@Controller可以用到任意元素上，@Retention(RetentionPolicy.RUNTIME)表明注解可以保存到运行期，@Documented表明注解可以被生成到API文档里。\n\n除定义的几个元注解外我们还看到有个@Component注解，这个注解是干什么的呢？\n\n查看[官方文档](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html)\n\n```\nIndicates that an annotated class is a \"component\". Such classes are considered as candidates for auto-detection when using annotation-based configuration and classpath scanning.\n复制代码\n```\n\n翻译一下：被@Component注解标注的类代表该类为一个component，被标注的类可以在包扫描过程中被检测到。\n\n再看源码：\n\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Component {\n   String value() default \"\";\n}\n复制代码\n```\n\n可以看到@Component注解可以用在任意类型上，保留在运行期，能生成到API文档中。\n\n再回到@Controller注解，正是因为@Controller被@Component标注，因此被@Controller标注的类也能在类扫描的过程中被发现并注册。\n\n另外Spring中还用@Service和@Repositor注解定义bean，@Service用来声明service类，@Repository用来声明DAO累。\n\n其源码如下：\n\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface Service {\n   String value() default \"\";\n}\n复制代码\n```\n\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface Repository {\n   String value() default \"\";\n}\n复制代码\n```\n\n### 2.4 源码剖析\n\n铺垫都结束了，现在开始重头戏。\n\n和< annotation-driven/>元素一样， < component-scan/>也属于自定义命名空间，对应的解析器是ComponentScanBeanDefinitionParser。\n\n自定义命名空间的解析过程可以参考[上篇](https://juejin.im/post/5cbeadb96fb9a031ff0d18b5)，此处不再介绍。\n\n我们进入ComponentScanBeanDefinitionParser类的parse()方法。\n\n```\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    //此处 BASE_PACKAGE_ATTRIBUTE = \"base-package\";\n    //1.获取要扫描的包\n    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);\n    //此处CONFIG_LOCATION_DELIMITERS = \",; \\t\\n\"，\n    //把,或者;分割符分割的包放到数组里面\n   String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,\n         ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);\n    //2.创建扫描器\n   ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);\n    //3.扫描包并注册bean\n   Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);\n   return null;\n}\n复制代码\n```\n\n上面扫描注册过程可以分为3步。\n\n（1）获取要扫描的包。\n\n（2）创建扫描器。\n\n（3）扫描包并注册bean。\n\n第1步逻辑比较简单，就是单纯的读取配置文件的\"base-package\"属性得到要扫描的包列表。\n\n我们从第2步开始分析。\n\n#### 2.4.1 创建扫描器\n\n进入configureScanner方法()。\n\n```\nprotected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {\n    //useDefaultFilters默认为true，即扫描所有类型bean\n    boolean useDefaultFilters = true;\n    //1.此处USE_DEFAULT_FILTERS_ATTRIBUTE = \"use-default-filters\"，获取其XML中设置的值\n    if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) {\n        useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));\n    }\n   //2.创建扫描器\n    ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters);\n    //3.解析过滤类型\n    parseTypeFilters(element, scanner, parserContext);\n    //4.返回扫描器\n    return scanner;\n}\n复制代码\n```\n\n创建扫描器的方法分为4步。\n\n（1）获取扫描类范围。\n\n（2）根据扫描范围初始化扫描器。\n\n（3）设置扫描类的过滤器。\n\n（4）返回创建的扫描器。\n\n第1步也比较简单，从配置文件中获得“use-default-filters”属性的值，默认是true，即扫描所有类型的注解。\n\n我们进入第2步的createScanner（）方法，看看如何创建扫描器。\n\n```\nprotected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) {\n    //新建一个扫描器\n    return new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters,\n        readerContext.getEnvironment(),readerContext.getResourceLoader());\n}\n复制代码\n```\n\n沿调用栈进入ClassPathBeanDefinitionScanner()方法。\n\n```\npublic ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,\n//如果useDefaultFilters为true，注册默认过滤器\n    if (useDefaultFilters) {\n        //注册默认过滤器\n        registerDefaultFilters();\n   }\n}\n复制代码\n```\n\n进入registerDefaultFilters()方法。\n\n```\nprotected void registerDefaultFilters() {\n    this.includeFilters.add(new AnnotationTypeFilter(Component.class));\n}\n复制代码\n```\n\n可以看到上面方法把Component注解类型加入到了扫描白名单中，因此被@Component标注的类都会被扫描注册。\n\n在此，大家也明白为什么@Controller、@service、@Repository标注的类会被注册了吧，因为这些注解都用@Component标注了。\n\n我们再进入第3步的parseTypeFilters()方法，看如何设置过滤器。\n\n```\nprotected void parseTypeFilters(Element element, ClassPathBeanDefinitionScanner scanner, ParserContext parserContext) {\n    //解析exclude-filter和include-filter元素\n    //获取元素所有子节点\n    NodeList nodeList = element.getChildNodes();\n    //遍历元素子节点\n    for (int i = 0; i < nodeList.getLength(); i++) {\n        Node node = nodeList.item(i);\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n        String localName = parserContext.getDelegate().getLocalName(node);\n        //解析include-filter元素 ,此处 INCLUDE_FILTER_ELEMENT = \"include-filter\"\n        if (INCLUDE_FILTER_ELEMENT.equals(localName)) {\n            //创建类型过滤器\n            TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n            //把解析出来的类型加入白名单\n            scanner.addIncludeFilter(typeFilter);\n        }\n        //解析exclude-filter元素，此处EXCLUDE_FILTER_ELEMENT = \"exclude-filter\"\n        else if (EXCLUDE_FILTER_ELEMENT.equals(localName)) {\n            //创建类型过滤器\n            TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);\n            //把解析出来的类型加入黑名单\n            scanner.addExcludeFilter(typeFilter);\n        }\n    }\n}\n复制代码\n```\n\n进入createTypeFilter()方法查看实现逻辑。\n\n```\nprotected TypeFilter createTypeFilter(Element element, ClassLoader classLoader, ParserContext parserContext) {\n    //获取xml中type属性值，此处FILTER_TYPE_ATTRIBUTE = \"type\"   \n    String filterType = element.getAttribute(FILTER_TYPE_ATTRIBUTE);\n    //获取xml中expression属性值，此处FILTER_EXPRESSION_ATTRIBUTE = \"expression\"，获取xml中该属性值\n    String expression = element.getAttribute(FILTER_EXPRESSION_ATTRIBUTE);\n    expression = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(expression);\n    //如果是注解类型，创建注解类型过滤器，并把需要过滤的注解类设置进去\n    if (\"annotation\".equals(filterType)) {\n        return new AnnotationTypeFilter((Class<Annotation>) ClassUtils.forName(expression, classLoader));\n    }\n}\n复制代码\n```\n\n上面就是创建扫描器的过程，主要是将XML文件中设置的类型添加到白名单和黑名单中。\n\n#### 2.4.2 扫描注册bean\n\n得到扫描器后，开始扫描注册流程。\n\n进入doScan()方法。\n\n```\nprotected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<BeanDefinitionHolder>();\n    //遍历所有需要扫描的包\n    for (String basePackage : basePackages) {\n        //1.在该包中找出用@Component注解的类，放到候选列表中\n        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);\n        for (BeanDefinition candidate : candidates) {\n        //2.判断容器中是否已经有bean信息，如果没有就注册\n        if (checkCandidate(beanName, candidate)) {\n            //生成bean信息\n            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\n            //添加bean信息到bean定义列表中\n            beanDefinitions.add(definitionHolder);\n            //3.把bean注册到IOC容器中\n            registerBeanDefinition(definitionHolder, this.registry);\n        }\n    }\n}\n复制代码\n```\n\n扫描注册过程分为3步。\n\n（1）从包中找出需要注册的bean并放到候选列表中。\n\n（2）遍历候选列表中的所有bean，判断容器中是否已经存在bean。\n\n（3）如果不存在bean，就把bean信息注册到容器中。\n\n接下来依次分析上面扫描注册流程。\n\n##### 2.4.2.1 查找候选bean\n\n我们先看第1步，查找候选bean的过程。进入findCandidateComponents()方法。\n\n```\npublic Set<BeanDefinition> findCandidateComponents(String basePackage) {\n    Set<BeanDefinition> candidates = new LinkedHashSet<BeanDefinition>();\n    //1.获取包的classpath\n    String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +\n        resolveBasePackage(basePackage) + '/' + this.resourcePattern;\n    //2.把包下的所有class解析成resource资源   \n    Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);\n    //遍历所有类resource\n    for (Resource resource : resources) {\n        if (resource.isReadable()) {\n            //3.获取类的元信息\n            MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);\n            //4.判断是否候选component\n            if (isCandidateComponent(metadataReader)) {\n                //5.根据类元信息生成beanDefinition\n                ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);\n                sbd.setResource(resource);\n                sbd.setSource(resource);\n                //6.判断该bean是否能实例化\n                if (isCandidateComponent(sbd)) {\n                    //7.加入候选类列表\n                    candidates.add(sbd);\n                 }\n    //8.返回候选components选列表\n    return candidates;\n}\n复制代码\n```\n\n查找bean的流程比较繁琐，可以分为以下8步。\n\n（1）获取包扫描路径。\n\n（2）把包路径下的所有类解析成resource类。\n\n（3）解析resource类，获取类的元信息。\n\n（4）根据类元信息判断该类是否在白名单中。\n\n（5）如果在白名单中，生成beanDefinition信息。\n\n（6）根据beanDefinition信息判断类是否能实例化。\n\n（7）如果可以实例化，将beanDefinition信息加入到候选列表中。\n\n（8）返回保存beanDefinition信息的候选列表。\n\n还记得BeanDefinition是什么吧，主要是保存bean的信息。如果不记得看看[Spring注册流程](https://juejin.im/post/5cb89dae6fb9a0686b47306d)。\n\n因为其它逻辑比较简单，在此我们重点分析第4步和第6步。\n\n先看第4步，进入isCandidateComponent()方法。\n\n```\nprotected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {\n    //1.遍历黑名单，若传入的类元信息在黑名单中返回false\n    for (TypeFilter tf : this.excludeFilters) {\n        //判断是否和传入的类匹配\n        if (tf.match(metadataReader, this.metadataReaderFactory)) {\n            return false;\n        }\n    }\n    //2.遍历白名单，若传入的类元信息在白名单中返回true\n    for (TypeFilter tf : this.includeFilters) {\n        if (tf.match(metadataReader, this.metadataReaderFactory)) {\n            //根据@Conditional注解判断是否注册bean，如果没有@Conditional注解，返回true.\n            return isConditionMatch(metadataReader);\n        }\n    }\n    return false;\n}\n复制代码\n```\n\n可以看到上面主要逻辑是判断该类是否在白名单或黑名单列表中，如果在白名单，则返回true，在黑名单返回false。黑、白名单的值就是创建扫描流程中通过parseTypeFilters()方法设置进去的。\n\n再稍微提一下上面@Conditional注解，此注解是Spring 4中加入的，作用是根据设置的条件来判断要不要注册bean，如果没有标注该注解，默认注册。我们在这里不展开细说，有兴趣的同学可以自己查阅相关资料。\n\n我们再看第6步，进入isCandidateComponent()方法。\n\n```\nprotected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n    //获取元类信息\n    AnnotationMetadata metadata = beanDefinition.getMetadata();\n    //判断是否可以实例化\n    return (metadata.isIndependent() && (metadata.isConcrete() ||\n        (metadata.isAbstract() && metadata.hasAnnotatedMethods(Lookup.class.getName()))));\n}\n复制代码\n```\n\n可以看到上面是根据该类是不是接口、抽象类、嵌套类等信息来判断能否实例化的。\n\n##### 2.4.2.2 判断bean是否已经注册\n\n候选bean列表信息已经得到，再看看如何对列表中的bean做进一步判断。\n\n进入checkCandiates()方法。\n\n```\nprotected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) {\n    if (!this.registry.containsBeanDefinition(beanName)) {\n        return true;\n   }\n    return false;\n}\n复制代码\n```\n\n上面方法比较简单，主要是查看容器中是否已经有bean的定义信息。\n\n##### 2.4.2.3 注册bean\n\n对bean信息判断完成后，如果bean有效，就开始注册bean。\n\n进入registerBeanDefinition()方法。\n\n```\nprotected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {\n    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);\n}\n复制代码\n```\n\n再进入registerBeanDefinition()方法。\n\n```\npublic static void registerBeanDefinition(\n    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {\n    //得到beanname\n    String beanName = definitionHolder.getBeanName();\n    //注册bean信息\n    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n    //注册bean的别名\n    String[] aliases = definitionHolder.getAliases();\n    if (aliases != null) {\n    for (String alias : aliases) {\n        registry.registerAlias(beanName, alias);\n    }\n\n}\n复制代码\n```\n\n上面流程大家有没有似曾相识，和[Spring解析注册流程](https://juejin.im/post/5cb89dae6fb9a0686b47306d)文中注册bean的逻辑一样。\n\n到此就完成了扫描注册bean流程的分析。接下来就是bean的实例化等流程，大家可以参考[Spring解析注册流程](https://juejin.im/post/5cb89dae6fb9a0686b47306d)一文。\n\n## 3.小结\n\n看完上面的分析，相信大家对< context:component-scan/>有了深入的了解。\n\n现在回到开头的那段代码。会不会有“诚不我欺也”的感觉。\n\n最后，我再把那段代码贴出来，大家对着代码在脑海里想象一下其解析流程，检验一下掌握程度。\n\n如果有哪一步卡住了，建议再回头看看我的文章，直至能在脑海中有一个完整的流程图，甚至能想到对应的源代码段。\n\n如果能做到这样，说明你真正理解了< context:component-scan/>，接下来就可以愉快的和小伙伴炫技或者和面试官去侃大山了。\n\nspring-mvc.xml\n\n```\n<!-- 只扫描@Controller注解 -->\n<context:component-scan base-package=\"com.xxx.controller\" use-default-filters=\"false\"\n >\n    <context:include-filter type=\"annotation\"\n        expression=\"org.springframework.stereotype.Controller\" />\n</context:component-scan>\n复制代码\n```\n\nspring.xml\n\n```\n<!-- 配置扫描注解,不扫描@Controller注解 -->\n<context:component-scan base-package=\"com.xxx\">\n    <context:exclude-filter type=\"annotation\"\n        expression=\"org.springframework.stereotype.Controller\" />\n</context:component-scan>\n复制代码\n```\n\n本文完。",[[1573954247424,["GJX@GJXAIOUPC",[[1,0,"\n"]],[0,0],[1,1]]],[1573954253159,["GJX@GJXAIOUPC",[[1,0,"---\nflag: blue\n---"]],[0,0],[18,18]]]],null,"GJX@GJXAIOUPC"]]}