{"compress":true,"commitItems":[["b973d2a1-c1bf-4f15-8275-bf49c64e4867",1564662340634,"",[[1564662291710,["GJX@GJXAIOU",[[1,0,"# Java中各种简写含义\n\n\n\n"]],[0,0],[16,16]]],[1564662294222,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1564662317214,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1564662317343,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1564662317464,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1564662317487,["GJX@GJXAIOU",[[1,4,"\n---\n\n"]],[3,3],[4,4]]],[1564662325543,["GJX@GJXAIOU",[[1,4,"tags: []"]],[4,4],[12,12]]],[1564662341847,["GJX@GJXAIOU",[[1,11,"# [DO、DTO、BO、AO、VO、POJO](https://www.cnblogs.com/EasonJim/p/7967999.html)"]],[11,11],[84,84]]],[1564662345342,["GJX@GJXAIOU",[[-1,11,"# ["]],[14,14],[11,11]]],[1564662351190,["GJX@GJXAIOU",[[-1,32,"(https://www.cnblogs.com/EasonJim/p/7967999.html)"]],[32,81],[32,32]]],[1564662353959,["GJX@GJXAIOU",[[-1,13,"、"]],[14,14],[13,13]]],[1564662355945,["GJX@GJXAIOU",[[1,13,", "]],[13,13],[15,15]]],[1564662358681,["GJX@GJXAIOU",[[-1,18,"、"]],[19,19],[18,18]]],[1564662361463,["GJX@GJXAIOU",[[1,18,", "]],[18,18],[20,20]]],[1564662364654,["GJX@GJXAIOU",[[-1,21,"O、"]],[23,23],[21,21]]],[1564662368090,["GJX@GJXAIOU",[[1,21,"O,."]],[21,21],[24,24]]],[1564662369384,["GJX@GJXAIOU",[[-1,23,"."]],[24,24],[23,23]]],[1564662369606,["GJX@GJXAIOU",[[1,23," "]],[23,23],[24,24]]],[1564662371384,["GJX@GJXAIOU",[[-1,26,"、"]],[27,27],[26,26]]],[1564662372912,["GJX@GJXAIOU",[[1,26,", "]],[26,26],[28,28]]],[1564662374791,["GJX@GJXAIOU",[[-1,30,"、"]],[31,31],[30,30]]],[1564662375448,["GJX@GJXAIOU",[[1,30,", "]],[30,30],[32,32]]],[1564662380390,["GJX@GJXAIOU",[[-1,37,"]"]],[37,37],[36,36]]],[1564662396854,["GJX@GJXAIOU",[[1,36,",Query,DAO"]],[36,36],[46,46]]],[1564662413847,["GJX@GJXAIOU",[[1,46," POJO"]],[46,46],[51,51]]],[1564662427799,["GJX@GJXAIOU",[[1,74,"层领域模型规约：\n\n*   DO（ Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。\n*   DTO（ Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。\n*   BO（ Business Object）：业务对象。 由Service层输出的封装业务逻辑的对象。\n*   AO（ Application Object）：应用对象。 在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。\n*   VO（ View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。\n*   POJO（ Plain Ordinary Java Object）：在本手册中， POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。\n*   Query：数据查询对象，各层接收上层的查询请求。 注意超过2个参数的查询封装，禁止使用Map类来传输。\n\n领域模型命名规约：\n\n*   数据对象：xxxDO，xxx即为数据表名。\n*   数据传输对象：xxxDTO，xxx为业务领域相关的名称。\n*   展示对象：xxxVO，xxx一般为网页名称。\n*   POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。"]],[74,74],[663,663]]],[1564662504477,["GJX@GJXAIOU",[[1,527,"* \n"]],[526,526],[529,529]]],[1564662504992,["GJX@GJXAIOU",[[1,529,"## PO(persistant object) 持久对象\n\n在 o/r 映射的时候出现的概念，如果没有 o/r 映射，没有这个概念存在了。通常对应数据模型 ( 数据库 ), 本身还有部分业务逻辑的处理。可以看成是与数据库中的表相映射的 java 对象。最简单的 PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。\n\n## DO（Domain Object）领域对象\n\n就是从现实世界中抽象出来的有形或无形的业务实体。一般和数据中的表结构对应。\n\n## TO(Transfer Object) ，数据传输对象\n\n在应用程序不同 tie( 关系 ) 之间传输的对象\n\n## DTO（Data Transfer Object）数据传输对象\n\n这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。\n\n## VO(view object) 值对象\n\n视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。\n\n## BO(business object) 业务对象\n\n从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 java 对象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。 business object: 业务对象 主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。\n\n## POJO(plain ordinary java object) 简单无规则 java 对象\n\n纯的传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增加别的属性和方法。我的理解就是最基本的 Java Bean ，只有属性字段及 setter 和 getter 方法！。\n\n## DAO(data access object) 数据访问对象\n\n是一个 sun 的一个标准 j2ee 设计模式， 这个模式中有个接口就是 DAO ，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作\n\n作者：木戎\n链接：https://www.jianshu.com/p/b36ac13a3511\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"]],[529,529],[1871,1871]]],[1564662533895,["GJX@GJXAIOU",[[-1,1783,"作者：木戎\n链接：https://www.jianshu.com/p/b36ac13a3511\n来源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"]],[1783,1871],[1783,1783]]],[1564662534701,["GJX@GJXAIOU",[[-1,1784,"\n"]],[1783,1783],[1782,1782]]],[1564662537894,["GJX@GJXAIOU",[[1,1920,"* \n"]],[1919,1919],[1922,1922]]],[1564662538030,["GJX@GJXAIOU",[[-1,1920,"* "]],[1922,1922],[1921,1921]]],[1564662538149,["GJX@GJXAIOU",[[1,1921,"\n"]],[1921,1921],[1922,1922]]],[1564662538272,["GJX@GJXAIOU",[[1,1922,"\n"]],[1922,1922],[1923,1923]]],[1564663996464,["GJX@GJXAIOU",[[-1,527,"* "]],[529,529],[527,527]]],[1564663997565,["GJX@GJXAIOU",[[1,527,"\n"]],[527,527],[528,528]]],[1564664012908,["GJX@GJXAIOU",[[-1,744,"就是从现实世界中抽象出来的有形或无形的业务实体"]],[744,767],[744,744]]],[1564664015695,["GJX@GJXAIOU",[[1,133,"就是从现实世界中抽象出来的有形或无形的业务实体"]],[133,133],[156,156]]],[1564664020317,["GJX@GJXAIOU",[[-1,741,"## DO（Domain Object）领域对象\n\n。一般和数据中的表结构对应。"]],[741,781],[741,741]]],[1564664061943,["GJX@GJXAIOU",[[1,218,"泛指用于展示层与服务层之间的数据传输对象。\n"]],[218,218],[240,240]]],[1564664064253,["GJX@GJXAIOU",[[-1,240,"\n"]],[240,240],[239,239]]],[1564664073318,["GJX@GJXAIOU",[[-1,823,"## DTO（Data Transfer Object）数据传输对象\n\n这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。"]],[823,963],[823,823]]],[1564664075062,["GJX@GJXAIOU",[[-1,824,"\n"]],[823,823],[822,822]]],[1564664092223,["GJX@GJXAIOU",[[1,416,"它的作用是把某个指定页面（或组件）的所有数据封装起来。"]],[416,416],[443,443]]],[1564664095168,["GJX@GJXAIOU",[[-1,851,"## VO(view object) 值对象\n\n视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。\n"]],[851,914],[851,851]]],[1564664095792,["GJX@GJXAIOU",[[-1,851,"\n"]],[851,851],[850,850]]],[1564664110415,["GJX@GJXAIOU",[[-1,1154,"## POJO(plain ordinary java object) 简单无规则 java 对象\n\n纯的传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增加别的属性和方法。我的理解就是最基本的 Java Bean ，只有属性字段及 setter 和 getter 方法！。"]],[1154,1380],[1154,1154]]],[1564664130057,["GJX@GJXAIOU",[[1,293,"从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 java 对象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。 business object: 业务对象 主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。"]],[293,293],[565,565]]],[1564664137333,["GJX@GJXAIOU",[[-1,871,"##"]],[871,873],[871,871]]],[1564664137926,["GJX@GJXAIOU",[[1,871,"-"]],[871,871],[872,872]]],[1564664138190,["GJX@GJXAIOU",[[1,873," "]],[872,872],[873,873]]],[1564664140077,["GJX@GJXAIOU",[[-1,901,"\n"]],[901,901],[900,900]]],[1564664148056,["GJX@GJXAIOU",[[-1,1062,"##"],[1,1064,"-"]],[1062,1064],[1063,1063]]],[1564664155677,["GJX@GJXAIOU",[[-1,1121,"## BO(business object) 业务对象\n\n从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 java 对象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。 business object: 业务对象 主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。\n"]],[1121,1423],[1121,1121]]],[1564664156341,["GJX@GJXAIOU",[[-1,1123,"\n"]],[1121,1121],[1120,1120]]],[1564664165968,["GJX@GJXAIOU",[[-1,1123,"## "],[1,1126,"-"]],[1123,1126],[1124,1124]]],[1564664166486,["GJX@GJXAIOU",[[1,1124," "]],[1124,1124],[1125,1125]]],[1564664168981,["GJX@GJXAIOU",[[-1,1092,"\n"]],[1092,1092],[1091,1091]]],[1564664170533,["GJX@GJXAIOU",[[-1,1121,"\n"]],[1121,1121],[1120,1120]]],[1564664170759,["GJX@GJXAIOU",[[-1,1120,"\n"]],[1120,1120],[1119,1119]]],[1564664172045,["GJX@GJXAIOU",[[-1,1061,"\n"]],[1061,1061],[1060,1060]]],[1564664172261,["GJX@GJXAIOU",[[-1,1060,"\n"]],[1060,1060],[1059,1059]]],[1564664173479,["GJX@GJXAIOU",[[-1,1117,"\n"]],[1117,1117],[1116,1116]]],[1564664174415,["GJX@GJXAIOU",[[-1,1150,"\n"]],[1150,1150],[1149,1149]]]],null,"GJX@GJXAIOU"]]}