{"compress":true,"commitItems":[["71a833eb-2545-49e1-afc8-24561fe6baa3",1573954233622,"# Spring 系列（三）：你真的懂@RequestMapping吗？\n\n## 1.前言\n\n[上篇](https://juejin.im/post/5cbc10b46fb9a0689f4c2c22)给大家介绍了Spring MVC父子容器的概念，主要提到的知识点是:\n\n```\nSpring MVC容器是Spring容器的子容器，当在Spring MVC容器中找不到bean的时候就去父容器找.\n复制代码\n```\n\n在文章最后我也给大家也留了一个问题，既然子容器找不到就去父容器找，那干脆把bean定义都放在父容器不就行了？是这样吗，我们做个实验。\n\n我们把<context:component-scan base-package=\"xx.xx.xx\"/> 这条语句从spring-mvc.xml文件中挪到spring.xml中，重启应用。会发现报404，如下图：\n\n![](https://user-gold-cdn.xitu.io/2019/4/24/16a4cf72528d985c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n404说明请求的资源没有找到，为什么呢？\n\n使用Spring MVC的同学一般都会以下方式定义请求地址:\n\n```\n@Controller\n@RequestMapping(\"/test\")\npublic class Test {\n   @RequestMapping(value=\"/handle\", method=RequestMethod.POST)\n   public void handle();\n}\n复制代码\n```\n\n@Controller注解用来把一个类定义为Controller。\n\n@RequestMapping注解用来把web请求映射到相应的处理函数。\n\n@Controller和@RequestMapping结合起来完成了Spring MVC请求的派发流程。\n\n为什么两个简单的注解就能完成这么复杂的功能呢？又和<context:component-scan base-package=\"xx.xx.xx\"/>的位置有什么关系呢？\n\n让我们开始分析源码。\n\n## 2.@RequestMapping流程分析\n\n@RequestMapping流程可以分为下面6步：\n\n*   1.注册RequestMappingHandlerMapping bean 。\n*   2.实例化RequestMappingHandlerMapping bean。\n*   3.获取RequestMappingHandlerMapping bean实例。\n*   4.接收requst请求。\n*   5.在RequestMappingHandlerMapping实例中查找对应的handler。\n*   6.handler处理请求。\n\n为什么是这6步，我们展开分析。\n\n### 2.1 注册RequestMappingHandlerMapping bean\n\n第一步还是先找程序入口。\n\n使用Spring MVC的同学都知道，要想使@RequestMapping注解生效，必须得在xml配置文件中配置< mvc:annotation-driven/>。因此我们以此为突破口开始分析。\n\n在[Spring系列（一）：bean 解析、注册、实例化](https://juejin.im/post/5cb89dae6fb9a0686b47306d) 文中我们知道xml配置文件解析完的下一步就是解析bean。在这里我们继续对那个方法展开分析。如下：\n\n```\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n   //如果该元素属于默认命名空间走此逻辑。Spring的默认namespace为：http://www.springframework.org/schema/beans“\n   if (delegate.isDefaultNamespace(root)) {\n      NodeList nl = root.getChildNodes();\n      for (int i = 0; i < nl.getLength(); i++) {\n         Node node = nl.item(i);\n         if (node instanceof Element) {\n            Element ele = (Element) node;\n            //对document中的每个元素都判断其所属命名空间，然后走相应的解析逻辑\n            if (delegate.isDefaultNamespace(ele)) {\n               parseDefaultElement(ele, delegate);\n            }\n            else {\n              //如果该元素属于自定义namespace走此逻辑 ，比如AOP，MVC等。\n               delegate.parseCustomElement(ele);\n            }\n         }\n      }\n   }\n   else {\n      //如果该元素属于自定义namespace走此逻辑 ，比如AOP，MVC等。\n      delegate.parseCustomElement(root);\n   }\n}\n复制代码\n```\n\n方法中根据元素的命名空间来进行不同的逻辑处理，如bean、beans等属于默认命名空间执行parseDefaultElement()方法，其它命名空间执行parseCustomElement()方法。\n\n< mvc:annotation-driven/>元素属于mvc命名空间，因此进入到 parseCustomElement()方法。\n\n```\npublic BeanDefinition parseCustomElement(Element ele) {\n    //解析自定义元素\n    return parseCustomElement(ele, null);\n}\n复制代码\n```\n\n进入parseCustomElement(ele, null)方法。\n\n```\npublic BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {\n    //获取该元素namespace url\n    String namespaceUri = getNamespaceURI(ele);\n    //得到NamespaceHandlerSupport实现类解析元素\n    NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n    return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n}\n复制代码\n```\n\n进入NamespaceHandlerSupport类的parse()方法。\n\n```\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    //此处得到AnnotationDrivenBeanDefinitionParser类来解析该元素\n    return findParserForElement(element, parserContext).parse(element, parserContext);\n}\n复制代码\n```\n\n上面方法分为两步，（1）获取元素的解析类。（2）解析元素。\n\n（1）获取解析类。\n\n```\nprivate BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {\n    String localName = parserContext.getDelegate().getLocalName(element);\n    BeanDefinitionParser parser = this.parsers.get(localName);\n    return parser;\n}\n复制代码\n```\n\nSpring MVC中含有多种命名空间，此方法会根据元素所属命名空间得到相应解析类，其中< mvc:annotation-driven/>对应的是AnnotationDrivenBeanDefinitionParser解析类。\n\n（2）解析< mvc:annotation-driven/>元素\n\n进入AnnotationDrivenBeanDefinitionParser类的parse（）方法。\n\n```\n@Override\npublic BeanDefinition parse(Element element, ParserContext context) {\n    Object source = context.extractSource(element);\n    XmlReaderContext readerContext = context.getReaderContext();\n    //生成RequestMappingHandlerMapping bean信息\n    RootBeanDefinition handlerMappingDef = new RootBeanDefinition(RequestMappingHandlerMapping.class);\n    handlerMappingDef.setSource(source);\n    handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    handlerMappingDef.getPropertyValues().add(\"order\", 0);\n    handlerMappingDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n    //此处HANDLER_MAPPING_BEAN_NAME值为:RequestMappingHandlerMapping类名\n    //容器中注册name为RequestMappingHandlerMapping类名\n    context.registerComponent(new BeanComponentDefinition(handlerMappingDef, HANDLER_MAPPING_BEAN_NAME));\n}\n复制代码\n```\n\n可以看到上面方法在Spring MVC容器中注册了一个名为“HANDLER_MAPPING_BEAN_NAME”,类型为RequestMappingHandlerMapping的bean。\n\n至于这个bean能干吗，继续往下分析。\n\n### 2.2\\. RequestMappingHandlerMapping bean实例化\n\nbean注册完后的下一步就是实例化。\n\n在开始分析实例化流程之前，我们先介绍一下RequestMappingHandlerMapping是个什么样类。\n\n#### 2.2.1 RequestMappingHandlerMapping继承图\n\n![](https://user-gold-cdn.xitu.io/2019/4/24/16a4d2126e4259ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n上图信息比较多，我们查找关键信息。可以看到这个类间接实现了HandlerMapping接口，是HandlerMapping类型的实例。\n\n除此之外还实现了ApplicationContextAware和IntitalzingBean 这两个接口。\n\n在这里简要介绍一下这两个接口：\n\n#### 2.2.2 ApplicationContextAware接口\n\n下面是[官方介绍](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContextAware.html)：\n\n```\npublic interface ApplicationContextAware extends Aware\n\nInterface to be implemented by any object that wishes to be notified of the ApplicationContext that it runs in.\n复制代码\n```\n\n该接口只包含以下方法：\n\n```\nvoid setApplicationContext(ApplicationContext applicationContext)\nthrows BeansException\n\nSet the ApplicationContext that this object runs in. Normally this call will be used to initialize the object.\n复制代码\n```\n\n概括一下上面表达的信息：如果一个类实现了ApplicationContextAware接口，Spring容器在初始化该类时候会自动回调该类的setApplicationContext()方法。这个接口主要用来让实现类得到Spring 容器上下文信息。\n\n#### 2.2.3 IntitalzingBean接口\n\n下面是[官方介绍](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/InitializingBean.html)：\n\n```\npublic interface InitializingBean\n\nInterface to be implemented by beans that need to react once all their properties have been set by a BeanFactory: e.g. to perform custom initialization, or merely to check that all mandatory properties have been set.\n\n复制代码\n```\n\n该接口只包含以下方法：\n\n```\nvoid afterPropertiesSet() throws Exception\n\nInvoked by the containing BeanFactory after it has set all bean properties and satisfied BeanFactoryAware, ApplicationContextAware etc.\n复制代码\n```\n\n概括一下上面表达的信息：如果一个bean实现了该接口，Spring 容器初始化bean时会回调afterPropertiesSet()方法。这个接口的主要作用是让bean在初始化时可以实现一些自定义的操作。\n\n介绍完RequestMappingHandlerMapping类后我们开始对这个类的源码进行分析。\n\n#### 2.2.2.4 RequestMappingHandlerMapping类源码分析\n\n既然RequestMappingHandlerMapping实现了ApplicationContextAware接口，那实例化时候肯定会执行setApplicationContext方法，我们查看其实现逻辑。\n\n```\n@Override\npublic final void setApplicationContext(ApplicationContext context) throws BeansException {\n   if (this.applicationContext == null) {\n  \tthis.applicationContext = context;\n   }\n}\n复制代码\n```\n\n可以看到此方法把容器上下文赋值给applicationContext变量，因为现在是Spring MVC容器创建流程，因此此处设置的值就是Spring MVC容器 。\n\nRequestMappingHandlerMapping也实现了InitializingBean接口，当设置完属性后肯定会回调afterPropertiesSet方法，再看afterPropertiesSet方法逻辑。\n\n```\n@Override\npublic void afterPropertiesSet() \n   super.afterPropertiesSet();\n}\n复制代码\n```\n\n上面调用了父类的afterPropertiesSet()方法，沿调用栈继续查看。\n\n```\n@Override\npublic void afterPropertiesSet() {\n\t//初始化handler函数\n   initHandlerMethods();\n}\n复制代码\n```\n\n进入initHandlerMethods初始化方法查看逻辑。\n\n```\nprotected void initHandlerMethods() {\n    //1.获取容器中所有bean 的name。\n    //根据detectHandlerMethodsInAncestorContexts bool变量的值判断是否获取父容器中的bean，默认为false。因此这里只获取Spring MVC容器中的bean，不去查找父容器\n    String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?\n         BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :\n         getApplicationContext().getBeanNamesForType(Object.class));\n    //循环遍历bean\n    for (String beanName : beanNames) {\n\t//2.判断bean是否含有@Controller或者@RequestMappin注解\n        if (beanType != null && isHandler(beanType)) {\n            //3.对含有注解的bean进行处理，获取handler函数信息。\n              detectHandlerMethods(beanName);\n      }\n}\n复制代码\n```\n\n上面函数分为3步。\n\n（1）获取Spring MVC容器中的bean。\n\n（2）找出含有含有@Controller或者@RequestMappin注解的bean。\n\n（3）对含有注解的bean进行解析。\n\n第1步很简单就是获取容器中所有的bean name，我们对第2、3步作分析。\n\n查看isHandler()方法实现逻辑。\n\n```\n@Override\nprotected boolean isHandler(Class<?> beanType) {\n   return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||\n         AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));\n}\n复制代码\n```\n\n上面逻辑很简单，就是判断该bean是否有@Controller或@RequestMapping注解，然后返回判断结果。\n\n如果含有这两个注解之一就进入detectHandlerMethods（）方法进行处理。\n\n查看detectHandlerMethods（）方法。\n\n```\nprotected void detectHandlerMethods(final Object handler) {\n    //1.获取bean的类信息\n    Class<?> handlerType = (handler instanceof String ?\n         getApplicationContext().getType((String) handler) : handler.getClass());\n    final Class<?> userType = ClassUtils.getUserClass(handlerType);\n    //2.遍历函数获取有@RequestMapping注解的函数信息\n   Map<Method, T> methods = MethodIntrospector.selectMethods(userType,\n         new MethodIntrospector.MetadataLookup<T>() {\n            @Override\n            public T inspect(Method method) {\n               try {\n                //如果有@RequestMapping注解，则获取函数映射信息\n                return getMappingForMethod(method, userType);\n               }\n         });\n    //3.遍历映射函数列表，注册handler\n    for (Map.Entry<Method, T> entry : methods.entrySet()) {\n      Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);\n      T mapping = entry.getValue();\n      //注册handler函数\n      registerHandlerMethod(handler, invocableMethod, mapping);\n   }\n}\n复制代码\n```\n\n上面方法中用了几个回调，可能看起来比较复杂，其主要功能就是获取该bean和父接口中所有用@RequestMapping注解的函数信息，并把这些保存到methodMap变量中。\n\n我们对上面方法进行逐步分析，看看如何对有@RequestMapping注解的函数进行解析。\n\n先进入selectMethods()方法查看实现逻辑。\n\n```\npublic static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {\n   final Map<Method, T> methodMap = new LinkedHashMap<Method, T>();\n   Set<Class<?>> handlerTypes = new LinkedHashSet<Class<?>>();\n   Class<?> specificHandlerType = null;\n    //把自身类添加到handlerTypes中\n    if (!Proxy.isProxyClass(targetType)) {\n        handlerTypes.add(targetType);\n        specificHandlerType = targetType;\n    }\n    //获取该bean所有的接口，并添加到handlerTypes中\n    handlerTypes.addAll(Arrays.asList(targetType.getInterfaces()));\n    //对自己及所有实现接口类进行遍历\n   for (Class<?> currentHandlerType : handlerTypes) {\n      final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);\n      //获取函数映射信息\n      ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {\n\t    //循环获取类中的每个函数，通过回调处理\n            @Override\n            public void doWith(Method method) {\n            //对类中的每个函数进行处理\n            Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);\n            //回调inspect（）方法给个函数生成RequestMappingInfo  \n            T result = metadataLookup.inspect(specificMethod);\n            if (result != null) {\n                //将生成的RequestMappingInfo保存到methodMap中\n                methodMap.put(specificMethod, result);\n            }\n         }\n      }, ReflectionUtils.USER_DECLARED_METHODS);\n   }\n    //返回保存函数映射信息后的methodMap\n    return methodMap;\n}\n复制代码\n```\n\n上面逻辑中doWith()回调了inspect(),inspect()又回调了getMappingForMethod（）方法。\n\n我们看看getMappingForMethod()是如何生成函数信息的。\n\n```\nprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n    //创建函数信息\n    RequestMappingInfo info = createRequestMappingInfo(method);\n    return info;\n}\n复制代码\n```\n\n查看createRequestMappingInfo()方法。\n\n```\nprivate RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) {\n    //如果该函数含有@RequestMapping注解,则根据其注解信息生成RequestMapping实例，\n    //如果该函数没有@RequestMapping注解则返回空\n    RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);\n    //如果requestMapping不为空，则生成函数信息MAP后返回\n    return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);\n}\n复制代码\n```\n\n看看createRequestMappingInfo是如何实现的。\n\n```\nprotected RequestMappingInfo createRequestMappingInfo(\n      RequestMapping requestMapping, RequestCondition<?> customCondition) {\n         return RequestMappingInfo\n         .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n         .methods(requestMapping.method())\n         .params(requestMapping.params())\n         .headers(requestMapping.headers())\n         .consumes(requestMapping.consumes())\n         .produces(requestMapping.produces())\n         .mappingName(requestMapping.name())\n         .customCondition(customCondition)\n         .options(this.config)\n         .build();\n}\n复制代码\n```\n\n可以看到上面把RequestMapping注解中的信息都放到一个RequestMappingInfo实例中后返回。\n\n当生成含有@RequestMapping注解的函数映射信息后，最后一步是调用registerHandlerMethod 注册handler和处理函数映射关系。\n\n```\nprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n   this.mappingRegistry.register(mapping, handler, method);\n}\n复制代码\n```\n\n看到把所有的handler方法都注册到了mappingRegistry这个变量中。\n\n到此就把RequestMappingHandlerMapping bean的实例化流程就分析完了。\n\n### 2.3 获取RequestMapping bean\n\n这里我们回到Spring MVC容器初始化流程，查看initWebApplicationContext方法。\n\n```\nprotected WebApplicationContext initWebApplicationContext() {\n    //1.获得rootWebApplicationContext\n    WebApplicationContext rootContext =\n        WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac = null;\n    if (wac == null) {\n        //2.创建 Spring 容器 \n        wac = createWebApplicationContext(rootContext);\n    }\n    //3.初始化容器\n    onRefresh(wac)；\n    return wac;\n}\n复制代码\n```\n\n前两步我们在[Spring 系列（二）：Spring MVC的父子容器](https://juejin.im/post/5cbc10b46fb9a0689f4c2c22)一文中分析过，主要是创建Spring MVC容器，这里我们重点看第3步。\n\n进入onRefresh()方法。\n\n```\n@Override\nprotected void onRefresh(ApplicationContext context) {\n    //执行初始化策略 \n    initStrategies(context);\n}\n复制代码\n```\n\n进入initStrategies方法，该方法进行了很多初始化行为，为减少干扰我们只过滤出与本文相关内容。\n\n```\nprotected void initStrategies(ApplicationContext context) {\n   //初始化HandlerMapping\n   initHandlerMappings(context);\n}\n复制代码\n```\n\n进入initHandlerMappings()方法。\n\n```\nprivate void initHandlerMappings(ApplicationContext context) {\n    //容器中查找name为\"ANDLER_MAPPING_BEAN_NAME\"的实例\n    HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);\n    //把找到的bean放到hanlderMappings中。\n    this.handlerMappings = Collections.singletonList(hm);\n}\n复制代码\n```\n\n此处我们看到从容器中获取了name为 “HANDLER_MAPPING_BEAN_NAME”的bean，这个bean大家应该还记得吧，就是前面注册并实例化了的RequestMappingHandlerMapping bean。\n\n### 2.4 接收请求\n\nDispatchServlet继承自Servlet，那所有的请求都会在service()方法中进行处理。\n\n查看service()方法。\n\n```\n@Override\nprotected void service(HttpServletRequest request, HttpServletResponse response) {\n    //获取请求方法\n    HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n    //若是patch请求执行此逻辑\n    if (httpMethod == HttpMethod.PATCH || httpMethod == null) {\n        processRequest(request, response);\n   }\n    //其它请求走此逻辑\n   else {\n      super.service(request, response);\n   }\n}\n复制代码\n```\n\n我们以get、post请求举例分析。查看父类service方法实现。\n\n```\nprotected void service(HttpServletRequest req, HttpServletResponse resp){\n    String method = req.getMethod();\n    if (method.equals(METHOD_GET)) {\n        //处理get请求\n        doGet(req, resp);\n    } else if (method.equals(METHOD_POST)) {\n        //处理post请求\n        doPost(req, resp)\n    }\n} \n复制代码\n```\n\n查看doGet()、doPost()方法实现。\n\n```\n@Override\nprotected final void doGet(HttpServletRequest request, HttpServletResponse response){\n    processRequest(request, response);\n}\n@Override\nprotected final void doPost(HttpServletRequest request, HttpServletResponse response {\n    processRequest(request, response);\n}\n复制代码\n```\n\n可以看到都调用了processRequest（）方法，继续跟踪。\n\n```\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response){\n    //处理请求\n    doService(request, response);\n}\n复制代码\n```\n\n查看doService()方法。\n\n```\n@Override\nprotected void doService(HttpServletRequest request, HttpServletResponse response) {\n    //处理请求\n    doDispatch(request, response);\n}\n复制代码\n```\n\n### 2.5 获取handler\n\n最终所有的web请求都由doDispatch()方法进行处理，查看其逻辑。\n\n```\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) {\n    HttpServletRequest processedRequest = request;\n    // 根据请求获得真正处理的handler\n    mappedHandler = getHandler(processedRequest);\n    //用得到的handler处理请求，此处省略\n\t。。。。\n}\n复制代码\n```\n\n查看getHandler()。\n\n```\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    //获取HandlerMapping实例\n    for (HandlerMapping hm : this.handlerMappings) {\n        //得到处理请求的handler\n        HandlerExecutionChain handler = hm.getHandler(request);\n        if (handler != null) {\n            return handler;\n        }\n   }\n   return null;\n}\n复制代码\n```\n\n这里遍历handlerMappings获得所有HandlerMapping实例，还记得handlerMappings变量吧，这就是前面initHandlerMappings()方法中设置进去的值。\n\n可以看到接下来调了用HandlerMapping实例的getHanlder()方法查找handler，看其实现逻辑。\n\n```\n@Override\npublic final HandlerExecutionChain getHandler(HttpServletRequest request) {\n    Object handler = getHandlerInternal(request);\n}\n复制代码\n```\n\n进入getHandlerInternal()方法。\n\n```\n@Override\nprotected HandlerMethod getHandlerInternal(HttpServletRequest request) {\n    //获取函数url\n    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);\n    //查找HandlerMethod \n    handlerMethod = lookupHandlerMethod(lookupPath, request);\n}\n复制代码\n```\n\n进入lookupHandlerMethod()。\n\n```\nprotected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) {\n    this.mappingRegistry.getMappingsByUrl(lookupPath);\n}\n复制代码\n```\n\n可以看到上面方法中从mappingRegistry获取handler，这个mappingRegistry的值还记得是从哪里来的吗？\n\n就是前面RequestMappingHandlerMapping 实例化过程的最后一步调用registerHandlerMethod()函数时设置进去的。\n\n### 2.6 handler处理请求\n\n获取到相应的handler后剩下的事情就是进行业务逻辑。处理后返回结果，这里基本也没什么好说的。\n\n到此整个@RequestMapping的流程也分析完毕。\n\n## 3.小结\n\n认真读完上面深入分析@RequestMapping注解流程的同学，相信此时肯定对Spring MVC有了更深一步的认识。\n\n现在回到文章开头的那个问题，为什么把<context:component-scan base-package=\"xx.xx.xx\"/>挪到spring.xml文件中后就会404了呢？\n\n我想看明白此文章的同学肯定已经知道答案了。\n\n答案是：\n\n当把<context:component-scan base-package=\"xx.xx.xx\"/>写到spring.xml中时，所有的bean其实都实例化在了Spring父容器中。\n\n但是在@ReqestMapping解析过程中，initHandlerMethods()函数只是对Spring MVC 容器中的bean进行处理的，并没有去查找父容器的bean。因此不会对父容器中含有@RequestMapping注解的函数进行处理，更不会生成相应的handler。\n\n所以当请求过来时找不到处理的handler，导致404。\n\n## 4.尾声\n\n从上面的分析中，我们知道要使用@RequestMapping注解，必须得把含有@RequestMapping的bean定义到spring-mvc.xml中。\n\n这里也给大家个建议：\n\n因为@RequestMapping一般会和@Controller搭配使。为了防止重复注册bean，建议在spring-mvc.xml配置文件中只扫描含有Controller bean的包，其它的共用bean的注册定义到spring.xml文件中。写法如下：\n\nspring-mvc.xml\n\n```\n<!-- 只扫描@Controller注解 -->\n<context:component-scan base-package=\"com.xxx.controller\" use-default-filters=\"false\"\n >\n    <context:include-filter type=\"annotation\"\n        expression=\"org.springframework.stereotype.Controller\" />\n</context:component-scan>\n复制代码\n```\n\nspring.xml\n\n```\n<!-- 配置扫描注解,不扫描@Controller注解 -->\n<context:component-scan base-package=\"com.xxx\">\n    <context:exclude-filter type=\"annotation\"\n        expression=\"org.springframework.stereotype.Controller\" />\n</context:component-scan>\n复制代码\n```\n\nuse-default-filters属性默认为true，会扫描所有注解类型的bean 。如果配置成false，就只扫描白名单中定义的bean注解。",[[1573954176648,["GJX@GJXAIOUPC",[[1,0,"\n"]],[0,0],[1,1]]],[1573954179187,["GJX@GJXAIOUPC",[[1,0,"---\nflag: blue\n---"]],[0,0],[18,18]]]],null,"GJX@GJXAIOUPC"]]}