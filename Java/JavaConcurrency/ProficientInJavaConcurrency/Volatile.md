## Volatile

[TOC]

使用方式：private volatile int count；

#### volatile 关键字的作用以及缺点

- 实现 long/double 类型变量的原子操作

    因为 JVM 中的 long 和 double 都是占 64 位，针对现在的 32 位和 64 位机器，其可能分成低 32 位和高 32 位进行分别填充赋值。导致其非原子性。

    ![image-20210320151618677](Volatile.resource/image-20210320151618677.png)

    如图所示：volatile double a = 1.0 // 因为一个double的赋值其实是分为两步来完成的。也可以使用 atomicLong 或者 atomicDouble 来实现。

    

- 防止指令重排序

- 实现变量的可见性

因为程序在读取一个变量值的时候不会直接从内存中进行读取，而是从 CPU 中的寄存器中读取。当使用 volatile 修饰一个变量的时候，编译器就不会将该变量防止到寄存器中进行存储。对变量的访问和修改都需要访问内存。

当使用 volatile 修饰变量时，应用就不会从寄存器中获取该变量的值，而是从内存（高速缓存）中获取。

####  volatile与锁的异同

Volatile 和锁的类似两点：确保变量的内存可见性和防止指令重排序，但是它并不是锁。

不具备：

- 可以保证其修饰变量写操作的原子性，但是不具备锁的排他性（互斥性）。【原子性可以理解为就是一条 CPU 指令，不能在分割了。而排他性是指像 synchronized 那样同一时刻只能有一个线程操作，而 volatile 修饰的变量可能同时有多个线程对其进行写操作】
- 使用锁可能会导致线程的上下文切换(内核态与用户态之间的切换)，但使用volatile并不会出现这种情况 （一直在用户态）。

#### volatile的缺点：

为了实现原子性操作那么每次取数据的时候不会在寄存器上取而是在主内存或者高速缓存上取这将带来性能的损失

 

volatile int a = b + 2;    // 错误示例，无法保证对 a 的原子性。这里的赋值包含两个步骤：首先实现 b + 2，然后将其结果赋值给了 a。因为第一个线程获取 b 进行了 + 2，第二个线程也获取了 b，则 b 的值都不一样。【b + 2，其实是两步，先读取 b 然后进行 + 2】因为这里是两条指令进行一个操作。

volatile int a = a++;     // 同样需要两条指令来完成相应的操作

volatile int count = 1;    // 正确示例

volatile boolean flag = false; // 正确示例

volatile Date date = new Date( );这个如果是多线程的话也可能出现问题，因为 new Date() 首先需要在堆上创建一个 Date 对象的存储并生成一些数据，然后返回一个引用给左侧的 date。加上 volatile 仅仅能保证将引用值赋值给 date 是一个原子操作。因为通常以上操作都是在一个方法中，只能被一个线程执行，所以没有问题。

如果要实现volatile写操作的原子性，那么在等号右侧的赋值变量中就不能出现被多线程所共享的变量，哪怕这个变量也是个volatile也不可以。

#### 2.3 实现原理

防止指令重排序和实现变量的可见性都是通过一种手段进行实现的：内存屏障（Memory Barrier）

JIT 编译器将源代码生成字节码的过程中可能会进行指令的重排序以提升执行性能。在当线程问题下没有任何问题。Volatile 可以防止指令重排序，代码示例如下：



##### volatile 修饰写入操作

```java
int a = 1;

String s = " hello" ;

内存屏障(Release Barrier，释放屏障) // 这个是jvm底层自己加的就像monitorenter和monitorexist
volatile boolean v = false; // 这是一个写操作，看到 volatile 会在前后自动加上屏障
写入操作内存屏障(store Barrier，存储屏障)
```

Release Barrier实现两点作用：防止下面的volatile与上面的所有操作的指令重排序。和让内存屏障前的所有读/写操作都能立刻发布到其它所有的线程中，使得其它线程可以看到修改结果。（为了防止重排序就把上面的代码给执行掉），保证在 volatile 的修改之前，前面所有的读/写操作都已经被提交了，当前线程在执行 volatile 写操作时候，其它线程都可以看到 volatile 前面的所有的修改，这样就保证了其他的读线程对于当前写线程在写入 volatile 变量之前对共享变量的所有更新变量的看到顺序与源代码顺序一致，即防止指令重排序。

Store Barrier∶重要作用是刷新处理器缓存，结果是可以确保该存储屏障之前一切（包括 volatile 修饰和非 volatile 修饰）的操作所生成的结果对于其他处理器来说都立刻可见。

##### volatile 修饰读操作

```java
 内存屏障(Load Barrier，加载屏障)
 boolean v1 = v;
内存屏障(Acquire Barrier，获取屏障)

int a = 1;

String s = "hello" ;
```

Load Barrier:可以刷新处理器缓存，同步其他处理器对该volatile变量的修改结果。

Acquire Barrier:可以防止上面的volatile读取操作与下面的所有操作语句的指令重排序。

 

对于volatile关键字变量的读写操作，本质上都是通过内存屏障来执行的。

内存屏障兼具了两方面能力:1．防止指令重排序，2．实现变量内存的可见性。

1．对于读取操作来说，volatile可以确保该操作与其后续的所有读写操作都不会进行指令重排序。

2．对于修改操作来说，volatile可以确保该操作与其上面的所有读写操作都不会进行指令重排序。

 

volatile 只能修饰原生类型，不能修饰非原生类型，如 ArrayList(对于非原生类型，如果是赋值将具备原子性的操作，但是创建这个对象什么的不具备原子性)

 

#### volatile与锁的一些比较

锁同样具备变量内存可见性与防止指令重排序的功能。

以 synchroned 修饰代码块为例，其防止指令重排序也是使用内存屏障实现，在两个指令的前后的内存屏障如下所示：

monitorenter

内存屏障(Acquire Barrier, 获取屏障)

。。。。。

内存屏障(Release Barrier,释放屏障)

monitorexit

 

#### happen- -before

在多核的场景下，某个处理器对某个变量的修改操作**最终**是可以被其它处理器所知晓的，但是没确定什么时候能获取到。不保证实时一致性，只能保证最终一致性。

#### 3.1 Java内存模型(Java Memory Model, JMM) 以及happen- -before

JMM 主要规定以下问题，但是最终实现需要各个 JVM 来自定义实现。下面的变量主要是成员变量或者静态变量，因为局部变量不存在这些问题。

1.变量的原子性问题。

2.变量的可见性问题

3.变量修改的时序性问题。

#### 3.2 happen-before重要规则:（定义在 JMM 规范中）

happen-before 原则一方面具有传递性，同时除了第一个在单个线程内部，其它均是在多个线程之间。

- 顺序执行规则(限定在单个线程上的) :该线程的每个动作都happen-before它的后面的动作。（指令重排序和happen-before是不矛盾的，只要不违反 happen-before原则是允许指令重排序的，比如一个线程执行 a/b/c 三条语句，则 a  happen-before b happen before c，但是并不表示 a 一定会在 b 之前执行，因为如果  a  和 b 之间操作的语句没有任何关系的话，JIT 编译器是允许他们进行指令重排序的。但是如果有有先后关系则不会进行指令重排序）

- 隐式锁(monitor) 规则：针对同一把锁 unlock happen- before lock, 之前的线程对于同步代码块的所有执行结果对于后续获取同一把锁的线程来说都是可见的。

- volatile读写规则：对于一个volatile变量的写操作一定会happen-before后续对该变量的读操作。

- 多线程的启动规则：Thread对象的start方法happen-before该线程run方法中的任何一个动作，包括在其中启动的任何子线程。 （可以在一个线程中启动另一个线程使其作为当前线程的子线程使用，即可以在父线程的 run 方法中启动另一个线程，则子线程在执行其 run 方法前可以看到父线程在执行 start 方法前的所有操作结果）保证父线程所作的一切对子线程都是可见的。

- 多线程的终正规则：一个线程启动了一个子线程，并且调用了子线程的join方法则该线程会等待其子线程结束，那么当子线程结束后，父线程的接下来的所有操作都可以看到子线程run方法中的执行结果。

- 线程的中断规则：可以调用 interrupt 方法来中断线程，这个调用 happen-before 对该线程中断的检查(isInterrupted) 。

