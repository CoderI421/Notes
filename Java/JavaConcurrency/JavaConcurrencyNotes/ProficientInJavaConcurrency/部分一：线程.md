

[TOC]

重复理解理论的情况下进行实践。不断巩固内化。

## 一、从 Thread 类与 Runnable 接口开始

### （一）两者关系

![计算机生成了可选文字: 0Functionallnterface 0Runnable 0Thread](部分一：线程.resource/clip_image001.png)

首先 Thread 类是实现了 Runnable 接口 `public class Thread implements Runnable {`

### （二）Thread 类分析

**下面为完整的 Thread 类的 JavaDoc 文档**

> 一个 Thread 是程序的一个执行线程，Java 虚拟机允许应用程序同时运行多个执行线程。
>
> 每个线程都有一个优先级，优先级较高的线程优先于优先级较低的线程执行。每个线程也可以标记为守护进程，也可以不标记为守护进程。当在某个线程中运行的代码创建一个新的 Thread 对象时，新线程的优先级最初设置为等于创建线程的优先级（即如果在一个线程中创建另一个线程，则被创建线程初始优先级和创建它的线程优先级相同），并且仅当创建线程是守护进程时被创建的线程才是守护进程线程。
>
> 当Java虚拟机启动时，通常只有一个非守护进程线程（它通常调用某些指定类的名为 main 的方法，所以 main 方法是执行在线程上的）。Java虚拟机会继续执行线程，直到发生以下任一情况：
>
> - Runtime 类的 exit 方法被调用，并且类安全管理器允许退出操作发送；
>
> - 不是守护进程线程的所有线程都已死亡，消亡原因可能是调用 run 方法返回了，或者抛出了超过 run 方法范围的异常。
>
> 有两种方法可以创建一个新的执行线程，一种是将类声明为 Thread 类的子类。这个子类应该覆盖重写Thread 类的 run 方法。然后可以分配并启动子类的实例。例如，计算大于指定值的素数的线程可以如下编写：
>
> ```java
> class PrimeThread extends Thread {
>    long minPrime;
>    PrimeThread(long minPrime) {
>        this.minPrime = minPrime;
>    }
>    public void run() {
>        // compute primes larger than minPrime
>        ...
>    }
> }
> ```
>
> 然后通过如下代码可以创建一个线程然后开始运行
>
> ```java
> PrimeThread p = new PrimeThread(143);
> p.start();
> ```
>
> 创建线程的另一种方法是声明一个实现  Runnable 接口的类。然后，该类实现 run 方法。然后可以分配类的实例（即可以创建该类的实例），在创建 Thread 时将该实例对象作为参数传递，然后启动。其他样式中的相同示例如下所示：
>
> ```java
> class PrimeRun implements Runnable {
>     long minPrime;
>     PrimeRun(long minPrime) {
>         this.minPrime = minPrime;
>     }
> 
>     public void run() {
>         // compute primes larger than minPrime
>         ......
>     }
> }
> ```
>
> 然后创建线程对象，启动
>
> ```java
> PrimeRun p = new PrimeRun(143);
> new Thread(p).start();
> ```
>
> 每个线程都有一个用于标识的名称。多个线程可能具有相同的名称。如果在创建线程时未指定名称，则会为其生成新名称。
>

---

**在 Thread 类的代码中同样含有设置了线程优先级代码，代码如下：**

```java
/**
* The minimum priority that a thread can have.
* 一个线程可以使用的最小优先级
*/
public final static int MIN_PRIORITY = 1;

/**
* The default priority that is assigned to a thread.
* 分配给一个线程的默认优先级
*/
public final static int NORM_PRIORITY = 5;

/**
* The maximum priority that a thread can have.
* 一个线程可以使用的最大优先级
*/
public final static int MAX_PRIORITY = 10;
```

注意构造方法中的参数含义，start 方法、run 方法。

~~针对 start 方法中的 JavaDoc 文档中  P710 的疑惑~~

```
* 结果就是两个线程同时执行：当前线程（调用 start 方法返回的线程）和其他线程（执行其 run 方法的线程）。
* 因为调用 start 方法肯定是通过某个线程的对象来调用 start 方法，这是一个线程。  =》调用 start 方法的线程
* 当调用 start 方法之后，JVM 又会调用该线程的 run 方法，这是在另一个线程中执行。=》调用 run 方法的线程
```



### （三）Runnable 接口（函数型接口）

**下面为 Runnable 接口的 JavaDoc 文档**

> `Runnable` 接口应该由其实例（要由线程执行的任何类）实现。该类必须定义一个没有参数的 run 方法。
>
> 此接口旨在为希望在活动时执行代码的对象提供通用协议。例如，Thread 类实现了 Runnable 接口。
>
> **处于活动状态只意味着线程已启动但尚未停止**。
>
> 此外，`Runnable` 提供了一种方法，使类在不子类化 `Thread` 类的情况下处于活动状态。实现 Runnable 接口的类可以通过实例化 Thread 实例并将其自身作为目标传入而运行，而无需子类化 Thread 类。在大多数情况下，**如果您只计划重写 run（）方法，而不打算重写其他 Thread 类的方法，则应使用  Runnable 接口**。这一点很重要，因为除非程序员打算修改或增强类的基本行为，否则不应该对类进行子类化（即不应该继承）。

```java
package java.lang;

/*
 * @author  Arthur van Hoff
 * @see     java.lang.Thread
 * @see     java.util.concurrent.Callable
 * @since   JDK1.0
 */
@FunctionalInterface
public interface Runnable {
    /**
    // 当实现 Runnable 接口的对象被用于创建一个线程的时候，启动该线程的时候会导致该对象的 run 方法在独立执行的线程中被调用。
     */
    public abstract void run();
}
```

## 二、wait 和 sleep 方法字节码分析

### （一）Object 类中的关于线程的方法

主要包括 wait（） 、notify 、notifyAll 方法

```java
/*
 * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package java.lang;

/**
 * Class {@code Object} is the root of the class hierarchy.
 * Every class has {@code Object} as a superclass. All objects,
 * including arrays, implement the methods of this class.
 *
 * @author  unascribed
 * @see     java.lang.Class
 * @since   JDK1.0
 */
public class Object {

    public final native void notify();

    public final native void notifyAll();
   
    public final native void wait(long timeout) throws InterruptedException;
   
    public final void wait(long timeout, int nanos) throws InterruptedException {
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }

        if (nanos >= 500000 || (nanos != 0 && timeout == 0)) {
            timeout++;
        }

        wait(timeout);
    }
}    
```
### （二）wait 方法详解

#### 1.无参数 wait 方法分析

**wait 方法的 JavaDoc**，这里是针对无参数的 wait() 方法：

> 会使当前线程等待，直到另一个线程调用此对象的 `java.lang.Object.notify()` 方法或`java.lang.Object.notifyAll()` 方法。（因此 wait 和 notify或者 notifyall 方法总是成对出现的，wait 会使当前线程出现等待，直到另一个线程调用了当前这个对象的 notify 或者 notifyAll 方法才会使当前线程被唤醒）
>
> 换句话说，这个方法的行为就像它只是执行调用 wait（0）(因为 wait() 里面的参数为超时时间，如果不写或者是 wait(0) 就是一直等待)。
>
> 当前线程必须拥有此对象的监视器（通常就是指锁）。（当这个线程调用了 wait 方法之后）线程释放此监视器的所有权并等待，直到另一个线程通过调用 `notify` 方法或 `notifyAll` 方法通知等待此对象监视器唤醒的线程。然后线程还需等待，直到它可以重新获得监视器的所有权并继续执行。

上面总结：

  - 如果想调用 wait 方法，当前线程必须拥有这个对象的锁
  - 一旦调用 wait 方法之后，调用该方法的线程就会释放被他所调用的对象的锁，然后进入等待状态。
   - 一直等待到另外的线程去通知在这个对象的锁上面等待的所有的线程（因为有可能一个对象，有多个线程都调用了这个对象的 wait 方法，这样多个线程都会陷入等待的状态）

> 在单参数版本中，中断和虚假唤醒是可能发生的，此方法应始终在循环中使用：
>
> ```java
> synchronized (obj) {
>     while (<条件尚未满足>)
>         obj.wait();
>      ...//Perform action appropriate to condition
> } 
> ```
>
> **此方法只能由作为此对象监视器所有者的线程调用**（即只能被拥有该对象锁的线程调用）。请参阅 notify方法，以了解线程成为监视器所有者的方式（线程如何获取对象的锁见 notify 方法）。

```java
/* @throws  IllegalMonitorStateException  if the current thread is not
     *               the owner of the object's monitor.
     * @throws  InterruptedException if any thread interrupted the
     *             current thread before or while the current thread
     *             was waiting for a notification.  The <i>interrupted
     *             status</i> of the current thread is cleared when
     *             this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
public final void wait() throws InterruptedException {
    wait(0);
}
```
----

【针对上面的 wait 方法】所以当前线程必须持有对象的锁才能调用 wait 方法，而且一旦调用 wait 方法之后就会将调用了 wait 对象的锁释放掉。同时线程还有一个 sleep 方法（Thread 类中）。

上面分析的是不带参数的 wait 方法，该方法实际实际上是调用了带参数的 wait 方法（见下），传入的是参数 0，接下来分析带参数的 wait 方法

```java
  public final void wait() throws InterruptedException {
        wait(0);
    }
```

#### 2.带参数 wait 方法分析

-----

> 使当前线程等待，直到另一个线程调用此对象的 notify（）方法或 notifyAll（）方法，或者指定的时间已过。
> 当前线程必须拥有此对象的监视器（锁）。
>
> 此方法会导致当前线程（称为 T 线程）将其自身放置在此对象的等待集合中，然后放弃此对象上的任何和所有同步声明（即是释放锁）。线程 T 出于线程调度目的被禁用，并处于休眠状态，直到发生以下四种情况之一：
>
> - 其他一些线程调用了此对象的 notify 方法，而线程 T 恰好被任意选择为要唤醒的线程（从等待集合中选择一个）。
> - 其他一些线程为此对象调用 notifyAll 方法。
> - 其他一些线程中断了线程 T 。
> - 指定的时间或多或少已经过去。但是，如果参数 timeout 为零，则不考虑实时性，线程只需等待通知。
>
> 然后从该对象的等待集合删除线程 T （因为已经被唤醒了），并重新启用线程调度。然后，它以通常的方式与其他线程去竞争该对象上的同步权；一旦它获得了对象的控制权（可以对这个对象同步了），它对对象的所有同步声明都将恢复到原来的状态，也就是说，恢复到调用 wait 方法时的所处的状态。然后线程 T 从 wait方法的调用中返回。因此，从 wait 方法返回时，对象和线程 T 的同步状态与调用 wait 方法时完全相同。
>
> 线程也可以在不被通知、中断或超时的情况下唤醒，即所谓的“虚假唤醒”。虽然这种情况在实践中很少发生，但应用程序必须通过测试本应导致线程被唤醒的条件，并在条件不满足时继续等待来防范这种情况。换句话说，等待应该总是以循环的形式出现，如下所示
>
> ```java
> // 对 obj 对象同步和上锁
> synchronized (obj) {
>     while (<condition does not hold>)
>     // 当另一个线程调用 obj 的 notify 方法的时候，正好当前线程就是被唤醒的线程的话，就会从这里唤醒然后执行一系列操作，然后再次判断
>        obj.wait(timeout);
>        ... // Perform action appropriate to condition
> }
> ```
>
> 如果当前线程在等待之前或等待期间被任何线程中断，则抛出一个 InterruptedException。在还原此对象的锁定状态（如上所述）之前，不会引发此异常。
>
> 注意，wait 方法在将当前线程放入此对象的等待集合中时，只解锁此对象；在线程等待期间，当前线程可能同步的任何其他对象都将保持锁定状态（因为一个线程在执行的时候可能同时调用几个对象的 wait 方法，但是某个时刻通过 notify 方法唤醒线程之后，但是其他对象还保持锁定）。
>
> 此方法只能由作为此对象监视器所有者的线程调用。查看 notify 方法，了解线程成为监视器所有者的方式

----

```java
/*
     * @param      timeout   the maximum time to wait in milliseconds.// 超时时间，如果为 0 表示一直等待。
     * @throws  IllegalArgumentException      if the value of timeout is
     *               negative.
     * @throws  IllegalMonitorStateException  if the current thread is not
     *               the owner of the object's monitor.
     * @throws  InterruptedException if any thread interrupted the
     *             current thread before or while the current thread
     *             was waiting for a notification.  The <i>interrupted
     *             status</i> of the current thread is cleared when
     *             this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
public final native void wait(long timeout) throws InterruptedException;
```

另一个 wait 方法和上面 wait 一样，只不多加了一个设置纳秒的参数，可以实现更加精确的时间，可以从下面代码中看出最后还是调用了上面的一个参数的 wait 方法；

```java
// 这里的 JavaDoc 和上面相似，只是多了 nanos 说明以及使用方式
public final void wait(long timeout, int nanos) throws InterruptedException {
    if (timeout < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (nanos < 0 || nanos > 999999) {
        throw new IllegalArgumentException(
            "nanosecond timeout value out of range");
    }

    if (nanos >= 500000 || (nanos != 0 && timeout == 0)) {
        timeout++;
    }

    wait(timeout);
}
```



### （三）Thread 类的 sleep 方法详解

从下面Thread 类的 sleep 方法对应的 JavaDoc 可以看出 sleep 会一直持有该对象的锁，不会释放掉。

> 会导致当前正在执行的线程进入休眠状态（临时的停止执行一段特定时间的毫秒数），它会受到系统定时器和调度器的精度的影响。**线程并不会失去任何锁的所有权**。

```java
/* @param  millis
     *         the length of time to sleep in milliseconds
     *
     * @throws  IllegalArgumentException
     *          if the value of {@code millis} is negative
     *
     * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
public static native void sleep(long millis) throws InterruptedException;
```



测试1：线程必须用于对象的锁才能调用 wait 方法，如果直接调用会报错

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/14 11:23
 */

/**
 * 在调用 wait 方法时，线程必须要持有被调用对象的锁，当调用 wait 方法后，线程就会释放掉该对象的锁
 * 在调用 Thread 类的 sleep 方法时候，线程是不会释放掉对象的锁的。
 */
public class MyTest1 {
    public static void main(String[] args) throws InterruptedException {

        Object object = new Object();
        // 测试：线程必须用于对象的锁才能调用 wait 方法，如果直接调用会报错
        // Exception in thread "main" java.lang.IllegalMonitorStateException
        // 即当前的线程一定要持有调用 wait 对象（这里是 object 对象）的锁才可以
        // 解决方法：可以将调用 wait 方法放入 synchronized 同步代码块，因为进入代码块中就相当于获取到对象的锁了
        // object.wait();
        
        // 正确的使用方式如下：
        synchronized (object) {
            // 进入代码块相当于已经获取到 object 对象的锁
            object.wait();
        }
    }
}

```

对编译之后的 MyTest1.class 进行反编译之后得到（下面仅仅为 main 方法中反编译结果）

```java
 public static void main(java.lang.String[]) throws java.lang.InterruptedException;
    Code:
       0: new           #2                  // class java/lang/Object
       3: dup
       4: invokespecial #1                  // Method java/lang/Object."<init>":()V
       7: astore_1
       8: aload_1
       9: dup
      10: astore_2
      11: monitorenter // 注：当执行 synchronized 代码块，一旦进入对应的字节码指令为 monitorenter
      12: aload_1
      13: invokevirtual #3                  // Method java/lang/Object.wait:()V
      16: aload_2
      17: monitorexit // 注：从 synchronized 代码块正常或非正常退出都对应着 monitorexit 指令
      18: goto          26
      21: astore_3
      22: aload_2
      23: monitorexit // 这是异常的退出对应的 monitoexit 指令
      24: aload_3
      25: athrow
      26: return
```

**小结**

- 在调用 wait 方法时候，线程必须要持有被调用对象的锁，当调用 wait 方法之后，线程就会释放掉该对象的锁（monitor）。

- 在调用 Thread 类的 sleep 方法时候，线程是不会释放掉对象的锁的。



## 三、notify 方法详解以及线程获取锁的方式

### （一） notify 方法分析

下面为 notify 方法的 JavaDoc

---

> 唤醒等待此对象锁的单个线程。如果有任何（多个）线程正在等待这个对象（的锁），则选择其中一个等待的线程被唤醒。选择是任意的，由实现者自行决定。线程通过调用这个对象 wait 方法中的一个（因为有多个 wait）来等待对象的监视器。
>
> 在当前线程放弃对该对象的锁定之前，唤醒的线程将无法继续（执行）。唤醒的线程将以通常的方式与任何其他线程竞争，这些线程竞争在此对象上的同步；例如，唤醒的线程在成为下一个锁定此对象的线程时没有可靠的特权或劣势（和其它线程地位相同）。
>
> 此方法只能由作为此对象监视器所有者的线程调用（即调用了 notify 方法的线程一定是持有当前对象锁的线程）。线程通过以下三种方式之一成为对象锁的持有者：
>
> - 通过执行该对象的同步实例方法（即被标记为 Synchronized 的实例方法）。
> - 通过执行在对象上同步的{@code synchronized}语句的主体（即执行 synchronized 的语句块）。
> - 对于 class 类型的对象，通过执行该类的同步静态方法(即被标记为 Synchronized 的静态方法)
>     在某一时刻只有一个线程可以拥有该对象的锁的。

----

```java
/*
 * @throws  IllegalMonitorStateException  if the current thread is not
 *               the owner of this object's monitor.
 * @see        java.lang.Object#notifyAll()
 * @see        java.lang.Object#wait()
 */
public final native void notify();
```

### （二）notifyAll 方法分析

首先是介绍 notifyAll 方法的 JavaDoc

>**会唤醒此对象监视器上等待的所有线程**。线程通过调用其中一个 wait 方法来等待对象的监视器（锁）。
>
>在当前线程放弃对该对象的锁定之前，被唤醒的线程将无法继续。唤醒的线程将以通常的方式与任何其他线程竞争，这些线程可能正在积极竞争以在此对象上同步；例如，唤醒的线程在成为下一个锁定此对象的线程时没有可靠的特权或劣势。
>
>此方法只能由作为此对象监视器所有者的线程调用。请参阅{@code notify}方法，以了解线程成为监视器所有者的方式。

```java
   /**
     * @throws  IllegalMonitorStateException  if the current thread is not
     *               the owner of this object's monitor.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#wait()
     */
public final native void notifyAll();
```



### （三）wait 和 notify 、notifyAll 方法与线程同步系统总结

- 当调用 wait 方法时，首先需要确保**调用的 wait 方法的线程已经持有了对象的锁**；这里的对象是调用 wait 的对象，因为 wait 是定义在 Object 类中，所以任何一个对象都会有一个 wait 方法。
- 当调用 wait 方法后，该线程就会释放掉这个对象的锁，然后进入到等待状态（或者成为等待集合：wait set)；
- 当线程调用了 wait 之后进入到等待状态时候，它就可以等待其他线程调用相同对象的 notify 或 notifyAll 方法来使得自己被唤醒；
- 一旦这个线程被其他线程唤醒之后，该线程就会与其他线程一同开始**竞争**这个对象的锁（公平竞争）；**只有当该线程获取到了这个对象的锁之后**，代码才会继续向下执行，没有获取到则继续等待。
- 调用 wait 方法的代码片段需要放在一个 synchronized 块或者是 synchronized 方法中，这样才可以确保线程在调用 wait 方法前已经获取到了对象的锁。
- 当调用对象的 notify 方法时，它会随机唤醒该对象等待集合（wait set) 中的任意一个线程，当某个线程被唤醒之后，他就会与其他线程一同竞争对象的锁。
- 当调用对象的 notifyAll 方法时候，他就会唤醒该对象等待集合（wait set) 中的所有线程，这些线程被唤醒之后，又会开始竞争对象的锁；
- 在某一个时刻，只有唯一一个线程可以拥有对象的锁。



### （四）wait 和 notify 方法案例剖析和详解

编写一个多线程程序，实现目标：

- 存在一个对象，该对象（即对象对应的类中）存在一个 int 类型的成员变量 counter，该成员变量的初始值为 0；
- 创建两个线程，其中一个线程对该对象的成员变量 counter 增1，另一个线程对该对象的成员变量减 1；
- 输出该对象成员变量 counter 每次变化后的值；最终输出的结果应该为：1010101010…



**分析**

- 需要两个线程，因为操作不同，所以需要两个线程类；

首先构造 MyObject 类

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 10:51
 */
public class MyObject {
    private int counter;

    // 分别实现递增、递减方法，因为要调用 wait 方法，所以需要使用 synchronized
    public synchronized void increase() {
        // 进入 increase 方法之后，说明该线程已经拿到该对象的锁，如果 counter 不为 0，则该线程等待
        while (counter != 0) {
            try {
                // 调用 wait 使得释放掉该对象的锁，使得递减的线程拿到锁
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 当另一个线程执行完递减之后，调用 notify 方法让递增线程唤醒了
        counter++;
        System.out.println(counter);
        // 通知其它线程起来（因为只有两个线程，所以这里就是指递减的线程）
        notify();
    }

    // 下面的解释同上
    public synchronized void decrease() {
        while (counter == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        counter--;
        System.out.println(counter);
        notify();
    }
}
```

然后分别实现递增和递减两个线程类

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 11:18
 */
public class IncreaseThread extends Thread {
    // 因为要操作 MyObject 的对象
    private MyObject myObject;

    public IncreaseThread(MyObject myObject) {
        this.myObject = myObject;
    }

    // 重写 run 方法
    @Override
    public void run() {
        for (int i = 0; i < 30; i++) {
            // 每次先让线程随机休眠 0 ~ 1 秒
            try {
                Thread.sleep((long) (Math.random() * 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 每次调用都会尝试获取该对象的锁，如果获取到就进入了方法体内部，然后判断 counter 不等于 0 的话就会释放掉这把锁，并且进入等待状态。直到另一个线程使用 notify  进行唤醒继续往下执行。
            myObject.increase();
        }
    }
}

```

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 11:24
 */
public class DecreaseThread extends Thread {
    private MyObject myObject;

    public DecreaseThread(MyObject myObject) {
        this.myObject = myObject;
    }

    // 重写 run 方法
    @Override
    public void run() {
        for (int i = 0; i < 30; i++) {
            // 每次先让线程休眠 0 ~ 1 秒
            try {
                Thread.sleep((long) (Math.random() * 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            myObject.decrease();
        }
    }
}

```

最后在 main 方法中创建分别创建一个递增和递减线程，然后执行程序

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 11:26
 */
public class Client {
    public static void main(String[] args) {
        // 只能创建一个对象，因为锁是加在对象上，如果两个线程操作两个对象就没有意义了MyObject myObject = new MyObject();
        MyObject myObject = new MyObject();
        Thread increaseThread = new IncreaseThread(myObject);
        Thread decreaseThread = new DecreaseThread(myObject);
        increaseThread.start();
        decreaseThread.start();
    }
}
```

程序运行结果：（这里选取前十结果）

```java
1
0
1
0
1
0
1
0
1
0
```

如果创建 4 个线程对象，它们分别来自两个类的实例（IncreaseThread 和 DecreaseThread），然后分别启动这 4 个线程。

```java
package com.gjxaiou;

public class Client {
    public static void main(String[] args) {
    
        MyObject myObject = new MyObject();
        Thread increaseThread = new IncreaseThread(myObject);
        Thread increaseThread2 = new IncreaseThread(myObject);
        Thread decreaseThread = new DecreaseThread(myObject);
        Thread decreaseThread2 = new DecreaseThread(myObject);
        increaseThread.start();
        increaseThread2.start();
        decreaseThread.start();
        decreaseThread2.start();
    }
}
```

执行结果就是随机值了。同时程序执行完之后，JVM 并没有退出。【前提是 increase 和 decrease 方法中使用是 if 额不是 while】

原来只有两个线程对象，一个增加一个减少。假如在某个时刻，用于增加的线程进入了  increase 方法，如果此时恰巧 counter = 0，则会执行 counter++，然后输出 1，接着调用 notify() 方法，notify 只会唤醒唯一一个即用于减少的线程（执行 decrease() 方法的线程对象），该线程对象可能正处于  wait() 方法位置，然后因为收到  notify 通知，则该线程被唤醒（因为只有 2 个线程，所以一个线程调用 notify 会唤醒另一个）。然后减少线程起来之后 counter—，输出 0，然后又调用了 notify 。减少的线程调用 notify 唤醒的肯定是调用增加方法的线程，该线程可能处于 wait() 状态，或者还没有拿到锁而没有进入 increase 方法。

针对四个线程对象：

例如开始是起始状态，counter = 0。两个用于增加的线程中的一个进入了 increase 方法中，则会依次执行 counter++，然后输出，并且调用 notify 方法，唤醒在这个 object 对象上调用 wait 方法的线程，如果此时没有线程在 wait，则第一个线程正常执行完该方法之后就退出了。然后用于减少的线程对象中的一个执行了 decrease 方法，然后依次执行counter–，然后输出，然后执行  notify 方法。如果第三个线程执行的是减少的方法，然后因为 counter = 0，则进入 wait 进行等待。因为 wait  会释放掉这个对象的锁，则另外三个线程（2个用于增加，一个用户减少）都有可能执行  increase 和 decrease 方法，如当减少线程进入 decrease 方法，由进行了减一操作。

进入 wait 之后被 notify 唤醒之后也要再次争抢获取对象的锁，获取到才能继续执行。没抢到就一直在 wait 进行等待。

修改 if 为 while，即当线程从 wait 被唤醒之后需要再次判断  counter 的值，因为此时 counter 值可能被其它线程修改，使得其不再是之前进入 wait 时候的值了，符合了才能继续执行。

## 二、synchronized 关键字原理详解

### （一）引言

**关于 synchronized 的一道题目**

```java
public class Test{
    public synchronized void method1(){
    }
    
    public synchronized void method2(){
    }
}
// 当创建 Test 的唯一一个实例（对象）
Test test = new Test():
// 当一个线程执行这个对象的 method1 时候（还没有执行完），其他线程能不能执行该对象的 method2

```

【解答】不能，因为对于同一个对象来说，它的所有 synchronize 方法锁的对象是同一个东西，当一个线程正在执行其中的一个 synchronized 方法的时候，其他线程执行不了其他方法的，因为该 synchronized 方法已经被该线程进去了，已经获取该对象的锁了。

如果创建了两个对象就可以了，因为一个线程获取一个对象的锁并不妨碍另一个线程获取另一个对象的锁。

- 代码修改：

    ```java
    public class Test{
        public synchronized void method1(){
        }
        
        public static synchronized void method2(){
        }
    }
    // 当创建 Test 的唯一一个实例（对象）
    Test test = new Test():
    // 当一个线程执行这个对象的 method1 时候（还没有执行完），其他线程能不能执行该对象的 method2
    ```

    可以，因为第一个方法的 synchronized 关键字锁的是当前的  test 对象，而第二个 方法的synchronized 关键字锁的是当前 test 对象所对应的 Class 对象（因为本质上一个静态方法并不属于当前对象，属于当前对象所对应的 Class 对象），是两个独立的对象，两个对立的对象拥有各自独立的锁。

### （二）测试

#### 1.测试程序一：

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 15:16
 */
public class MyThreadTest {
    public static void main(String[] args) {
        Runnable thread = new MyThread();
        // 因为创建线程 thread1 和 thread2 对象时候传入的是同一个 Runnable 实例对象
        Thread thread1 = new Thread(thread);
        Thread thread2 = new Thread(thread);
        // 因此当两个线程启动 start 方法时候都会去执行同一个 MyThread 对象里面的 run 方法
        thread1.start();
        thread2.start();
    }
}

// 该线程类实现了 Runnable 接口
class MyThread implements Runnable {
    // 共享的成员变量
    int x;

    public void run() {
        x = 0;
        while (true) {
            System.out.println("result:" + x++);

            try {
                Thread.sleep((long) (Math.random() * 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if (x == 30) {
                break;
            }
        }
    }
}
```

程序执行结果：

```java
result:0
result:0
result:1
result:2
result:3
result:4
result:5
result:6
result:7
result:8
result:9
result:10
result:11
result:12
result:13
result:14
result:15
result:16
result:17
result:18
result:19
result:20
result:21
result:22
result:23
result:24
result:25
result:26
result:27
result:28
result:29

Process finished with exit code 0

```

通过下面一个小的框架示例来说明上面程序

```java
// struts2
public class LoginAction{
    private String username;
    private String password;
}
```

这两个成员变量分别对应着用户请求表单中对应的两个参数。参数的信息是以成员变量的形式放置到类中的，但是成员变量可能会被多线程修改的。所以 Struts 的 LoginAction 就是一个多实例的，就是用户每一次访问登录都会创建一个新的实例。这样只有一个线程会访问到同一个实例。

```java
public class LoginController{
	public void login(String username, String password){
	}
}
```

在 SpringMVC 中，当用户登录的时候，表单中的信息就会映射到方法的两个参数中，而对于一个方法而言，无论方法的参数还是方法内部代码声明的变量，都是局部变量。而局部变量是归一个线程所独有。所以在 Controller 中一般不会定义可以被修改的成员变量。一般都是放置只读的或者无状态的变量。

看一个对象中是否有可被修改的成员变量来判断该对象是有状态还是无状态的对象。

#### 2.测试程序二：

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 16:00
 */
public class MyThreadTest2 {
    public static void main(String[] args) {
        // 使用此种方式输出为：hello,world
        MyClass myClass = new MyClass();
        Thread1 thread1 = new Thread1(myClass);
        Thread2 thread2 = new Thread2(myClass);

        // 测试方式二：
        // 如果使用以下代码代替上面代码，结果为 ：world,hello
//        MyClass myClass = new MyClass();
//        MyClass myClass1 = new MyClass();
//        Thread1 thread1 = new Thread1(myClass);
//        Thread2 thread2 = new Thread2(myClass1);

        thread1.start();
        // 休眠一段时间
        try {
            Thread.sleep(700);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread2.start();
    }
}

class MyClass {
    public synchronized void hello() {
        // thread1 首先进入 hello 方法，即是下面休眠了，但是不会释放对 myClass 对象的锁
        // 所以即是上面主线程在 700 毫秒之后恢复了，接着 thread2 启动，然后访问 world 方法，因为这时候 myClass 对象的锁还在 thread1 中，所以不能访问。
        try {
            Thread.sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("hello");
    }

    public synchronized void world() {
        System.out.println("world");
    }
}

// 定义两个线程类
class Thread1 extends Thread {
    private MyClass myClass;

    public Thread1(MyClass myClass) {
        this.myClass = myClass;
    }

    @Override
    public void run() {
        myClass.hello();
    }
}

class Thread2 extends Thread {
    private MyClass myClass;

    public Thread2(MyClass myClass) {
        
        
        this.myClass = myClass;
    }

    @Override
    public void run() {
        myClass.world();
    }
}
```

如果一个对象中含有若干个 synchronized 方法，那么在某一个时刻只能有唯一的线程进入到其中一个 synchronized 方法。其他线程即使想访问其他 synchronized 方法也要等待。因为当一个线程想要访问其中一个 synchronized 方法的时候，要尝试着获取当前对象的锁（而当前对象只有唯一的一把锁）。

### （三）透过字节码理解 synchronized 关键字

- synchronized 关键字一般用于修饰一个方法或者修饰一个代码块

    - 修饰方法

        方法可以是静态或者非静态的，如果是修饰实例方法（不加 static 关键字），当线程去访问的该方法的时候，是给当前对象上锁。如果是修饰静态方法，线程访问该方法的的时候是给该对象对应的类的 Class 对象上锁。

    - 修饰代码块：

        synchronized 关键字 后面会跟上一个对象的名字（引用的名字），加上具体执行的代码逻辑。



**总结**：当我们使用 synchronized 关键字来修饰代码块时候，字节码层面上是通过 monitorenter 和 monitorexit 指令来实现锁的获取与释放动作。

当线程进入到 monitorenter 指令后，线程将会持有被同步的对象（就是 synchronized 关键值后面括号中的对象）的 monitor 对象，当退出 monitorenter 指令之后（即执行 monitorexit 指令），线程将会释放该 monitor 对象。

#### 1. synchronized 关键字修饰代码块

**测试程序1：**

```java
package com.gjxaiou.synchronize;

/**
 * 测试 synchronized 用法
 *
 * @Author GJXAIOU
 * @Date 2020/2/16 21:51
 */
public class MyTest1 {
    // 同步代码块（因为一个方法中可能只有几行需要上锁，所以关键字即可）
    private Object object = new Object();

    public void method() {
        // 表示对 object 对象上锁，当执行到这里的时候该线程会尝试获取 object 对象的锁，如果获取到就就行执行，如果获取不到就阻塞了。
        synchronized (object) {
            System.out.println("hello world");
        }
    }
}
```

**反编译之后的结果** 更加具体的反编译：包括常量池信息

```java
E:\Program\Java\Project\JavaConcurrency\ProficientInJavaConcurrency\target\classes\com\gjxai
ou\synchronize>javap -v MyTest1.class
Classfile /E:/Program/Java/Project/JavaConcurrency/ProficientInJavaConcurrency/target/classe
s/com/gjxaiou/synchronize/MyTest1.class
  Last modified 2020-2-16; size 624 bytes
  MD5 checksum 1f26b481eb5d16a1179ccfb6138ef19e
  Compiled from "MyTest1.java"
public class com.gjxaiou.synchronize.MyTest1
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   // 常量池省略
{
     // 编译器自动生成的构造方法
  public com.gjxaiou.synchronize.MyTest1();
   // 构造方法省略

  public void method();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1 // 最大栈深度、局部变量表的数量和参数的数量（因为 Java 中任何实例方法的第一个参数都是 this(不是在定义或者声明该方法的时候显式指定的，而是编译器在程序编译完成之后动态传入的)，所以我们可以在方法中使用 this 关键字来引用当前对象的成员变量或者其他方法）
         0: aload_0
         1: getfield      #3                  // Field object:Ljava/lang/Object; // 表示获取当前对象的成员变量（因为 synchronized 要对 object 对象进行同步，所以要先获取该对象） 
         4: dup
         5: astore_1 
         6: monitorenter  // 执行完该行助记符之后就进入了同步方法里面了
         7: getstatic     #4   // Field java/lang/System.out:Ljava/io/PrintStream;
             // 首先要获取到 system.out 对象（该对象实际为一个 System 类中的静态变量，点进去看看，类型是 java.lang.PrintStream）
        10: ldc           #5                  // String hello world
        12: invokevirtual #6// Method java/io/PrintStream.println:(Ljava/lang /String;)V  // 调用了 out 对象中的 println 方法
        15: aload_1
        16: monitorexit  // 锁退出(正常退出）
        17: goto          25
        20: astore_2
        21: aload_1
        22: monitorexit  // 出现异常时候退出，保证该线程无论十分情况下都可以释放掉该对象的锁
        23: aload_2
        24: athrow
        25: return
      Exception table:
         from    to  target type
             7    17    20   any
            20    23    20   any
      LineNumberTable:
        line 15: 0
        line 16: 7
        line 17: 15
        line 18: 25
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      26     0  this   Lcom/gjxaiou/synchronize/MyTest1;
}
SourceFile: "MyTest1.java"
```

**测试程序 2**：如果两个方法中都含有 synchronized 修饰的代码块

```java
package com.gjxaiou.synchronize;

/**
 * 测试 synchronized 用法
 *
 * @Author GJXAIOU
 * @Date 2020/2/16 21:51
 */
public class MyTest1 {
    // 同步代码块（因为一个方法中可能只有几行需要上锁，所以关键字即可）
    private Object object = new Object();

    public void method() {
        // 表示对 object 对象上锁，当执行到这里的时候该线程会尝试获取 object 对象的锁，如果获取到就就行执行，如果获取不到就阻塞了。
        synchronized (object) {
            System.out.println("hello world");
        }
    }

    public void method2(){
        synchronized (object){
            System.out.println("welcome");
        }
    }
}

```

反编译之后的结果为：**每个方法都生成了一个 monitorenter 和 2 个 monitorexit**

```java
E:\Program\Java\Project\JavaConcurrency\ProficientInJavaConcurrency\target\classes\c
om\gjxaiou\synchronize>javap -v MyTest1.class
Classfile /E:/Program/Java/Project/JavaConcurrency/ProficientInJavaConcurrency/targe
t/classes/com/gjxaiou/synchronize/MyTest1.class
  Last modified 2020-2-17; size 757 bytes
  MD5 checksum 2908e6ef3bf3551cae84950f5a1bf947
  Compiled from "MyTest1.java"
public class com.gjxaiou.synchronize.MyTest1
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
// 常量池省略
{
  public com.gjxaiou.synchronize.MyTest1();
// 构造方法省略

  public void method();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: getfield      #3                  // Field object:Ljava/lang/Object;
         4: dup
         5: astore_1
         6: monitorenter
         7: getstatic     #4                  // Field java/lang/System.out:Ljava/io
/PrintStream;
        10: ldc           #5                  // String hello world
        12: invokevirtual #6                  // Method java/io/PrintStream.println:
(Ljava/lang/String;)V
        15: aload_1
        16: monitorexit
        17: goto          25
        20: astore_2
        21: aload_1
        22: monitorexit
        23: aload_2
        24: athrow
        25: return
      Exception table:
         from    to  target type
             7    17    20   any
            20    23    20   any
      LineNumberTable:
        line 15: 0
        line 16: 7
        line 17: 15
        line 18: 25
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      26     0  this   Lcom/gjxaiou/synchronize/MyTest1;

  public void method2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: getfield      #3                  // Field object:Ljava/lang/Object;
         4: dup
         5: astore_1
         6: monitorenter
         7: getstatic     #4                  // Field java/lang/System.out:Ljava/io
/PrintStream;
        10: ldc           #7                  // String welcome
        12: invokevirtual #6                  // Method java/io/PrintStream.println:
(Ljava/lang/String;)V
        15: aload_1
        16: monitorexit
        17: goto          25
        20: astore_2
        21: aload_1
        22: monitorexit
        23: aload_2
        24: athrow
        25: return
      Exception table:
         from    to  target type
             7    17    20   any
            20    23    20   any
      LineNumberTable:
        line 21: 0
        line 22: 7
        line 23: 15
        line 24: 25
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      26     0  this   Lcom/gjxaiou/synchronize/MyTest1;
}
SourceFile: "MyTest1.java"

```

**测试程序 3：**在上面代码中增加了抛出异常，字节码对应几个 monitorenter  和 monitorexit

```java
package com.gjxaiou.synchronize;

/**
 * 测试 synchronized 用法
 *
 * @Author GJXAIOU
 * @Date 2020/2/16 21:51
 */
public class MyTest1 {
    // 同步代码块（因为一个方法中可能只有几行需要上锁，所以关键字即可）
    private Object object = new Object();

    public void method() {
        // 表示对 object 对象上锁，当执行到这里的时候该线程会尝试获取 object 对象的锁，如果获取到就就行执行，如果获取不到就阻塞了。
        synchronized (object) {
            System.out.println("hello world");
            throw new RuntimeException();
        }
    }

    public void method2(){
        synchronized (object){
            System.out.println("welcome"):;
        }
    }
}
 	
```

反编译之后结果为：

**method1 方法对应字节码**为什么只有一个 monitorexit，因为代码块中代码无论是 print 语句还是 throw 语句抛出异常，该代码块最后都是以异常结束的。最终异常抛出对应 27 行的 athrow 助记符（ 22 行的 athrow 对应于显式的 throw new runtimeXX 动作。

**method2 方法对应字节码**中仍然为两个 monitorexit，因为程序有可能正常结束，正常结束的时候程序就从 17 行 goto 到 25 行（跳过了中间异常退出）直接 return，如果要是抛出异常的话，会在想 22 行那样先释放锁，然后在 24 行抛出异常。

```java
E:\Program\Java\Project\JavaConcurrency\ProficientInJavaConcurrency\target\classes\com\gjxaiou\synchronize>javap -v MyTest1.class
Classfile /E:/Program/Java/Project/JavaConcurrency/ProficientInJavaConcurrency/target/classes/com/gjxaiou/synchronize/MyTest1.class
  Last modified 2020-2-17; size 788 bytes
  MD5 checksum b98e0d981195ca3814a94fc4872ecb95
  Compiled from "MyTest1.java"
public class com.gjxaiou.synchronize.MyTest1
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
 // 常量池省略
{
  public com.gjxaiou.synchronize.MyTest1();
   // 构造函数省略
  public void method();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: getfield      #3                  // Field object:Ljava/lang/Object;
         4: dup
         5: astore_1
         6: monitorenter
         7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        10: ldc           #5                  // String hello world
        12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        15: new           #7                  // class java/lang/RuntimeException
        18: dup
        19: invokespecial #8  // 因为 new 出来一个 RuntimeException 实例，所以调用其的构造方法                // Method java/lang/RuntimeException."<init>":()V
        22: athrow
        23: astore_2
        24: aload_1
        25: monitorexit // 代码块执行结束释放锁
        26: aload_2
        27: athrow
      Exception table:
         from    to  target type
             7    26    23   any
      LineNumberTable:
        line 15: 0
        line 16: 7
        line 17: 15
        line 18: 23
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      28     0  this   Lcom/gjxaiou/synchronize/MyTest1;

  public void method2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: getfield      #3                  // Field object:Ljava/lang/Object;
         4: dup
         5: astore_1
         6: monitorenter
         7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        10: ldc           #9                  // String welcome
        12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        15: aload_1
        16: monitorexit
        17: goto          25
        20: astore_2
        21: aload_1
        22: monitorexit
        23: aload_2
        24: athrow
        25: return
      Exception table:
         from    to  target type
             7    17    20   any
            20    23    20   any
      LineNumberTable:
        line 22: 0
        line 23: 7
        line 24: 15
        line 25: 25
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      26     0  this   Lcom/gjxaiou/synchronize/MyTest1;
}
SourceFile: "MyTest1.java"
```



#### 2.synchronized 关键字修饰方法

**总结**：synchronized 关键字修饰方法的时候，并没有出现 monitorenter 和 monitorexit 指令，而是在 JVM 层面通过方法的标识（flags)来标识这个是否为一个同步方法。从字节码中可以看出对应于：`ACC_SYNCHRONIZED`，当线程去调用该方法的时候首先就会去检验该方法是否含有 `ACC_SYNCHRONIZED` 标志位，如果有的话会该执行线程尝试获取当前方法所在的对象的锁（即对象的 monitor 对象），获取到锁之后才会正常的执行方法体。在该方法执行期间，其他任何线程均无法再获取到这个 monitor 对象（锁），当线程执行完方法之后或者抛出异常，它会释放掉这个 monitor 对象。

**测试代码 1**：

```java
package com.gjxaiou.synchronize;

/**
 * @Author GJXAIOU
 * @Date 2020/2/17 20:51
 */
public class MyTest2 {
    public synchronized void method() {
        System.out.println("hello world");
    }
}
```

对应反编译结果

```java
E:\Program\Java\Project\JavaConcurrency\ProficientInJavaConcurrency\target\classes\com\gjxai
ou\synchronize>javap -v MyTest2.class
Classfile /E:/Program/Java/Project/JavaConcurrency/ProficientInJavaConcurrency/target/classe
s/com/gjxaiou/synchronize/MyTest2.class
  Last modified 2020-2-17; size 520 bytes
  MD5 checksum e31ae67e69b765315b9facb2b3d2e48d
  Compiled from "MyTest2.java"
public class com.gjxaiou.synchronize.MyTest2
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
// 常量池省略
{
  public com.gjxaiou.synchronize.MyTest2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/gjxaiou/synchronize/MyTest2;

  public synchronized void method();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED  // 通过 ACC_SYNCHRONIZED 标识为一个同步方法
    Code:
      stack=2, locals=1, args_size=1
      0: getstatic     #2    // Field java/lang/System.out:Ljava/io/PrintStream;
      3: ldc           #3                  // String hello world
      5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      8: return
     LineNumberTable:
        line 9: 0
        line 10: 8
     LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lcom/gjxaiou/synchronize/MyTest2;
}
SourceFile: "MyTest2.java"

```



#### 3. synchronized 关键字修饰静态方法

同样通过 ACC_SYNCHRONIZED 标识

当线程去调用该方法的时候首先就会去检验该方法是否含有 `ACC_SYNCHRONIZED`  和 `ACC_STATIC`标志位，如果有的话会该执行线程尝试获取当前方法所在的类的对应 Class 对象的锁（即 Class 对象的 monitor 对象），获取到锁之后才会正常的执行方法体。在该方法执行期间，其他任何线程均无法再获取到这个 monitor 对象（锁），当线程执行完方法之后或者抛出异常，它会释放掉这个 monitor 对象。

**测试程序 1：**

```java
package com.gjxaiou.synchronize;

/**
 * @Author GJXAIOU
 * @Date 2020/2/17 21:12
 */
public class MyTest3 {
    public static synchronized void method() {
        System.out.println("hello world");
    }
}

```

对应的字节码为：

```java
E:\Program\Java\Project\JavaConcurrency\ProficientInJavaConcurrency\target\classes\com\gjxaiou\synchronize>javap -v MyTest3.class
Classfile /E:/Program/Java/Project/JavaConcurrency/ProficientInJavaConcurrency/target/classe
s/com/gjxaiou/synchronize/MyTest3.class
  Last modified 2020-2-17; size 502 bytes
  MD5 checksum 02b9ebc1b02bd60130e038ace131515a
  Compiled from "MyTest3.java"
public class com.gjxaiou.synchronize.MyTest3
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   // 省略常量池
{
  public com.gjxaiou.synchronize.MyTest3();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/gjxaiou/synchronize/MyTest3;

  public static synchronized void method();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED
    Code:
      // 这是显示方法参数个数为 0，因为该方法是静态方法，原则上这个方法并不属于 MyTest3 这个类（我们可以在没有生成 MyTest3 对象的情况下使用类名直接调用该方法），
      stack=2, locals=0, args_size=0
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintSt
ream;
         3: ldc           #3                  // String  hello world
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/l
ang/String;)V
         8: return
      LineNumberTable:
        line 9: 0
        line 10: 8
}
SourceFile: "MyTest3.java"
```



### （四）自旋对于 synchronized 关键字的底层意义与价值分析

> 注：一个线程调用了 wait 方法之后就会进入 waitset 中，当另一个线程调用了 notify/notifyAll 方法之后会将这个线程唤醒，唤醒之后争用锁，争到就执行，没争到就阻塞进入了 EntryList 中；阻塞的线程进入 EntryList 中。

JVM 中的同步是基于进入与退出监视器对象（即 Monitor 对象）（Monitor 也称为 **管程**）来实现的，每个对象实例都会有一个 Monitor 对象， Monitor 对象会和 Java 对象一同创建和销毁（当创建 Java 对象时候，JVM 会对应生成其 Monitor 对象，并将两者进行连接，实际上 Monitor 对象在 Java 对象头中）， Monitor 对象是由 C++ 来实现的。

当多个线程同时访问一段同步代码时，这些线程会被放入一个 EntryList 集合中，处于阻塞状态的线程都会被放到该列表当中，接下来，当线程获取到对象的 Monitor 时候， Monitor 是依赖于底层操作系统的 matex Lock 来实现互斥的，线程获取 mutex 成功，则会持有该 mutex，这时其他线程就无法在获取到该 mutex。

**所以 synchronized 底层是基于操作系统的互斥锁实现的**。

如果线程调用了 wait 方法，那么该线程就会释放掉所持有的 mutex，并且该线程会进入到 WaitSet （等待集合）中，等待下一次被其他线程调用 notify/notifyAll 唤醒，如果当初线程顺利的执行完毕方法，那么他也会释放所持有的 mutex。

当一个线程调用了 wait 方法，该线程就会进入 waitSet（等待集合）中，等待其他线程调用 notify 或者 notifyAll 方法来唤醒，如果被成功唤醒之后，就会尝试着获取对象的锁，如果成功获取了锁就拥有了该对象的 monitor 对象，然后正常执行。如果没有获得对象的锁，该线程就会进入到 EntryList 中（EntryList 中都是存放着被阻塞的线程，它们等待下次获取对象的 mutex）。

**总结**：同步锁在这种实现方式中，因为 monitor 是依赖于底层的操作系统实现，这样就存在用户态与内核态之间的切换（当线程真正执行业务代码的时候，是处于用户态的状态下，当没有获取到对象的锁而处于阻塞或者等待状态，因为 monitor 是由底层操作系统的 matex Lock 实现，所以就进入了内核态，如果该线程尝试获取对象的锁并且成功获取到的话就又转换为了用户态），所以会增加性能开销。通过对象互斥锁的概念来保证共享数据操作的完整性，每个对象都对应于一个可称为【互斥锁】的标记，这个标记用于保证在任何时刻，只能有一个线程访问该对象。

注：JVM 优化：当一个线程持有对象的锁并且正在执行相应的代码的时候，如果该线程发现该方法很快就执行完成，就不会让另一个等待线程进入内核态，而是让该线程进行自旋（空转等待正在执行的线程释放 monitor 对象）， 自旋占用 CPU 资源。因为该等待线程没有阻塞所有一直处于用户态，省去了用户态和内核态之间切换的时间。如果执行线程执行方法过长，等待线程自旋一段时间还是会转入内核态。

那些处于 EntryList 与 waitSet 中的线程均处于阻塞状态，阻塞操作是有操作系统来完成的，在 Linux 中是通过 `pthread_mutex_lock` 函数实现的。线程被阻塞之后就会进入到内核调度状态，这会导致系统在用户态和内核态之间来回切换，严重影响锁的性能。

解决上述问题的方法便是**自旋**（Spin）。其原理是：当发生对 monitor 的争用的时候，若锁的拥有者能够在很短的时间内释放掉锁，则那些正在争用的线程就可以稍微等待（即所谓的自旋），在拥有者线程释放锁之后，争用线程可能会立即获取到锁，从而避免了系统阻塞。如果拥有者运行的时间超过了临界值之后，争用线程自旋一段时间后依然无法获取到锁，这是争用线程就会停止自旋而进入阻塞状态，所有总体思想是：先自旋，不成功再进行阻塞，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有极大的性能提升。显然，自旋在多处理器（多核心）上才有意义。



### 互斥锁属性详解与 Monitor 对象特性解说

互斥锁的属性（类型）：从操作系统级别看

- `PTHREAD_MUTEX_TIMED_NP`；这是缺省值（默认值），也就是普通锁，当一个线程加锁之后，其余请求该锁的线程会形成一个等待队列，并且在解锁之后按照优先级获取到锁。这种策略可以确保资源分配的公平性。
- `PTHREAD_MUTEX_RECURSIVE_NP`：嵌套锁（可重入锁），允许一个线程对同一个锁成功获取多次，并通过 unlock 解锁（锁多少次就要调用多少次 unlock 来解锁）。如果是不同线程请求，则在加锁线程解锁时候重新进行竞争。
- `PTHREAD_MUTEX_ERRORCHECK_NP`：检错锁，如果一个线程请求同一个锁，则返回 EDEADLK，否则与 `PTHREAD_MUTEX_TIMED_NP` 类型动作相同，这样就保证了当不允许多次加锁时候不会出现最简单情况下的死锁。
- `PTHREAD_MUTEX_ADAPTIVE_NP`：适应锁，是动作最简单的锁，仅仅等待解锁后所有线程公平竞争。

synchronized 是语言层面提供的一个关键字，从语言层面来解决并发问题。语言本身加上关键字之后，通过编译器编译之后遇到这个关键字就是生成对应的字节码指令（monitorenter、monitorexit、ACC_SYNCHROIZED 等），程序整整执行的时候是执行一条条的字节码，同时字节码最后映射落实到了操作系统层面的函数调用，例如上面阻塞操作是有操作系统来完成的，在 Linux 中是通过 pthread_mutex_lock 函数实现的。通过底层操作系统层面的函数调用来实现应用层面上的并发访问等功能。



### 通过 openjdk 源码分析 ObjectMonitor 底层实现

官网：openjdk.java.net，在左边栏选择 Mercurial （这是 openjdk 网站的版本管理工具），单击之后就可看到其所管理的所以项目代码，这里选择 jdk8u，选择其中之一然后选择 hotspot，然后选择左边的 browse 可以查看项目的整体架构。src/share/vm/runtime/objectMonitor.cpp（具体实现）和 objectMonitor.hpp（头文件）

[点击直达 	](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/d975dfffada6/src/share/vm/runtime)

**首先 waitset 和 EntryList 关系**

在 hpp 头文件中：主要是变量和函数声明

```cpp

// ObjectWaiter serves as a "proxy" or surrogate thread.
// TODO-FIXME: Eliminate ObjectWaiter and use the thread-specific
// ParkEvent instead.  Beware, however, that the JVMTI code
// knows about ObjectWaiters, so we'll have to reconcile that code.
// See next_waiter(), first_waiter(), etc.

// ObjectWaiter 是对阻塞在对象锁上的线程的封装，因为下面有 Thread* _thread；和ObjectWaiter next/pre 表示前后等待的线程，所以整个应该类似于一种链表的结构
class ObjectWaiter : public StackObj {
 public:
  enum TStates { TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ } ;
  enum Sorted  { PREPEND, APPEND, SORTED } ;
  ObjectWaiter * volatile _next; // 采取的是一种链表的方式 下一个节点
  ObjectWaiter * volatile _prev; // 上一个节点
  Thread*       _thread;  // 指向当前线程的指针
  jlong         _notifier_tid;
  ParkEvent *   _event;
  volatile int  _notified ;
  volatile TStates TState ;
  Sorted        _Sorted ;           // List placement disposition
  bool          _active ;           // Contention monitoring is enabled
 public:
  ObjectWaiter(Thread* thread);

  void wait_reenter_begin(ObjectMonitor *mon);
  void wait_reenter_end(ObjectMonitor *mon);
};
```

![image-20210318204556489](部分一：线程.resource/image-20210318204556489.png)

同样上面的 Monitor 对象对应于底层 C++ 代码：ObjectMonitor

里面就有 waitset 和 EntryList 成员变量。

```java

// WARNING:
//   This is a very sensitive and fragile class. DO NOT make any
// change unless you are fully aware of the underlying semantics.

//   This class can not inherit from any other class, because I have
// to let the displaced header be the very first word. Otherwise I
// have to let markOop include this file, which would export the
// monitor data structure to everywhere.
//
// The ObjectMonitor class is used to implement JavaMonitors which have
// transformed from the lightweight structure of the thread stack to a
// heavy weight lock due to contention

// It is also used as RawMonitor by the JVMTI


class ObjectMonitor {
 public:
    // 关于系统状态或者异常的枚举值，Java 中异常都是由底层 C++ 对象抛出异常然后转换为 Java 的
  enum {
    OM_OK,                    // no error
    OM_SYSTEM_ERROR,          // operating system error
    OM_ILLEGAL_MONITOR_STATE, // IllegalMonitorStateException
    OM_INTERRUPTED,           // Thread.interrupt()
    OM_TIMED_OUT              // Object.wait() timed out
  };
    
 // 成员变量
  // initialize the monitor, exception the semaphore, all other fields
  // are simple integers or pointers
    // 初始化  monitor，除了 semaphore（信号量），其它所有变量都是整数或者指针。
  ObjectMonitor() {
    _header       = NULL;
    _count        = 0;
    _waiters      = 0,
      // 对应上面嵌套锁中的数量，进入一次加 1
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
      // -WaitSet 定义为  ObjectWaiter * volatile _WaitSet 
    _WaitSet      = NULL;
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
      // _EntryList 定义也一样
    _EntryList    = NULL ;
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
    _previous_owner_tid = 0;
  }

  ~ObjectMonitor() {
   // TODO: Add asserts ...
   // _cxq == 0 _succ == NULL _owner == NULL _waiters == 0
   // _count == 0 _EntryList  == NULL etc
  }

private:
  void Recycle () {
    // TODO: add stronger asserts ...
    // _cxq == 0 _succ == NULL _owner == NULL _waiters == 0
    // _count == 0 EntryList  == NULL
    // _recursions == 0 _WaitSet == NULL
    // TODO: assert (is_busy()|_recursions) == 0
    _succ          = NULL ;
    _EntryList     = NULL ;
    _cxq           = NULL ;
    _WaitSet       = NULL ;
    _recursions    = 0 ;
    _SpinFreq      = 0 ;
    _SpinClock     = 0 ;
    OwnerIsThread  = 0 ;
  }

public:

  void*     object() const;
  void*     object_addr();
  void      set_object(void* obj);

  bool      check(TRAPS);       // true if the thread owns the monitor.
  void      check_slow(TRAPS);
  void      clear();
  static void sanity_checks();  // public for -XX:+ExecuteInternalVMTests
                                // in PRODUCT for -XX:SyncKnobs=Verbose=1
#ifndef PRODUCT
  void      verify();
  void      print();
#endif

  bool      try_enter (TRAPS) ;
  void      enter(TRAPS);
  void      exit(bool not_suspended, TRAPS);
  void      wait(jlong millis, bool interruptable, TRAPS);
  void      notify(TRAPS);
  void      notifyAll(TRAPS);

// Use the following at your own risk
  intptr_t  complete_exit(TRAPS);
  void      reenter(intptr_t recursions, TRAPS);

 private:
  void      AddWaiter (ObjectWaiter * waiter) ;
  static    void DeferredInitialize();

  ObjectWaiter * DequeueWaiter () ;
  void      DequeueSpecificWaiter (ObjectWaiter * waiter) ;
  void      EnterI (TRAPS) ;
  void      ReenterI (Thread * Self, ObjectWaiter * SelfNode) ;
  void      UnlinkAfterAcquire (Thread * Self, ObjectWaiter * SelfNode) ;
  int       TryLock (Thread * Self) ;
  int       NotRunnable (Thread * Self, Thread * Owner) ;
  int       TrySpin_Fixed (Thread * Self) ;
  int       TrySpin_VaryFrequency (Thread * Self) ;
  int       TrySpin_VaryDuration  (Thread * Self) ;
  void      ctAsserts () ;
  void      ExitEpilog (Thread * Self, ObjectWaiter * Wakee) ;
  bool      ExitSuspendEquivalent (JavaThread * Self) ;
  void      post_monitor_wait_event(EventJavaMonitorWait * event,
                                                   jlong notifier_tid,
                                                   jlong timeout,
                                                   bool timedout);

 private:
  friend class ObjectSynchronizer;
  friend class ObjectWaiter;
  friend class VMStructs; 
```

画图演示：

![image-20200218213325708](%E9%83%A8%E5%88%86%E4%B8%80%EF%BC%9A%E7%BA%BF%E7%A8%8B.resource/image-20200218213325708.png)



### 通过 openjdk 源码分析 wait 与 notify 方法的本地实现

objectMonitor.cpp 1459行

java 中 Object 类中的 wait 方法就是下面 ObjectMonitor 类中 wait方法的一个实现。

```cpp
// -----------------------------------------------------------------------------
// Wait/Notify/NotifyAll
//
// Note: a subset of changes to ObjectMonitor::wait()
// will need to be replicated in complete_exit above
// 对应 Java 中的  wait(long time) 方法
void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {
   Thread * const Self = THREAD ;
   assert(Self->is_Java_thread(), "Must be Java thread!");
   JavaThread *jt = (JavaThread *)THREAD;

   DeferredInitialize () ;

   // Throw IMSX or IEX.
   CHECK_OWNER();

   EventJavaMonitorWait event;

   // check for a pending interrupt
   if (interruptible && Thread::is_ interrupted(Self, true) && !HAS_PENDING_EXCEPTION) {
     // post monitor waited event.  Note that this is past-tense, we are done waiting.
     if (JvmtiExport::should_post_monitor_waited()) {
        // Note: 'false' parameter is passed here because the
        // wait was not timed out due to thread interrupt.
        JvmtiExport::post_monitor_waited(jt, this, false);

        // In this short circuit of the monitor wait protocol, the
        // current thread never drops ownership of the monitor and
        // never gets added to the wait queue so the current thread
        // cannot be made the successor. This means that the
        // JVMTI_EVENT_MONITOR_WAITED event handler cannot accidentally
        // consume an unpark() meant for the ParkEvent associated with
        // this ObjectMonitor.
     }
     if (event.should_commit()) {
       post_monitor_wait_event(&event, 0, millis, false);
     }
     TEVENT (Wait - Throw IEX) ;
     THROW(vmSymbols::java_lang_InterruptedException());
     return ;
   }

   TEVENT (Wait) ;

   assert (Self->_Stalled == 0, "invariant") ;
   Self->_Stalled = intptr_t(this) ;
   jt->set_current_waiting_monitor(this);

    // 作用：将当前正在执行的线程封装成 ObjectWaiter 类型的结点，然后将其放入队列，这里的 self 根据上面 Line7可以看出是一个线程对象 
   // create a node to be put into the queue
   // Critically, after we reset() the event but prior to park(), we must check
   // for a pending interrupt.
   ObjectWaiter node(Self);
    // 将节点的状态设置为等待状态
   node.TState = ObjectWaiter::TS_WAIT ;
   Self->_ParkEvent->reset() ;
   OrderAccess::fence();          // ST into Event; membar ; LD interrupted-flag
// 这个注释重要
   // Enter the waiting queue, which is a circular doubly linked list in this case
   // but it could be a priority queue or any data structure.
   // _WaitSetLock protects the wait queue.  Normally the wait queue is accessed only
   // by the the owner of the monitor *except* in the case where park()
   // returns because of a timeout of interrupt.  Contention is exceptionally rare
   // so we use a simple spin-lock instead of a heavier-weight blocking lock.

   Thread::SpinAcquire (&_WaitSetLock, "WaitSet - add") ;
    // 调用 AddWaiter 将封装后的该结点放入 waitSet 中
   AddWaiter (&node) ；
       // AddWaiter 具体实现为 L2328：从方法中可以看出就是修改一系列的双向链表的指针
       /**
        inline void ObjectMonitor::AddWaiter(ObjectWaiter* node) {
          assert(node != NULL, "should not dequeue NULL node");
          assert(node->_prev == NULL, "node already in list");
          assert(node->_next == NULL, "node already in list");
          // put node at end of queue (circular doubly linked list)
          if (_WaitSet == NULL) {
            _WaitSet = node;
            node->_prev = node;
            node->_next = node;
          } else {
            ObjectWaiter* head = _WaitSet ;
            ObjectWaiter* tail = head->_prev;
            assert(tail->_next == head, "invariant check");
            tail->_next = node;
            head->_prev = node;
            node->_next = head;
            node->_prev = tail;
          }
        }
*/
       
       
   Thread::SpinRelease (&_WaitSetLock) ;

   if ((SyncFlags & 4) == 0) {
      _Responsible = NULL ;
   }
   intptr_t save = _recursions; // record the old recursion count
   _waiters++;                  // increment the number of waiters
   _recursions = 0;             // set the recursion level to be 1
    // 退出 monitor，即释放了锁
   exit (true, Self) ;                    // exit the monitor
    // exit 具体实现方法见：L956
    /**
    void ATTR ObjectMonitor::exit(bool not_suspended, TRAPS) {
   Thread * Self = THREAD ;
   if (THREAD != _owner) {
     if (THREAD->is_lock_owned((address) _owner)) {
       // Transmute _owner from a BasicLock pointer to a Thread address.
       // We don't need to hold _mutex for this transition.
       // Non-null to Non-null is safe as long as all readers can
       // tolerate either flavor.
       assert (_recursions == 0, "invariant") ;
       _owner = THREAD ;
       _recursions = 0 ;
       OwnerIsThread = 1 ;
     } else {
       // NOTE: we need to handle unbalanced monitor enter/exit
       // in native code by throwing an exception.
       // TODO: Throw an IllegalMonitorStateException ?
       TEVENT (Exit - Throw IMSX) ;
       assert(false, "Non-balanced monitor enter/exit!");
       if (false) {
          THROW(vmSymbols::java_lang_IllegalMonitorStateException());
       }
       return;
     }
   }
   */
   guarantee (_owner != Self, "invariant") ;

   // The thread is on the WaitSet list - now park() it.
   // On MP systems it's conceivable that a brief spin before we park
   // could be profitable.
   //
   // TODO-FIXME: change the following logic to a loop of the form
   //   while (!timeout && !interrupted && _notified == 0) park()

   int ret = OS_OK ;
   int WasNotified = 0 ;
   { // State transition wrappers
     OSThread* osthread = Self->osthread();
     OSThreadWaitState osts(osthread, true);
     {
       ThreadBlockInVM tbivm(jt);
       // Thread is in thread_blocked state and oop access is unsafe.
       jt->set_suspend_equivalent();

       if (interruptible && (Thread::is_interrupted(THREAD, false) || HAS_PENDING_EXCEPTION)) {
           // Intentionally empty
       } else
       if (node._notified == 0) {
         if (millis <= 0) {
            Self->_ParkEvent->park () ;
         } else {
            ret = Self->_ParkEvent->park (millis) ;
         }
       }

       // were we externally suspended while we were waiting?
       if (ExitSuspendEquivalent (jt)) {
          // TODO-FIXME: add -- if succ == Self then succ = null.
          jt->java_suspend_self();
       }

     } // Exit thread safepoint: transition _thread_blocked -> _thread_in_vm
```

notify 从 waitset 中确定好唤醒哪一个之后，最终只会出来一个线程，不是都出来然后再选择。

**分析 notify 方法**

ObjectMonitor.cpp 中 L1698

```cpp
void ObjectMonitor::notify(TRAPS) {
  CHECK_OWNER();
    // 如果当前 waitSet 为 null，表示当前没有任何线程去调用了该对象的 wait 方法，直接返回了。
  if (_WaitSet == NULL) {
     TEVENT (Empty-Notify) ;
     return ;
  }
DTRACE_MONITOR_PROBE(notify, this, object(), THREAD);

  int Policy = Knob_MoveNotifyee ;

  Thread::SpinAcquire (&_WaitSetLock, "WaitSet - notify") ;
    // 如果 waitSet 不为空，通过 DequeueWaiter() 方法来唤醒线程
  ObjectWaiter * iterator = DequeueWaiter() ;
    // DequeueWaiter 方法的具体实现：L2348，它就是获取到 waitSet 集合中第一个对象
    /**
    inline ObjectWaiter* ObjectMonitor::DequeueWaiter() {
      // dequeue the very first waiter
      ObjectWaiter* waiter = _WaitSet;
      if (waiter) {
        DequeueSpecificWaiter(waiter);
      }
      return waiter;
    }
    */
    // 根据不同的调度策略，找到对应的要唤醒的线程对象，只会唤醒一个，不是将所有等待集合都唤醒然后竞争。具体唤醒是使用 L1793 的 unpark()；
  if (iterator != NULL) {
     TEVENT (Notify1 - Transfer) ;
     guarantee (iterator->TState == ObjectWaiter::TS_WAIT, "invariant") ;
     guarantee (iterator->_notified == 0, "invariant") ;
     if (Policy != 4) {
        iterator->TState = ObjectWaiter::TS_ENTER ;
     }
     iterator->_notified = 1 ;
     Thread * Self = THREAD;
     iterator->_notifier_tid = Self->osthread()->thread_id();

     ObjectWaiter * List = _EntryList ;
     if (List != NULL) {
        assert (List->_prev == NULL, "invariant") ;
        assert (List->TState == ObjectWaiter::TS_ENTER, "invariant") ;
        assert (List != iterator, "invariant") ;
     }

     if (Policy == 0) {       // prepend to EntryList
         if (List == NULL) {
             iterator->_next = iterator->_prev = NULL ;
             _EntryList = iterator ;
         } else {
             List->_prev = iterator ;
             iterator->_next = List ;
             iterator->_prev = NULL ;
             _EntryList = iterator ;
        }
     } else
     if (Policy == 1) {      // append to EntryList
         if (List == NULL) {
             iterator->_next = iterator->_prev = NULL ;
             _EntryList = iterator ;
         } else {
            // CONSIDER:  finding the tail currently requires a linear-time walk of
            // the EntryList.  We can make tail access constant-time by converting to
            // a CDLL instead of using our current DLL.
            ObjectWaiter * Tail ;
            for (Tail = List ; Tail->_next != NULL ; Tail = Tail->_next) ;
            assert (Tail != NULL && Tail->_next == NULL, "invariant") ;
            Tail->_next = iterator ;
            iterator->_prev = Tail ;
            iterator->_next = NULL ;
        }
     } else
     if (Policy == 2) {      // prepend to cxq
         // prepend to cxq
         if (List == NULL) {
             iterator->_next = iterator->_prev = NULL ;
             _EntryList = iterator ;
         } else {
            iterator->TState = ObjectWaiter::TS_CXQ ;
            for (;;) {
                ObjectWaiter * Front = _cxq ;
                iterator->_next = Front ;
                if (Atomic::cmpxchg_ptr (iterator, &_cxq, Front) == Front) {
                    break ;
                }
            }
         }
     } else
     if (Policy == 3) {      // append to cxq
        iterator->TState = ObjectWaiter::TS_CXQ ;
        for (;;) {
            ObjectWaiter * Tail ;
            Tail = _cxq ;
            if (Tail == NULL) {
                iterator->_next = NULL ;
                if (Atomic::cmpxchg_ptr (iterator, &_cxq, NULL) == NULL) {
                   break ;
                }
            } else {
                while (Tail->_next != NULL) Tail = Tail->_next ;
                Tail->_next = iterator ;
                iterator->_prev = Tail ;
                iterator->_next = NULL ;
                break ;
            }
        }
     } else {
        ParkEvent * ev = iterator->_event ;
        iterator->TState = ObjectWaiter::TS_RUN ;
        OrderAccess::fence() ;
        ev->unpark() ;
     }

     if (Policy < 4) {
       iterator->wait_reenter_begin(this);
     }

     // _WaitSetLock protects the wait queue, not the EntryList.  We could
     // move the add-to-EntryList operation, above, outside the critical section
     // protected by _WaitSetLock.  In practice that's not useful.  With the
     // exception of  wait() timeouts and interrupts the monitor owner
     // is the only thread that grabs _WaitSetLock.  There's almost no contention
     // on _WaitSetLock so it's not profitable to reduce the length of the
     // critical section.
  }

  Thread::SpinRelease (&_WaitSetLock) ;

  if (iterator != NULL && ObjectMonitor::_sync_Notifications != NULL) {
     ObjectMonitor::_sync_Notifications->inc() ;
  }
}
    
    
```



### 锁升级与偏向锁深入理解

**分析 synchronized 关键字底层**

在 JDK1.5 之前，我们若想实现线程同步，只能通过 synchronized 关键字这一种方式来实现；在底层 Java 也是通过 synchronized 关键字来做到数据的原子性维护（原子性维护是指该数据在同一时刻只能由一个线程来修改）的。synchronized 关键字是 JVM 实现的一种内置锁，从底层调度来说，这种锁的获取和释放都是有 JVM 帮助我们隐式实现的。

从 JDK1.5之后，并发包引入了 Lock 锁（位于 java.util.concurrent.locks 包下），Lock 这种同步锁是基于 Java 来实现的，因此锁的获取与释放都是通过 Java 代码（程序开发者）来实现与控制的。然而 synchronized 是基于底层操作系统的 Mutex Lock（互斥锁）来实现的，每次对锁的获取与释放动作都会带来用户态和内核态之间的切换，这种切换会极大的增加系统的负担。在并发量较高时，也就是说锁的竞争比较激烈时候，synchronized 锁在性能的表现就非常差。

synchronized 在 JDK1.6 之前都是重量级锁（需要用户态和内核态之间来回切换），从 JDK1.6 开始 synchronized 锁的实现上发生了极大的变化， JVM 引入了响应的优化手段来提升 synchronized  锁的性能，这种提升涉及到偏向锁，轻量级锁、重量级锁等，从而减少锁的竞争所带来的用户态与内核态之前的切换。这种锁的优化实际上是通过 Java 对象头中的一些标志位来实现的。对于锁的访问和改变，实际上都与 Java 对象息息相关。==> synchronized 的优化方向就是减少用户态和内核态之间切换

从 JDK1.6 开始，对象实例在堆当中会被划分为三个组成部分：对象头、实例数据（对象本身持有的数据）和对齐填充（确保数据长度的一致性）。

对象头主要由三块内容组成：

- mark word：标记词
- 指向类的指针：（因为对象一定是归属于某一个类的，该标志位指向该对象实例是从哪个类创建出来的）
- 数组长度

其中 MarkWord （它记录了对象、锁以及垃圾回收相关的信息，在 64 位的 JVM 中，其长度也是 64 bit）的位信息包括了以下组成部分：

- 无锁标记：当前对象没有被上锁
- 偏向锁标记
- 轻量级锁标记
- 重量级锁标记
- 垃圾回收标记

对于 synchronized 锁来说，锁的升级主要都是通过 Mark word 中的锁标志位与是否为偏向锁标志位来达成的； synchronized 关键字所对应的锁都是先从偏向锁开始，随着锁的竞争的不断升级，逐步演化为轻量级锁，最后则变成了重量级锁。所以对了锁的演化来说，一般会经历如下阶段（可以在 JVM 启动参数中显式指定从而跳过某些阶段）：无锁——》偏向锁-》轻量级锁-》重量级锁。其中上面的自旋（锁）属于轻量级锁的一种实现方式。

**偏向锁**：是针对一个线程来说的（只有一个线程的情况下），如果去执行 synchronized 修饰的代码块或者方法，首先（也肯定能，因为只有一个线程）要获取到对象的锁，这样就实际到用户态与内核态的切换。执行完成之后，如果其再次执行同样的代码块或者方法，原则上还要获取该对象的锁。偏向锁改进：当一个线程去访问一个 synchronized 方法（代码块）的时候，第一次访问的时候，作为锁的对象，它就会将偏向锁标记标记上（表明该对象有一把偏向锁）还有一个字段指向拥有这把锁的线程的 ID。当又一个线程来访问该 synchronized 方法（代码块）的时候，想获取该对象的锁的时候，就会去该同步对象的 MarkWord 中判断一下，发现该对象已经有了偏向锁，同时指向的线程 ID 和该线程的 ID 一致。说明两次访问中间没有其他线程访问该对象，就不再获取该对象的锁（monitor，因为获取对象的 monitor 肯定要进入内核态），直接进入该方法（代码块）中，这样线程就需要再次因为获取锁而在用户态和内核态之间切换，只在用户态运行。

**偏向锁总结**：它的作用就是优化同一个线程多次获取一个锁的情况；如果一个synchronized 方法（代码块）被一个线程访问，那么这个方法所在的对象就会在其 Mark Word 中将偏向锁进行标记，同时还会有一个字段来存储该线程的 ID，当这个线程再次访问同一个 synchronized 方法时候，它会检测这个对象的 Mark Word 的偏向锁标记以及是否指向了其线程 ID，如果是的话，那么该线程就无需再次进入管程（Monitor）了，而是直接进入到该方法体中。

如果是另外的一个线程访问了这个 synchronized 方法（代码块），这个偏向锁就会被取消掉，因为偏向指的是偏向于上一个访问该同步方法（代码块）的线程。这次是另一个线程，因此偏向就没有意义了。

当一个线程正在执行该 synchronized 方法（代码块） 还没有执行完的时候，其他线程来争抢该锁的时候（当然这时候抢不到）偏向锁会被取消掉，同时锁会升级为轻量级锁。如果已经执行执行完则同样取消偏向锁。因为锁的取消会带来更大的开销，所以大并发的时候可以配置 JVM 启动参数取消偏向锁的设定。



### 轻量级锁和重量级锁的变化深入理解

**轻量级锁**：如果第一个线程已经获取到了当前对象的锁，这时候第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁，而第二个线程在争抢时候，会发现该对象头中的 Mark Word 已经是偏向锁，但是里面存储的线程 ID 并不是自己（是第一个线程），那么他就会进行 CAS（Compare and Swap），从而获取到锁。这里面存在两种情况。

- 获取锁成功：那么他就会直接将 Mark Word 中的线程 ID 由第一个线程变成自己（偏向锁的标记位不变），这样该对象依然会保持偏向锁的状态。
- 获取锁失败：则表示这时候可能会有多个线程同时在尝试争抢该对象的锁，~~这个线程获取锁失败~~，那么这时偏向锁就会进行升级，升级为轻量级锁。

轻量级锁适合两个线程轮流访问的情景，不适合很多线程同时竞争的情况。

**自旋锁**

如果自旋失败（依然无法获取到锁），那么锁就会升级为重量级锁，在这种情况下，无法获取到锁的线程就会进入 Monitor （即内核态）。

自旋最大的一个特点就是避免了线程从用户态进入内核态。

**重量级锁**

线程最终从用户态进入内核态。



### 锁粗化与锁消除技术实例演示与分析

编译器对于锁的优化措施：运行期优化，编译期形成的字节码还是没有改变。

- 优化一：锁消除

    JIT（Just In Time） 编译器（即时编译器）可以在动态编译同步代码时候，使用一种叫做逃逸分析的技术，通过该项技术判别程序中所使用的锁对象是否只被一个线程所使用，而没有散步到其他线程中；如果情况确实如此，那么 JIT 编译器在编译这个同步代码时就不会生成 synchronized 关键字所标识的锁的申请与释放**机器码**，从而消除了锁的使用流程。（反编译字节码含有 monitorenter 和 monitorexit，但是执行时候相当于没有）

    **示例程序**

    ```java
    package com.gjxaiou.synchronize;
    
    /**
     * @Author GJXAIOU
     * @Date 2020/2/20 21:30
     */
    public class MyTest4 {
        // 在 MyTest4 只有一个实例的情况下，这个实例的成员变量会被所有线程所共享
        // private Object object = new Object();
    
        public void method() {
            // 局部变量，每个线程都会有该 object 对象的引用，所以加不加 synchronized 没什么意义了
            Object object = new Object();
            synchronized (object) {
                System.out.println("hello world");
            }
        }
    }
    ```

    如上面这个程序中，本质上不需要上锁，所以执行的时候编译器进行了优化。

- 优化二：锁粗化

    JIT 编译器在执行动态编译的时候，如发现前后相邻的 synchronized 块使用的是同一个对象，那么就会把这几个 synchronized 块给合并为一个较大的同步块，这样做的好处在于线程在执行这些代码时候，就无须频繁的申请和释放锁了，从而达到申请与释放锁一次就可以执行完全部的同步代码块，从而提升了性能。

```java
package com.gjxaiou.synchronize;

/**
 * @Author GJXAIOU
 * @Date 2020/2/20 21:44
 */
public class MyTest5 {
    // 如果声明为成员变量,就被所有访问同一个 MyTest5 实例的线程所共享，所以同一时刻只有一个对象可以获取到 object 对象的锁。
    // 这种代码，各个 synchronized 锁的同一个对象，同时中间没有任何其它代码。每一个 synchronized 代码块线程都要争锁，浪费时间。
    Object object = new Object();

    public void method() {
        // 因为编译器使用 锁消除，相当于下面的 synchronized 关键字都不存在了，也就不需要锁获取与消除了，就是直接执行。（这里针对是锁消除的示例）
        // Object object = new Object();
        synchronized (object) {
            System.out.println("hello");
        }
        synchronized (object) {
            System.out.println("world");
        }
        synchronized (object) {
            System.out.println("person");
        }
    }
}
```



### 小结：锁与底层内容阶段性回顾与总结

如果一个线程获取 Monitor 之后，进入 synchronized 方法，同时接下来调用了 wait 方法，则该线程进入 等待状态（waitSet），并且会释放掉该对象的锁。这样其它线程就可以争抢获取，获取到就可以进入该方法，。。。因此可能会出现多个线程同时等待的情况。

### openjdk 源码剖析与锁升级技术回顾



### 死锁检测和相关工具详解

**死锁**：线程 1 等待线程 2 互斥持有的资源，而线程 2 也在等待线程 1 互斥持有的资源，两个线程都无法继续执行。

**活锁**：线程持续重试一个总是失败的操作，导致无法继续进行（针对一个线程）。 就是线程需要执行某个操作然后才能继续执行，但是该操作一直执行失败，所以一直无法进行。

**饿死**：线程一直被调度器延迟访问其赖以执行的资源，也许是调度器先于低优先级的线程而执行高优先级的线程，同时总是会有一个高优先级的线程可以执行，饿死也叫做无限延迟。    当然这是理论情况，虽然有些操作系统是按照优先级大小执行线程，但是其实一个线程延迟时间越长，系统就会越提高该线程的优先级，不会优先级一直不动。        

​                                              

**死锁示例**

```java
package com.gjxaiou.lock;

/**
 * @Author GJXAIOU
 * @Date 2020/2/21 20:37
 */
public class MyTest1 {
    // 两个资源使用两个对象的锁来代替
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void myMethod1() {
        synchronized (lock1) {
            synchronized (lock2) {
                System.out.println("myMethod1 invoked");
            }
        }
    }

    public void myMethod2() {
        synchronized (lock2) {
            synchronized (lock1) {
                System.out.println("myMethod2 invoked");
            }
        }
    }
    
    // 创建两个线程

    public static void main(String[] args) {
        final MyTest1 myTest1 = new MyTest1();

        Runnable runnable1 = new Runnable() {
            public void run() {
                while (true) {
                    myTest1.myMethod1();
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };

        Thread thread1 = new Thread(runnable1, "myThread1");
        Runnable runnable2 = new Runnable() {
            public void run() {
                while (true) {
                    myTest1.myMethod2();
                    try {
                        Thread.sleep(250);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        Thread thread2 = new Thread(runnable2, "myThread2");

        thread1.start();
        thread2.start();
    }
}

```

对于死锁的检测，我们除了从打印结果不在滚动可以看出之外，可以通过命令行或者 JVisualVM 来查看。

- 命令行查看

    运行程序之后，通过命令： `jps -l `查看当前 Java 进程以及进程 ID

    ```java
    C:\Users\gjx16>jps -l
    2592 com.gjxaiou.lock.MyTest1
    10788 org.jetbrains.jps.cmdline.Launcher
    5012 org.jetbrains.jps.cmdline.Launcher
    9620 org.jetbrains.idea.maven.server.RemoteMavenServer36
    5708
    5740 org/netbeans/Main
    6316 sun.tools.jps.Jps
    ```

    从中可以看出当前程序的进程 ID 为 2592。

    然后通过命令：`jstack 2592` 查看具体信息

    ```java
    C:\Users\gjx16>jstack 2592
    2020-02-21 20:56:57
    Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.221-b11 mixed mode):
    
    "DestroyJavaVM" #14 prio=5 os_prio=0 tid=0x0000000003773800 nid=0x2f0c waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
    "myThread2" #13 prio=5 os_prio=0 tid=0x000000001ec6c800 nid=0xc30 waiting for monitor entry [0x000000002094f000]
       java.lang.Thread.State: BLOCKED (on object monitor)
            at com.gjxaiou.lock.MyTest1.myMethod2(MyTest1.java:22)
            - waiting to lock <0x000000076b98fda0> (a java.lang.Object)
            - locked <0x000000076b98fdb0> (a java.lang.Object)
            at com.gjxaiou.lock.MyTest1$2.run(MyTest1.java:47)
            at java.lang.Thread.run(Thread.java:748)
    
    "myThread1" #12 prio=5 os_prio=0 tid=0x000000001ec6b800 nid=0x1e6c waiting for monitor entry [0x000000002084e000]
       java.lang.Thread.State: BLOCKED (on object monitor)
            at com.gjxaiou.lock.MyTest1.myMethod1(MyTest1.java:14)
            - waiting to lock <0x000000076b98fdb0> (a java.lang.Object)
            - locked <0x000000076b98fda0> (a java.lang.Object)
            at com.gjxaiou.lock.MyTest1$1.run(MyTest1.java:33)
            at java.lang.Thread.run(Thread.java:748)
    
    "Service Thread" #11 daemon prio=9 os_prio=0 tid=0x000000001ec5a800 nid=0x7e0 runnable [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
    "C1 CompilerThread3" #10 daemon prio=9 os_prio=2 tid=0x000000001ebbd000 nid=0x4198 waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
    "C2 CompilerThread2" #9 daemon prio=9 os_prio=2 tid=0x000000001ebae000 nid=0x13c0 waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
    "C2 CompilerThread1" #8 daemon prio=9 os_prio=2 tid=0x000000001ebad000 nid=0x1788 waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
    "C2 CompilerThread0" #7 daemon prio=9 os_prio=2 tid=0x000000001eba8000 nid=0x528 waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
    "Monitor Ctrl-Break" #6 daemon prio=5 os_prio=0 tid=0x000000001eba3000 nid=0x1164 runnable [0x000000002014e000]
       java.lang.Thread.State: RUNNABLE
            at java.net.SocketInputStream.socketRead0(Native Method)
            at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
            at java.net.SocketInputStream.read(SocketInputStream.java:171)
            at java.net.SocketInputStream.read(SocketInputStream.java:141)
            at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)
            at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)
            at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)
            - locked <0x000000076b884838> (a java.io.InputStreamReader)
            at java.io.InputStreamReader.read(InputStreamReader.java:184)
            at java.io.BufferedReader.fill(BufferedReader.java:161)
            at java.io.BufferedReader.readLine(BufferedReader.java:324)
            - locked <0x000000076b884838> (a java.io.InputStreamReader)
            at java.io.BufferedReader.readLine(BufferedReader.java:389)
            at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:64)
    
    "Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x000000001eb15000 nid=0x2310 waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
    "Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x000000001eb72000 nid=0x15f8 runnable [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
    "Finalizer" #3 daemon prio=8 os_prio=1 tid=0x000000000386d000 nid=0x1bb8 in Object.wait() [0x000000001fe4e000]
       java.lang.Thread.State: WAITING (on object monitor)
            at java.lang.Object.wait(Native Method)
            - waiting on <0x000000076b708ed8> (a java.lang.ref.ReferenceQueue$Lock)
            at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)
            - locked <0x000000076b708ed8> (a java.lang.ref.ReferenceQueue$Lock)
            at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)
            at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)
    
    "Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x000000001d42d800 nid=0x9c0 in Object.wait() [0x000000001fd4f000]
       java.lang.Thread.State: WAITING (on object monitor)
            at java.lang.Object.wait(Native Method)
            - waiting on <0x000000076b706c00> (a java.lang.ref.Reference$Lock)
            at java.lang.Object.wait(Object.java:502)
            at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
            - locked <0x000000076b706c00> (a java.lang.ref.Reference$Lock)
            at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)
    
    "VM Thread" os_prio=2 tid=0x000000001d425800 nid=0x22fc runnable
    
    "GC task thread#0 (ParallelGC)" os_prio=0 tid=0x0000000003789000 nid=0xf70 runnable
    
    "GC task thread#1 (ParallelGC)" os_prio=0 tid=0x000000000378a800 nid=0x47c8 runnable
    
    "GC task thread#2 (ParallelGC)" os_prio=0 tid=0x000000000378c000 nid=0x38d8 runnable
    
    "GC task thread#3 (ParallelGC)" os_prio=0 tid=0x000000000378e000 nid=0x2930 runnable
    
    "GC task thread#4 (ParallelGC)" os_prio=0 tid=0x0000000003790000 nid=0x12d0 runnable
    
    "GC task thread#5 (ParallelGC)" os_prio=0 tid=0x0000000003792000 nid=0x3270 runnable
    
    "GC task thread#6 (ParallelGC)" os_prio=0 tid=0x0000000003795800 nid=0x998 runnable
    
    "GC task thread#7 (ParallelGC)" os_prio=0 tid=0x0000000003796800 nid=0xb28 runnable
    
    "GC task thread#8 (ParallelGC)" os_prio=0 tid=0x0000000003797800 nid=0x17d8 runnable
    
    "GC task thread#9 (ParallelGC)" os_prio=0 tid=0x0000000003799000 nid=0x3080 runnable
    
    "VM Periodic Task Thread" os_prio=2 tid=0x000000001eba8800 nid=0x433c waiting on condition
    
    JNI global references: 12
    
     //--------------主要看下面这里就可以看出，这里是总结------------------------
    
    Found one Java-level deadlock:
    =============================
    "myThread2":
      waiting to lock monitor 0x000000001d430c38 (object 0x000000076b98fda0, a java.lang.Object),
      which is held by "myThread1"
    "myThread1":
      waiting to lock monitor 0x000000001d433578 (object 0x000000076b98fdb0, a java.lang.Object),
      which is held by "myThread2"
    
    Java stack information for the threads listed above:
    ===================================================
    "myThread2":
            at com.gjxaiou.lock.MyTest1.myMethod2(MyTest1.java:22)
            - waiting to lock <0x000000076b98fda0> (a java.lang.Object)
            - locked <0x000000076b98fdb0> (a java.lang.Object)
            at com.gjxaiou.lock.MyTest1$2.run(MyTest1.java:47)
            at java.lang.Thread.run(Thread.java:748)
    "myThread1":
            at com.gjxaiou.lock.MyTest1.myMethod1(MyTest1.java:14)
            - waiting to lock <0x000000076b98fdb0> (a java.lang.Object)
            - locked <0x000000076b98fda0> (a java.lang.Object)
            at com.gjxaiou.lock.MyTest1$1.run(MyTest1.java:33)
            at java.lang.Thread.run(Thread.java:748)
    
    Found 1 deadlock.
    
    ```

- JVisualVM ：可以使用 JVisualVM 更加直观的显示

    运行程序之后，打开 JVisualVM 然后选择对应的线程，可以看出已经提示产生了死锁，同时根据提示点击右边的 Dump 具体信息，可以查看与上面相同的具体死锁信息

    ![2](%E9%83%A8%E5%88%86%E4%B8%80%EF%BC%9A%E7%BA%BF%E7%A8%8B.resource/2.png)

![3](%E9%83%A8%E5%88%86%E4%B8%80%EF%BC%9A%E7%BA%BF%E7%A8%8B.resource/3.png)







### Lock 锁机制深入详解

jdk 1.5 之前对于对象同步只能使用 synchronized 关键字，之后引入了 锁，可以实现对象同步。

java.util.concurrency.locks.Lock.java 的 JavaDoc

> Lock 实现提供了比使用 synchronized 方法和语句更广泛的锁定操作。它们允许更灵活的结构，可能具有完全不同的属性，并且可能支持多个关联的 Condition 对象（也在 locks 中，后面讲解）。
>
> **锁是一种工具，用于控制多个线程对共享资源的访问**。通常情况下，锁提供对共享资源的独占访问：一次只有一个线程可以获取锁，**对共享资源的所有访问都要求首先获取锁**。但是，有些锁可能允许并发访问共享资源，例如 ReadWriteLock 的读锁。
>
> > 注：通常情况下， Lock 是一种排他性的锁，即同一时刻只能有一个线程拥有这把锁，然后访问该锁控制的资源，如果有其它线程想访问该共享资源则只能等待持有该锁的线程执行完或者抛出异常从而释放该锁，然后去争抢这把锁。 当时这种方式对于共享资源划分力度不够，例如通常资源读的次数大于写次数，当多个线程对同一个资源都是读取，本质上都是不需要上锁的，所以通过 ReadWriteLock，读和写线程分别获取读锁和写锁。具体后续再分析啦。
>
> 使用 synchronized 方法或语句可以访问与每个对象关联的隐式监视锁，但会强制以块结构的方式获取和释放所有锁：当获取多个锁时，它们必须按相反的顺序释放，所有锁都必须在获得它们的相同词法（作用域）范围内释放。
>
> 虽然 synchronized 方法和语句的作用域机制使使用监视器锁编程更加容易，并有助于避免许多涉及锁的常见编程错误，但有时需要以更灵活的方式使用锁。例如，一些遍历并发访问数据结构的算法需要使用“head - over - head”或“链锁定”：先获取节点 A 的锁，然后获取节点 B，然后释放 A 和获取 C，然后释放 B 和获取D，依此类推。 **Lock 接口的实现允许在不同的作用域中获取和释放一个锁，并允许以任何顺序获取和释放多个锁**，从而允许使用此类技术。
>
> 随着这种灵活性的增加，也带来了额外的责任。缺少块结构锁定将删除 synchronized 方法和语句所发生的锁的自动释放。在大多数情况下，应使用以下用法：
>
> ```java
> Lock l = ...;
> l.lock();
> // 即在 try 中访问锁保护的资源，并且在 finally 中释放锁
> try {
>    // access the resource protected by this lock
> } finally {
>    l.unlock();
> }
> ```
>
> 当锁定和解锁发生在不同的作用域中时，必须注意确保在锁定期间执行的所有代码都受到 try finally 或 try catch 的保护，以确保在必要时释放锁定。
>
> Lock 实现通过提供一个非阻塞的获取锁的尝试 `tryLock()`，一个获取可以中断的锁的尝试lockInterruptibly，以及试图获取可以超时的锁 `tryLock（long，TimeUnit)`。
>
> Lock 类还可以提供与隐式监视锁完全不同的行为和语义，例如保证排序、不可重入使用或死锁检测。如果一个实现提供了这样的专门语义，那么该实现必须记录这些语义。
>
> 注意 Lock 实例只是普通对象，它们本身可以用作  synchronized 语句中的目标。**获取 lock 实例的监视器锁与调用该实例的任何 lock 方法都没有指定的关系**。建议您不要以这种方式使用 Lock 实例，除非在它们自己的实现中。
>
> 除非另有说明，否则为任何参数传递 null 值将导致引发 NullPointerException。
>
> <h4>内存同步</h4>
>
> 所有的 Lock实现都必须执行内置监视器锁提供的相同内存同步语义，如 [Java 语言规范（17.4内存模型）]( http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html )
>
> 成功的 lock 操作与成功的<em>lock</em>动作具有相同的内存同步效果。
>
> 成功的 unlock 操作与成功的<em>unlock</em>动作具有相同的内存同步效果。
>
> 不成功的锁定和解锁操作以及可重入的锁定/解锁动作不需要任何内存同步效果。
>
> <h4>实现上的注意事项</h4>
>
> 锁获取的三种形式（可中断、不可中断和定时）在性能特征、顺序保证或其他实现质量方面可能有所不同。此外，在给定的 lock 类中可能无法中断正在进行的获取锁的能力。因此，实现不需要为所有三种锁获取形式定义完全相同的保证或语义，也不需要支持正在进行的锁获取的中断。需要一个实现来清楚地记录每个锁定方法提供的语义和保证。它还必须遵守此接口中定义的中断语义，只要支持锁获取中断：要么完全中断，要么仅中断方法入口。
>
> 由于中断通常意味着取消，并且对中断的检查通常是不经常的，所以实现可能倾向于响应中断，而不是普通的方法返回。即使可以显示在另一个操作可能已解除阻止线程之后发生的中断，这也是正确的。实现应该记录此行为。

```java
*
 * @see ReentrantLock
 * @see Condition
 * @see ReadWriteLock
 *
 * @since 1.5
 * @author Doug Lea
 */
public interface Lock {

    /**
     * Acquires the lock.
     *
     * <p>If the lock is not available then the current thread becomes
     * disabled for thread scheduling purposes and lies dormant until the
     * lock has been acquired.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>A {@code Lock} implementation may be able to detect erroneous use
     * of the lock, such as an invocation that would cause deadlock, and
     * may throw an (unchecked) exception in such circumstances.  The
     * circumstances and the exception type must be documented by that
     * {@code Lock} implementation.
     */
    void lock();

    /**
    获取锁，除非当前线程是{@linkplain thread#interrupt interrupted}。
获取锁（如果可用）并立即返回。
如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到发生以下两种情况之一：
- 这个锁是由当前线程获取的；
- 或者某些其他线程中断当前线程（的休眠状态），并且支持锁获取的中断。

如果当前线程：
- 在进入此方法时设置了中断状态；
- 或者在获取锁时设置了{@linkplain thread#interrupt interrupted}，并且支持中断获取锁
则抛出{@link InterruptedException}，并清除当前线程的中断状态。

实施注意事项

在某些实现中中断锁获取的能力可能是不可能的，并且如果可能的话可能是一个昂贵的操作。程序员应该意识到情况可能是这样的。在这种情况下，实现应该记录下来。

实现有利于响应中断，而不是普通的方法返回。

{@code Lock}实现可能能够检测到锁的错误使用，例如可能导致死锁的调用，并且在这种情况下可能抛出（未检查的）异常。环境和异常类型必须由{@code Lock}实现记录。
     * Acquires the lock unless the current thread is
     * {@linkplain Thread#interrupt interrupted}.
     *
     * <p>Acquires the lock if it is available and returns immediately.
     *
     * <p>If the lock is not available then the current thread becomes
     * disabled for thread scheduling purposes and lies dormant until
     * one of two things happens:
     *
     * <ul>
     * <li>The lock is acquired by the current thread; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the
     * current thread, and interruption of lock acquisition is supported.
     * </ul>
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while acquiring the
     * lock, and interruption of lock acquisition is supported,
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>The ability to interrupt a lock acquisition in some
     * implementations may not be possible, and if possible may be an
     * expensive operation.  The programmer should be aware that this
     * may be the case. An implementation should document when this is
     * the case.
     *
     * <p>An implementation can favor responding to an interrupt over
     * normal method return.
     *
     * <p>A {@code Lock} implementation may be able to detect
     * erroneous use of the lock, such as an invocation that would
     * cause deadlock, and may throw an (unchecked) exception in such
     * circumstances.  The circumstances and the exception type must
     * be documented by that {@code Lock} implementation.
     *
     * @throws InterruptedException if the current thread is
     *         interrupted while acquiring the lock (and interruption
     *         of lock acquisition is supported)
     */
    void lockInterruptibly() throws InterruptedException;

    /**
    只有在调用时锁是空闲的情况下才获取锁。

获取锁（如果可用），并立即返回值{@code true}。如果锁不可用，则此方法将立即返回值{@code false}。
     * Acquires the lock only if it is free at the time of invocation.
     *
     * <p>Acquires the lock if it is available and returns immediately
     * with the value {@code true}.
     * If the lock is not available then this method will return
     * immediately with the value {@code false}.
     *
     * <p>A typical usage idiom for this method would be:
     *  <pre> {@code
     // 定义一个 lock 对象
     * Lock lock = ...;
     * if (lock.tryLock()) {
     *   try {
     *     // manipulate protected state
     *   } finally {
     *     lock.unlock();
     *   }
     * } else {
     *   // perform alternative actions
     * }}</pre>
     *
     // 此用法确保在获取锁时将其解锁，并且在未获取锁时不会尝试解锁。因为if 之后在 finally 中解锁了。
     * This usage ensures that the lock is unlocked if it was acquired, and
     * doesn't try to unlock if the lock was not acquired.
     *
     * @return {@code true} if the lock was acquired and
     *         {@code false} otherwise
     */
    boolean tryLock();

    /**
    如果锁在给定的等待时间内空闲并且当前线程未被终中断，则获取该锁。

如果锁可用（获取到），则此方法立即返回值 true。

如果锁不可用（没有获取到），则当前线程将被禁用以进行线程调度，并处于休眠状态，直到发生以下三种情况之一：
- 锁由当前线程获取；
- 另一个线程中断当前线程，并且支持锁获取中断；
- 指定的等待时间已过

如果获取了锁，则返回值{@code true}。

如果当前线程：在进入此方法时设置了中断状态；或在获取锁时是中断的，并且支持中断获取锁，然后 InterruptedException 被抛出，当前线程的中断状态被清除。



如果指定的等待时间已过，则值返回 false

如果时间小于或等于零，则该方法根本不会等待。

### 实施考虑1

在某些实现中中断锁获取的能力可能是不可能的，并且如果可能的话可能是一个昂贵的操作。

程序员应该意识到情况可能是这样的。在这种情况下，实现应该记录下来。

实现可以支持响应中断，而不是普通的方法返回，或者报告超时。

{@code Lock}实现可能能够检测到锁的错误使用，例如可能导致死锁的调用，并且在这种情况下可能抛出（未检查的）异常。

环境和异常类型必须由{@code Lock}实现记录。
     * Acquires the lock if it is free within the given waiting time and the
     * current thread has not been {@linkplain Thread#interrupt interrupted}.
     *
     * <p>If the lock is available this method returns immediately
     * with the value {@code true}.
     * If the lock is not available then
     * the current thread becomes disabled for thread scheduling
     * purposes and lies dormant until one of three things happens:
     * <ul>
     * <li>The lock is acquired by the current thread; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the
     * current thread, and interruption of lock acquisition is supported; or
     * <li>The specified waiting time elapses
     * </ul>
     *
     * <p>If the lock is acquired then the value {@code true} is returned.
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while acquiring
     * the lock, and interruption of lock acquisition is supported,
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared.
     *
     * <p>If the specified waiting time elapses then the value {@code false}
     * is returned.
     * If the time is
     * less than or equal to zero, the method will not wait at all.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>The ability to interrupt a lock acquisition in some implementations
     * may not be possible, and if possible may
     * be an expensive operation.
     * The programmer should be aware that this may be the case. An
     * implementation should document when this is the case.
     *
     * <p>An implementation can favor responding to an interrupt over normal
     * method return, or reporting a timeout.
     *
     * <p>A {@code Lock} implementation may be able to detect
     * erroneous use of the lock, such as an invocation that would cause
     * deadlock, and may throw an (unchecked) exception in such circumstances.
     * The circumstances and the exception type must be documented by that
     * {@code Lock} implementation.
     *
     * @param time the maximum time to wait for the lock
     * @param unit the time unit of the {@code time} argument
     * @return {@code true} if the lock was acquired and {@code false}
     *         if the waiting time elapsed before the lock was acquired
     *
     * @throws InterruptedException if the current thread is interrupted
     *         while acquiring the lock (and interruption of lock
     *         acquisition is supported)
     */
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

    /**
     * Releases the lock.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>A {@code Lock} implementation will usually impose
     * restrictions on which thread can release a lock (typically only the
     * holder of the lock can release it) and may throw
     * an (unchecked) exception if the restriction is violated.
     * Any restrictions and the exception
     * type must be documented by that {@code Lock} implementation.
     */
    void unlock();

    /**
    返回一个 Condition 实例，该实例绑定到调用了 newCondition() 方法的 Lock 实例对象上。
	在等待条件之前，锁必须由当前线程持有。
    对 Condition 的 await（）方法的调用将会在等待之前自动释放锁，并在等待返回之前重新获取锁
	
	实施注意事项
    {@link Condition}实例的确切操作取决于{@code Lock}实现，并且必须由该实现记录。
     * Returns a new {@link Condition} instance that is bound to this
     * {@code Lock} instance.
     *
     * <p>Before waiting on the condition the lock must be held by the
     * current thread.
     * A call to {@link Condition#await()} will atomically release the lock
     * before waiting and re-acquire the lock before the wait returns.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>The exact operation of the {@link Condition} instance depends on
     * the {@code Lock} implementation and must be documented by that
     * implementation.
     *
     * @return A new {@link Condition} instance for this {@code Lock} instance
     * @throws UnsupportedOperationException if this {@code Lock}
     *         implementation does not support conditions
     */
    Condition newCondition();
}

```





### 对 Lock 接口下最重要的实现  ReentrantLock 的研究

当第一个线程执行 Method1 ，首先获取锁之后进行输出，但是因为 lock.unlock(); 被注释了，所以锁并没有释放，这样当第二个线程尝试执行 method2 的时候，在 lock.lock() 时候获取不到锁，所以第二个线程进入睡眠状态，等待着获取这把锁，在等待的过程中，当第一个线程等待 2s 之后进入了下一个循环之中，然后又执行了 `myTest1.myMethod1()`，即执行了 myMethod1 方法，然后即执行其内部的 lock.lock()；因为该对象的锁已经被该线程持有了，因此该线程再次尝试获取该对象的锁的时候，因为是可重入锁所以是可以获取的。

```java
package com.gjxaiou.reentrantLock;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Author GJXAIOU
 * @Date 2021/3/19 15:38
 */
public class MyTest1 {

    // 先定义锁的对象实例
    public Lock lock = new ReentrantLock();

    public void myMethod1(){
        try {
            // 首先尝试获取锁
            lock.lock();
            System.out.println("myMethod1 invoked");
        } finally {
            // 如果注释该行代码，则只执行 method1，并且输出完之后 JVM 不退出
            lock.unlock();
        }
    }

    public void myMethod2(){
        try {
            // 首先尝试获取锁
            lock.lock();
            System.out.println("myMethod2 invoked");
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
         MyTest1 myTest1 = new MyTest1();
        // 分别构建两个线程对象，分别访问上面两个方法

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                myTest1.myMethod1();
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                myTest1.myMethod2();
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        t1.start();
        t2.start();

    }
}
```

执行结果为：每 2 秒输出一次 `myMethod1 invoked`，但是输出完之后 JVM 并没有退出。

```java
myMethod1 invoked
myMethod1 invoked
myMethod1 invoked
myMethod1 invoked
myMethod1 invoked
myMethod1 invoked
myMethod1 invoked
myMethod1 invoked
myMethod1 invoked
myMethod1 invoked
```

如果换成 tryLock，可以正常执行完，这也是比 syhchronized 的优势。

```java
package com.gjxaiou.reentrantLock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Author GJXAIOU
 * @Date 2021/3/19 16:49
 */
public class MyTest2 {

    public Lock lock = new ReentrantLock();

    public void myMethod1() {
        try {
            lock.lock();
            System.out.println("myMethod1 invoked");
        } finally {
            // 取消对锁的释放
        }
    }

    public void myMethod2() {
        boolean result = false;
        try {
            result = lock.tryLock(800, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if (result) {
            System.out.println("get the lock");
        } else {
            System.out.println("can't get the lock");
        }
    }


    public static void main(String[] args) {
        MyTest2 myTest2 = new MyTest2();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                myTest2.myMethod1();

                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                myTest2.myMethod2();
                try {
                    Thread.sleep(800);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        t1.start();
        t2.start();

    }
}
```

输出结果为：正常结束

```java
myMethod1 invoked
can't get the lock
myMethod1 invoked
can't get the lock
myMethod1 invoked
can't get the lock
can't get the lock
myMethod1 invoked
can't get the lock
myMethod1 invoked
can't get the lock
myMethod1 invoked
can't get the lock
myMethod1 invoked
can't get the lock
can't get the lock
myMethod1 invoked
can't get the lock
myMethod1 invoked
myMethod1 invoked

Process finished with exit code 0
```

测试三：将线程中睡眠动作放入方法中，因为现在是每次方法执行完才睡眠，不会对 lock 产生影响。

```java
package com.gjxaiou.reentrantLock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Author GJXAIOU
 * @Date 2021/3/19 16:59
 */
public class MyTest3 {

    public Lock lock = new ReentrantLock();

    public void myMethod1() {
        try {
            lock.lock();
            System.out.println("myMethod1 invoked");
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();

        } finally {
            lock.unlock();
        }
    }

    public void myMethod2() {
        boolean result = false;
        try {
            result = lock.tryLock(800, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if (result) {
            System.out.println("get the lock");
        } else {
            System.out.println("can't get the lock");
        }
    }

    public static void main(String[] args) {
        MyTest3 myTest3 = new MyTest3();
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                myTest3.myMethod1();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                myTest3.myMethod2();
            }
        });

        t1.start();
        t2.start();

    }

}

```

当第一个线程执行 myMethod1 时候，通过 lock.lock() 获取锁之后进入睡眠状态，则第二个线程执行 myMethod2 的 lock.tryLock() 时可能获取到也可能获取不到。

如果第一个线程刚好执行 unlock() 之后，还没有获取到新的锁之后，第二个线程就可以获取到锁。如果第一个线程还处于睡眠状态，则该线程还没有执行完该方法体中的代码，则这个锁还没有释放，则第二个线程获取不到锁。

输出结果

```java
myMethod1 invoked
can't get the lock
can't get the lock
myMethod1 invoked
can't get the lock
can't get the lock
get the lock
get the lock
get the lock
get the lock
get the lock
get the lock
```

#### Lock 和 synchronized 的区别

- 锁的获取方式∶前者是通过程序代码的方式由开发者手工获取（通过 lock()/tryLock() 等方法），后者是通过JVM来获取（无需开发者干预) 

- 具体实现方式: 前者是通过Java代码的方式来实现，后者是通过JVM底层来实现(无需开发者关注) 

- 锁的释放方式: 前者务必通过unlock()方法在finally块中手工释放，后者是通过JVM来释放（无需开发者关注) 

- 锁的具体类型: 前者提供了多种，如公平锁、非公平锁，后者与前者均提供了可重入锁 

常用的实现类：ReentrantLock（可重入锁，可以重新获得的锁）



### condition 详解及相比于传统线程并发模式的改进

传统上，我们可以通过 synchronized 关键字 ＋ wait + notify/notifyAll 来实现多个线程之间的协调与通信，整个过程都是由 JVM 来帮助我们实现的，开发者无需(也是无法)了解底层的实现细节。

从 JDK5 开始，并发包提供了 lock + Condition(主要是里面的 await 与 signal/signalAll )来实现多个线程之间的协调与通信，整个过程都是由开发者来控制的，而且相比于传统方式，更加灵活，功能也更加强大。

Thread.sleep与await(或是object的wait方法)的本质区别: sleep方法本质上不会释放锁，而await会释放锁，并且在signal后，还需要重新获得锁才能继续执行(该行为与object的wait方法完全一致)。

```java
/*
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent.locks;

import java.util.concurrent.TimeUnit;
import java.util.Date;

/**
 * Condition 相当于将 Object 类中的 monitor 方法（wait/notify/notifyAll）方法插入到不同对象中，以实现让每个对象有多个等待集合 wait-sets
 * 的效果。 * （传统方式是调用 wait 之后，所有线程都会进入该对象的唯一的一个等待集合中，但是 condition 可以将某几个线程放在一个等待集合中，另几个放在另一个等待集合）。
 * 通过任意一个 Lock 实现将他们组合起来，其中使用 Lock 替换掉 synchronized 修饰方法/代码块的使用，使用 Condition 替换掉 Object 中的那些监视器
 * monitor 方法。
 * <p>
 * Condition（也称之为条件队列/条件变量）提供了一种方式让线程挂起执行（类似于 wait）直到被另一个线程通知，这里的另一个线程满足某些状态条件变成了
 * true。由于在不同线程中发生这种共享状态信息的访问，因此其需要被保护，所以一个 lock 的某种形式需要关联到 condition 上。等待一个 condition
 * 提供的关键属性是它以原子方式释放关联的锁并挂起当前线程，就想 Object 的 wait 方法。
 * <p>
 * Condition 实例本质上绑定到 lock 上。要获取特定 Lock 实例的 Condition 实例，请使用 Lock 的 newCondition（）方法。【因此一个 lock 对象和
 * condition 对象是一对多的关系，因为每次通过 newCondition() 方法就获得一个 condition 对象】。
 * <p>
 * 例如，假设我们有一个支持{@code put}和{@code take}方法的有界缓冲区。如果在空缓冲区上尝试 take，则线程将阻塞，直到某个项变为可用；如果在满缓冲区上尝试
 * put，则线程将阻塞，直到某个空间变为可用。我们希望保持 put 线程和 take 线程在单独的等待集中等待，这样当缓冲区中的项或空间可用时，我们就可以使用只通知单个线程的优化。
 * 这可以通过使用两个{@link Condition}实例来实现。
 * <p>
 * 代码分析见笔记
 * （java.util.concurrent.ArrayBlockingQueue 类提供了这些功能，因此没有必要不使用类而像上面一样实现）
 * {@code Condition}实现可以提供不同于{@code Object}监视方法的行为和语义，例如保证通知的顺序，或者在执行通知时不需要持有锁。
 * <p>
 * 如果一个实现提供了这种专门的语义，那么这个实现必须记录这些语义。
 * <p>
 * 请注意，{@code Condition}实例只是普通对象，它们本身可以用作 synchronized 语句中的目标，并且可以调用它们自己的监视器
 * {@link Object#wait wait}和{@link Object#notify notification}方法。获取{@code Condition}
 * 实例的监视锁或使用其监视方法与获取与该{@code Condition}关联的{@link lock}或使用其{@linkplain#await waiting}和
 * {@linkplain#signal signaling}方法没有指定的关系。为了避免混淆，建议不要以这种方式使用{@code Condition}实例，除了它们自己的实现之外。【即
 * condition 也是一个普通的对象，其自身也是有 monitor 等，所以我们获取 condition 的 monitor 锁和使用 Condition 中的 wait/signal
 * 方法没有任何关系】。
 * <p>
 * 除非另有说明，否则为任何参数传递{@code null}值将导致抛出{@link NullPointerException}。
 *
 * <h3>实施注意事项</h3>
 * <p>
 * 在等待{@code Condition}时，通常允许发生虚假唤醒</em>&quot；作为对底层平台语义的让步。
 * <p>
 * 这对大多数应用程序几乎没有实际影响，因为 Condition
 * 应该始终在循环中等待，测试正在等待的状态谓词。实现可以自由地消除虚假唤醒的可能性，
 * 但建议应用程序程序员始终假设它们可以发生，因此始终在循环中等待。条件等待的三种形式（可中断、不可中断和定时）在某些平台上的易实现性和性能特征可能有所不同。尤其是，可能很难提供这些特性并维护特定的语义，例如排序保证。此外，中断线程的实际挂起的能力可能并不总是能够在所有平台上实现。
 * 因此，实现不需要为所有三种形式的等待定义完全相同的保证或语义，也不需要支持中断线程的实际挂起。
 * 一个实现需要清楚地记录每个等待方法提供的语义和保证，当一个实现确实支持线程挂起的中断时，它必须遵守这个接口中定义的中断语义。
 * 由于中断通常意味着取消，并且对中断的检查通常不经常发生，所以实现可能会倾向于响应中断而不是正常的方法返回。即使可以显示中断发生在另一个可能已解除线程阻塞的操作之后，也是如此。实现应该记录这种行为
 */


/**
 * {@code Condition} factors out the {@code Object} monitor
 * methods ({@link Object#wait() wait}, {@link Object#notify notify}
 * and {@link Object#notifyAll notifyAll}) into distinct objects to
 * give the effect of having multiple wait-sets per object, by
 * combining them with the use of arbitrary {@link Lock} implementations.
 * Where a {@code Lock} replaces the use of {@code synchronized} methods
 * and statements, a {@code Condition} replaces the use of the Object
 * monitor methods.
 *
 * <p>Conditions (also known as <em>condition queues</em> or
 * <em>condition variables</em>) provide a means for one thread to
 * suspend execution (to &quot;wait&quot;) until notified by another
 * thread that some state condition may now be true.  Because access
 * to this shared state information occurs in different threads, it
 * must be protected, so a lock of some form is associated with the
 * condition. The key property that waiting for a condition provides
 * is that it <em>atomically</em> releases the associated lock and
 * suspends the current thread, just like {@code Object.wait}.
 *
 * <p>A {@code Condition} instance is intrinsically bound to a lock.
 * To obtain a {@code Condition} instance for a particular {@link Lock}
 * instance use its {@link Lock#newCondition newCondition()} method.
 *
 * <p>As an example, suppose we have a bounded buffer which supports
 * {@code put} and {@code take} methods.  If a
 * {@code take} is attempted on an empty buffer, then the thread will block
 * until an item becomes available; if a {@code put} is attempted on a
 * full buffer, then the thread will block until a space becomes available.
 * We would like to keep waiting {@code put} threads and {@code take}
 * threads in separate wait-sets so that we can use the optimization of
 * only notifying a single thread at a time when items or spaces become
 * available in the buffer. This can be achieved using two
 * {@link Condition} instances.
 * <pre>
 * class BoundedBuffer {
 *   <b>final Lock lock = new ReentrantLock();</b>
 *   final Condition notFull  = <b>lock.newCondition(); </b>
 *   final Condition notEmpty = <b>lock.newCondition(); </b>
 *
 *   final Object[] items = new Object[100];
 *   int putptr, takeptr, count;
 *
 *   public void put(Object x) throws InterruptedException {
 *     <b>lock.lock();
 *     try {</b>
 *       while (count == items.length)
 *         <b>notFull.await();</b>
 *       items[putptr] = x;
 *       if (++putptr == items.length) putptr = 0;
 *       ++count;
 *       <b>notEmpty.signal();</b>
 *     <b>} finally {
 *       lock.unlock();
 *     }</b>
 *   }
 *
 *   public Object take() throws InterruptedException {
 *     <b>lock.lock();
 *     try {</b>
 *       while (count == 0)
 *         <b>notEmpty.await();</b>
 *       Object x = items[takeptr];
 *       if (++takeptr == items.length) takeptr = 0;
 *       --count;
 *       <b>notFull.signal();</b>
 *       return x;
 *     <b>} finally {
 *       lock.unlock();
 *     }</b>
 *   }
 * }
 * </pre>
 * <p>
 * (The {@link java.util.concurrent.ArrayBlockingQueue} class provides
 * this functionality, so there is no reason to implement this
 * sample usage class.)
 *
 * <p>A {@code Condition} implementation can provide behavior and semantics
 * that is
 * different from that of the {@code Object} monitor methods, such as
 * guaranteed ordering for notifications, or not requiring a lock to be held
 * when performing notifications.
 * If an implementation provides such specialized semantics then the
 * implementation must document those semantics.
 *
 * <p>Note that {@code Condition} instances are just normal objects and can
 * themselves be used as the target in a {@code synchronized} statement,
 * and can have their own monitor {@link Object#wait wait} and
 * {@link Object#notify notification} methods invoked.
 * Acquiring the monitor lock of a {@code Condition} instance, or using its
 * monitor methods, has no specified relationship with acquiring the
 * {@link Lock} associated with that {@code Condition} or the use of its
 * {@linkplain #await waiting} and {@linkplain #signal signalling} methods.
 * It is recommended that to avoid confusion you never use {@code Condition}
 * instances in this way, except perhaps within their own implementation.
 *
 * <p>Except where noted, passing a {@code null} value for any parameter
 * will result in a {@link NullPointerException} being thrown.
 *
 * <h3>Implementation Considerations</h3>
 *
 * <p>When waiting upon a {@code Condition}, a &quot;<em>spurious
 * wakeup</em>&quot; is permitted to occur, in
 * general, as a concession to the underlying platform semantics.
 * This has little practical impact on most application programs as a
 * {@code Condition} should always be waited upon in a loop, testing
 * the state predicate that is being waited for.  An implementation is
 * free to remove the possibility of spurious wakeups but it is
 * recommended that applications programmers always assume that they can
 * occur and so always wait in a loop.
 *
 * <p>The three forms of condition waiting
 * (interruptible, non-interruptible, and timed) may differ in their ease of
 * implementation on some platforms and in their performance characteristics.
 * In particular, it may be difficult to provide these features and maintain
 * specific semantics such as ordering guarantees.
 * Further, the ability to interrupt the actual suspension of the thread may
 * not always be feasible to implement on all platforms.
 *
 * <p>Consequently, an implementation is not required to define exactly the
 * same guarantees or semantics for all three forms of waiting, nor is it
 * required to support interruption of the actual suspension of the thread.
 *
 * <p>An implementation is required to
 * clearly document the semantics and guarantees provided by each of the
 * waiting methods, and when an implementation does support interruption of
 * thread suspension then it must obey the interruption semantics as defined
 * in this interface.
 *
 * <p>As interruption generally implies cancellation, and checks for
 * interruption are often infrequent, an implementation can favor responding
 * to an interrupt over normal method return. This is true even if it can be
 * shown that the interrupt occurred after another action that may have
 * unblocked the thread. An implementation should document this behavior.
 *
 * @author Doug Lea
 * @since 1.5
 */
public interface Condition {

    /**
     * 导致当前线程处于等待状态，直到被调用 signal 或者该线程被中断了。
     *
     * 调用 await 之后，与此 Condition 关联的锁被原子释放，当前线程无法进行线程调度，并且处于休眠状态，直到发生以下四种情况中的一种：
     *
     * 另一个线程调用当前 Condition 的 signal 方法，而当前线程恰好被选为要唤醒的线程；
     * 或者另一个线程为此{@code Condition}调用 signalAll方法；
     * 或者另一个线程中断了当前线程，并中断线程支持暂停；
     * 或发生“虚假唤醒”。
     *
     * 在所有情况下，在该方法返回之前（继续往下执行），当前线程必须重新获取与该 Condition 相关联的锁。当线程返回时保证其持有此锁。
     *
     * 如果当前线程：在进入此方法时设置了中断状态；或者在等待时被中断了，并且支持中断线程挂起，则抛出 InterruptedException
     * ，并且当前线程的中断状态被清除。在第一种情况下，没有规定是否在锁定之前进行中断测试释放。
     *
     * <b>实施注意事项</b>
     *
     * 调用此方法时，假定当前线程持有与此{@code Condition}关联的锁。这取决于执行情况，以确定是否是这种情况，如果不是，如何应对。通常，会抛出异常（例如
     * {@link IllegalMonitorStateException}），实现必须记录该事实。
     *
     * 与响应信号的正常方法返回相比，实现更倾向于响应中断。在这种情况下，实现必须确保信号被重定向到另一个等待线程（如果有）。
     * Causes the current thread to wait until it is signalled or
     * {@linkplain Thread#interrupt interrupted}.
     *
     * <p>The lock associated with this {@code Condition} is atomically
     * released and the current thread becomes disabled for thread scheduling
     * purposes and lies dormant until <em>one</em> of four things happens:
     * <ul>
     * <li>Some other thread invokes the {@link #signal} method for this
     * {@code Condition} and the current thread happens to be chosen as the
     * thread to be awakened; or
     * <li>Some other thread invokes the {@link #signalAll} method for this
     * {@code Condition}; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the
     * current thread, and interruption of thread suspension is supported; or
     * <li>A &quot;<em>spurious wakeup</em>&quot; occurs.
     * </ul>
     *
     * <p>In all cases, before this method can return the current thread must
     * re-acquire the lock associated with this condition. When the
     * thread returns it is <em>guaranteed</em> to hold this lock.
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while waiting
     * and interruption of thread suspension is supported,
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared. It is not specified, in the first
     * case, whether or not the test for interruption occurs before the lock
     * is released.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>The current thread is assumed to hold the lock associated with this
     * {@code Condition} when this method is called.
     * It is up to the implementation to determine if this is
     * the case and if not, how to respond. Typically, an exception will be
     * thrown (such as {@link IllegalMonitorStateException}) and the
     * implementation must document that fact.
     *
     * <p>An implementation can favor responding to an interrupt over normal
     * method return in response to a signal. In that case the implementation
     * must ensure that the signal is redirected to another waiting thread, if
     * there is one.
     *
     * @throws InterruptedException if the current thread is interrupted
     *                              (and interruption of thread suspension is supported)
     */
    void await() throws InterruptedException;

    /**
     * 等待不可中断
     * Causes the current thread to wait until it is signalled.
     *
     * <p>The lock associated with this condition is atomically
     * released and the current thread becomes disabled for thread scheduling
     * purposes and lies dormant until <em>one</em> of three things happens:
     * <ul>
     * <li>Some other thread invokes the {@link #signal} method for this
     * {@code Condition} and the current thread happens to be chosen as the
     * thread to be awakened; or
     * <li>Some other thread invokes the {@link #signalAll} method for this
     * {@code Condition}; or
     * <li>A &quot;<em>spurious wakeup</em>&quot; occurs.
     * </ul>
     *
     * <p>In all cases, before this method can return the current thread must
     * re-acquire the lock associated with this condition. When the
     * thread returns it is <em>guaranteed</em> to hold this lock.
     *
     * <p>If the current thread's interrupted status is set when it enters
     * this method, or it is {@linkplain Thread#interrupt interrupted}
     * while waiting, it will continue to wait until signalled. When it finally
     * returns from this method its interrupted status will still
     * be set.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>The current thread is assumed to hold the lock associated with this
     * {@code Condition} when this method is called.
     * It is up to the implementation to determine if this is
     * the case and if not, how to respond. Typically, an exception will be
     * thrown (such as {@link IllegalMonitorStateException}) and the
     * implementation must document that fact.
     */
    void awaitUninterruptibly();

    /**
     * Causes the current thread to wait until it is signalled or interrupted,
     * or the specified waiting time elapses.
     *
     * <p>The lock associated with this condition is atomically
     * released and the current thread becomes disabled for thread scheduling
     * purposes and lies dormant until <em>one</em> of five things happens:
     * <ul>
     * <li>Some other thread invokes the {@link #signal} method for this
     * {@code Condition} and the current thread happens to be chosen as the
     * thread to be awakened; or
     * <li>Some other thread invokes the {@link #signalAll} method for this
     * {@code Condition}; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the
     * current thread, and interruption of thread suspension is supported; or
     * <li>The specified waiting time elapses; or   // 增加一个一种：指定的等待时间已经过去了
     * <li>A &quot;<em>spurious wakeup</em>&quot; occurs.
     * </ul>
     *
     * <p>In all cases, before this method can return the current thread must
     * re-acquire the lock associated with this condition. When the
     * thread returns it is <em>guaranteed</em> to hold this lock.
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while waiting
     * and interruption of thread suspension is supported,
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared. It is not specified, in the first
     * case, whether or not the test for interruption occurs before the lock
     * is released.
     *
     * 该方法会返回一个近似的纳秒时间，改时间是剩余的响应时间（如设定 500纳秒，但是 200 纳秒之后就相应了，则返回300）。如果返回值小于或者等于 0则表示超时了。
     * <p>The method returns an estimate of the number of nanoseconds
     * remaining to wait given the supplied {@code nanosTimeout}
     * value upon return, or a value less than or equal to zero if it
     * timed out. This value can be used to determine whether and how
     * long to re-wait in cases where the wait returns but an awaited
     * condition still does not hold. Typical uses of this method take
     * the following form:
     *
     *  <pre> {@code
     * boolean aMethod(long timeout, TimeUnit unit) {
     *   long nanos = unit.toNanos(timeout);
     *   lock.lock();
     *   try {
     *     while (!conditionBeingWaitedFor()) {
     *       if (nanos <= 0L)
     *         return false;
     *       nanos = theCondition.awaitNanos(nanos);
     *     }
     *     // ...
     *   } finally {
     *     lock.unlock();
     *   }
     * }}</pre>
     *
     * <p>Design note: This method requires a nanosecond argument so
     * as to avoid truncation errors in reporting remaining times.
     * Such precision loss would make it difficult for programmers to
     * ensure that total waiting times are not systematically shorter
     * than specified when re-waits occur.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>The current thread is assumed to hold the lock associated with this
     * {@code Condition} when this method is called.
     * It is up to the implementation to determine if this is
     * the case and if not, how to respond. Typically, an exception will be
     * thrown (such as {@link IllegalMonitorStateException}) and the
     * implementation must document that fact.
     *
     * <p>An implementation can favor responding to an interrupt over normal
     * method return in response to a signal, or over indicating the elapse
     * of the specified waiting time. In either case the implementation
     * must ensure that the signal is redirected to another waiting thread, if
     * there is one.
     *
     * @param nanosTimeout the maximum time to wait, in nanoseconds
     * @return an estimate of the {@code nanosTimeout} value minus
     * the time spent waiting upon return from this method.
     * A positive value may be used as the argument to a
     * subsequent call to this method to finish waiting out
     * the desired time.  A value less than or equal to zero
     * indicates that no time remains.
     * @throws InterruptedException if the current thread is interrupted
     *                              (and interruption of thread suspension is supported)
     */
    long awaitNanos(long nanosTimeout) throws InterruptedException;

    /**
     * Causes the current thread to wait until it is signalled or interrupted,
     * or the specified waiting time elapses. This method is behaviorally
     * equivalent to:
     * <pre> {@code awaitNanos(unit.toNanos(time)) > 0}</pre>
     *
     * @param time the maximum time to wait
     * @param unit the time unit of the {@code time} argument
     * @return {@code false} if the waiting time detectably elapsed
     * before return from the method, else {@code true}
     * @throws InterruptedException if the current thread is interrupted
     *                              (and interruption of thread suspension is supported)
     */
    boolean await(long time, TimeUnit unit) throws InterruptedException;

    /**
     * Causes the current thread to wait until it is signalled or interrupted,
     * or the specified deadline elapses.
     *
     * <p>The lock associated with this condition is atomically
     * released and the current thread becomes disabled for thread scheduling
     * purposes and lies dormant until <em>one</em> of five things happens:
     * <ul>
     * <li>Some other thread invokes the {@link #signal} method for this
     * {@code Condition} and the current thread happens to be chosen as the
     * thread to be awakened; or
     * <li>Some other thread invokes the {@link #signalAll} method for this
     * {@code Condition}; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the
     * current thread, and interruption of thread suspension is supported; or
     * <li>The specified deadline elapses; or
     * <li>A &quot;<em>spurious wakeup</em>&quot; occurs.
     * </ul>
     *
     * <p>In all cases, before this method can return the current thread must
     * re-acquire the lock associated with this condition. When the
     * thread returns it is <em>guaranteed</em> to hold this lock.
     *
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while waiting
     * and interruption of thread suspension is supported,
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared. It is not specified, in the first
     * case, whether or not the test for interruption occurs before the lock
     * is released.
     *
     *
     * <p>The return value indicates whether the deadline has elapsed,
     * which can be used as follows:
     *  <pre> {@code
     * boolean aMethod(Date deadline) {
     *   boolean stillWaiting = true;
     *   lock.lock();
     *   try {
     *     while (!conditionBeingWaitedFor()) {
     *       if (!stillWaiting)
     *         return false;
     *       stillWaiting = theCondition.awaitUntil(deadline);
     *     }
     *     // ...
     *   } finally {
     *     lock.unlock();
     *   }
     * }}</pre>
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>The current thread is assumed to hold the lock associated with this
     * {@code Condition} when this method is called.
     * It is up to the implementation to determine if this is
     * the case and if not, how to respond. Typically, an exception will be
     * thrown (such as {@link IllegalMonitorStateException}) and the
     * implementation must document that fact.
     *
     * <p>An implementation can favor responding to an interrupt over normal
     * method return in response to a signal, or over indicating the passing
     * of the specified deadline. In either case the implementation
     * must ensure that the signal is redirected to another waiting thread, if
     * there is one.
     *
     * @param deadline the absolute time to wait until
     * @return {@code false} if the deadline has elapsed upon return, else
     * {@code true}
     * @throws InterruptedException if the current thread is interrupted
     *                              (and interruption of thread suspension is supported)
     */
    boolean awaitUntil(Date deadline) throws InterruptedException;

    /**
     * Wakes up one waiting thread.
     *
     * <p>If any threads are waiting on this condition then one
     * is selected for waking up. That thread must then re-acquire the
     * lock before returning from {@code await}.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>An implementation may (and typically does) require that the
     * current thread hold the lock associated with this {@code
     * Condition} when this method is called. Implementations must
     * document this precondition and any actions taken if the lock is
     * not held. Typically, an exception such as {@link
     * IllegalMonitorStateException} will be thrown.
     */
    void signal();

    /**
     * 唤醒所有的等待线程
     * 任何在该 condition 上等待的线程都会被唤醒，每个线程在从 await 方法上返回前必须重新获取 锁（即全部被唤醒之后，只有一个线程能获取锁，所以只有一个线程能从
     * await 上返回，其他线程还是处于等待状态。因此线程被唤醒和可以继续执行不是一回事）
     * Wakes up all waiting threads.
     *
     * <p>If any threads are waiting on this condition then they are
     * all woken up. Each thread must re-acquire the lock before it can
     * return from {@code await}.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>An implementation may (and typically does) require that the
     * current thread hold the lock associated with this {@code
     * Condition} when this method is called. Implementations must
     * document this precondition and any actions taken if the lock is
     * not held. Typically, an exception such as {@link
     * IllegalMonitorStateException} will be thrown.
     */
    void signalAll();
}
```

condition 使用标准示例（JavaDoc 文档中的）

```java
package com.gjxaiou.condition;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Author GJXAIOU
 * @Date 2021/3/19 20:15
 */
public class MyTest1 {

    final Lock lock = new ReentrantLock();
    // 调用同一个 lock 实例生成的两个 condition 对象。
    final Condition notFull = lock.newCondition();
    final Condition notEmpty = lock.newCondition();

    final Object[] items = new Object[100];
    int putptr, takeptr, count;

    public void put(Object x) throws InterruptedException {
        // 首先要获取锁
        lock.lock();
        try {
            while (count == items.length) {
                // 调用 await 进入等待状态，同时释放锁。同时放在 while 循环中，保证其它线程通过 signal
                //方法唤醒该线程，则该线程需要和其他线程争抢说，争抢到了才能执行。
                notFull.await();
            }
            items[putptr] = x;
            if (++putptr == items.length) {
                putptr = 0;
            }
            ++count;
            // 通知另一个线程，可以取出了。
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await();
            }
            Object x = items[takeptr];
            if (++takeptr == items.length) {
                takeptr = 0;
            }
            --count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```

Condition 主要方法测试和应用场景

该类实现的例子的描述：实现对容器的放置和取出的操作，在这个操作过程中保证在某一个时刻只能有一个线程在进行使用和操作。

整体的过程就是在模拟synchronized关键字和wait方法以及notify方法（只不过上面是从字节码层面来解决这个问题）

该类实现的例子的描述：实现对容器元素的放置和取出的操作，在多个线程操作过程中保证在某一个时刻只能有一个线程在进行使用和操作。使用condition来实现操作（这个concurrentHashMap，以及使用Collections工具类来实现集合实现并发安全的操作）。

put 方法不断往后放置元素，take 方法不断往后取元素，然后置为 NULL，如果满了从头开始。如果整个数组全部满了之后则 put 线程需要等待 take 线程取出一个元素，反之一样。

=> 如果 put 线程数和 get 线程数相同，则最终结果均为 Null，如果数目不一致：如  10 个 put, 8 个 take，则最后两个有元素，如果 8 个 put，10 个 take，则最终结果全部为 null，但是程序无法退出，因为第九个/十个 take 线程都陷入 await 的循环中了。因为 8 个唤醒线程已经用完了，没有线程使用 signal 来唤醒了。

```java
package com.gjxaiou.condition;

import javax.lang.model.element.NestingKind;
import java.util.Arrays;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.IntStream;

/**
 * @Author GJXAIOU
 * @Date 2021/3/20 12:52
 */
public class MyTest2 {

    public static void main(String[] args) {
        // 创建线程
        BoundedContainer boundedContainer = new BoundedContainer();

        IntStream.range(0, 10).forEach(i -> new Thread(() -> {
            try {
                boundedContainer.take();
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
        }).start());
        
        IntStream.range(0, 10).forEach(i -> new Thread(() -> {
            try {
                boundedContainer.put("hello");
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
        }).start());
    }
}

class BoundedContainer {

    // 定义一个有界数组存放元素
    private String[] elements = new String[10];

    // 定义一个  lock 对象，因为针对该数组不能有任意两个数组同时进行操作，无论是放放还是放拿还是拿拿都不行
    private Lock lock = new ReentrantLock();

    // 因为针对两个动作：拿和放都需要一定的条件，需要需要两个 condition
    // 全空的时候 拿线程不能进行，全满的时候放置线程不能进行
    private Condition notEmptyCondition = lock.newCondition();
    private Condition notFullCondition = lock.newCondition();

    // 判断数组元素是不是满了，该值表示数组中已有元素数量
    private int elementCount;

    // 接下来放置元素的位置和接下来取元素位置
    private int putIndex;
    private int takeIndex;


    public void put(String element) throws InterruptedException {
        // 禁止任意两个线程同时执行 put 方法，所以首先要获取锁
        this.lock.lock();

        try {
            // 首先如果数组满了就需要等待
            while (this.elementCount == this.elements.length) {
                // 被 signal 唤醒之后会再次判断，如果为真则表示有位子放置了
                notFullCondition.await();
            }
            elements[putIndex] = element;
            if (++putIndex == this.elements.length) {
                putIndex = 0;
            }
            ++elementCount;
            System.out.println("put method" + Arrays.toString(elements));

            // 通知取元素可以取了
            notEmptyCondition.signal();

        } finally {
            lock.unlock();
        }
    }

    public String take() throws InterruptedException {
        lock.lock();

        try {
            while (this.elementCount == 0) {
                notEmptyCondition.await();
            }
            String res = elements[takeIndex];
            elements[takeIndex] = null;
            if (++takeIndex == this.elements.length) {
                takeIndex = 0;
            }
            --elementCount;
            System.out.println("take method" + Arrays.toString(elements));

            // 通知放置元素线程
            notFullCondition.signal();
            return res;
        } finally {
            lock.unlock();
        }
    }
}
```



## Volatile

使用方式：private volatile int count；

#### volatile 关键字的作用以及缺点

- 实现 long/double 类型变量的原子操作

    因为 JVM 中的 long 和 double 都是占 64 位，针对现在的 32 位和 64 位机器，其可能分成低 32 位和高 32 位进行分别填充赋值。导致其非原子性。

    ![image-20210320151618677](部分一：线程.resource/image-20210320151618677.png)

    如图所示：volatile double a = 1.0 // 因为一个double的赋值其实是分为两步来完成的。也可以使用 atomicLong 或者 atomicDouble 来实现。

    

- 防止指令重排序

- 实现变量的可见性

因为程序在读取一个变量值的时候不会直接从内存中进行读取，而是从 CPU 中的寄存器中读取。当使用 volatile 修饰一个变量的时候，编译器就不会将该变量防止到寄存器中进行存储。对变量的访问和修改都需要访问内存。

当使用 volatile 修饰变量时，应用就不会从寄存器中获取该变量的值，而是从内存（高速缓存）中获取。

####  volatile与锁的异同

Volatile 和锁的类似两点：确保变量的内存可见性和防止指令重排序，但是它并不是锁。

不具备：

- 可以保证其修饰变量写操作的原子性，但是不具备锁的排他性（互斥性）。【原子性可以理解为就是一条 CPU 指令，不能在分割了。而排他性是指像 synchronized 那样同一时刻只能有一个线程操作，而 volatile 修饰的变量可能同时有多个线程对其进行写操作】
- 使用锁可能会导致线程的上下文切换(内核态与用户态之间的切换)，但使用volatile并不会出现这种情况 （一直在用户态）。

#### volatile的缺点：

为了实现原子性操作那么每次取数据的时候不会在寄存器上取而是在主内存或者高速缓存上取这将带来性能的损失

 

volatile int a = b + 2;    // 错误示例，无法保证对 a 的原子性。这里的赋值包含两个步骤：首先实现 b + 2，然后将其结果赋值给了 a。因为第一个线程获取 b 进行了 + 2，第二个线程也获取了 b，则 b 的值都不一样。【b + 2，其实是两步，先读取 b 然后进行 + 2】因为这里是两条指令进行一个操作。

volatile int a = a++;     // 同样需要两条指令来完成相应的操作

volatile int count = 1;    // 正确示例

volatile boolean flag = false; // 正确示例

volatile Date date = new Date( );这个如果是多线程的话也可能出现问题，因为 new Date() 首先需要在堆上创建一个 Date 对象的存储并生成一些数据，然后返回一个引用给左侧的 date。加上 volatile 仅仅能保证将引用值赋值给 date 是一个原子操作。因为通常以上操作都是在一个方法中，只能被一个线程执行，所以没有问题。

如果要实现volatile写操作的原子性，那么在等号右侧的赋值变量中就不能出现被多线程所共享的变量，哪怕这个变量也是个volatile也不可以。

#### 2.3 实现原理

防止指令重排序和实现变量的可见性都是通过一种手段进行实现的：内存屏障（Memory Barrier）

JIT 编译器将源代码生成字节码的过程中可能会进行指令的重排序以提升执行性能。在当线程问题下没有任何问题。Volatile 可以防止指令重排序，代码示例如下：



##### volatile 修饰写入操作

```java
int a = 1;

String s = " hello" ;

内存屏障(Release Barrier，释放屏障) // 这个是jvm底层自己加的就像monitorenter和monitorexist
volatile boolean v = false; // 这是一个写操作，看到 volatile 会在前后自动加上屏障
写入操作内存屏障(store Barrier，存储屏障)
```

Release Barrier实现两点作用：防止下面的volatile与上面的所有操作的指令重排序。和让内存屏障前的所有读/写操作都能立刻发布到其它所有的线程中，使得其它线程可以看到修改结果。（为了防止重排序就把上面的代码给执行掉），保证在 volatile 的修改之前，前面所有的读/写操作都已经被提交了，当前线程在执行 volatile 写操作时候，其它线程都可以看到 volatile 前面的所有的修改，这样就保证了其他的读线程对于当前写线程在写入 volatile 变量之前对共享变量的所有更新变量的看到顺序与源代码顺序一致，即防止指令重排序。

Store Barrier∶重要作用是刷新处理器缓存，结果是可以确保该存储屏障之前一切（包括 volatile 修饰和非 volatile 修饰）的操作所生成的结果对于其他处理器来说都立刻可见。

##### volatile 修饰读操作

```java
 内存屏障(Load Barrier，加载屏障)
 boolean v1 = v;
内存屏障(Acquire Barrier，获取屏障)

int a = 1;

String s = "hello" ;
```

Load Barrier:可以刷新处理器缓存，同步其他处理器对该volatile变量的修改结果。

Acquire Barrier:可以防止上面的volatile读取操作与下面的所有操作语句的指令重排序。

 

对于volatile关键字变量的读写操作，本质上都是通过内存屏障来执行的。

内存屏障兼具了两方面能力:1．防止指令重排序，2．实现变量内存的可见性。

1．对于读取操作来说，volatile可以确保该操作与其后续的所有读写操作都不会进行指令重排序。

2．对于修改操作来说，volatile可以确保该操作与其上面的所有读写操作都不会进行指令重排序。

 

volatile 只能修饰原生类型，不能修饰非原生类型，如 ArrayList(对于非原生类型，如果是赋值将具备原子性的操作，但是创建这个对象什么的不具备原子性)

 

#### volatile与锁的一些比较

锁同样具备变量内存可见性与防止指令重排序的功能。

以 synchroned 修饰代码块为例，其防止指令重排序也是使用内存屏障实现，在两个指令的前后的内存屏障如下所示：

monitorenter

内存屏障(Acquire Barrier, 获取屏障)

。。。。。

内存屏障(Release Barrier,释放屏障)

monitorexit

 

#### happen- -before

在多核的场景下，某个处理器对某个变量的修改操作**最终**是可以被其它处理器所知晓的，但是没确定什么时候能获取到。不保证实时一致性，只能保证最终一致性。

#### 3.1 Java内存模型(Java Memory Model, JMM) 以及happen- -before

JMM 主要规定以下问题，但是最终实现需要各个 JVM 来自定义实现。下面的变量主要是成员变量或者静态变量，因为局部变量不存在这些问题。

1.变量的原子性问题。

2.变量的可见性问题

3.变量修改的时序性问题。

#### 3.2 happen-before重要规则:（定义在 JMM 规范中）

happen-before 原则一方面具有传递性，同时除了第一个在单个线程内部，其它均是在多个线程之间。

- 顺序执行规则(限定在单个线程上的) :该线程的每个动作都happen-before它的后面的动作。（指令重排序和happen-before是不矛盾的，只要不违反 happen-before原则是允许指令重排序的，比如一个线程执行 a/b/c 三条语句，则 a  happen-before b happen before c，但是并不表示 a 一定会在 b 之前执行，因为如果  a  和 b 之间操作的语句没有任何关系的话，JIT 编译器是允许他们进行指令重排序的。但是如果有有先后关系则不会进行指令重排序）

- 隐式锁(monitor) 规则：针对同一把锁 unlock happen- before lock, 之前的线程对于同步代码块的所有执行结果对于后续获取同一把锁的线程来说都是可见的。

- volatile读写规则：对于一个volatile变量的写操作一定会happen-before后续对该变量的读操作。

- 多线程的启动规则：Thread对象的start方法happen-before该线程run方法中的任何一个动作，包括在其中启动的任何子线程。 （可以在一个线程中启动另一个线程使其作为当前线程的子线程使用，即可以在父线程的 run 方法中启动另一个线程，则子线程在执行其 run 方法前可以看到父线程在执行 start 方法前的所有操作结果）保证父线程所作的一切对子线程都是可见的。

- 多线程的终正规则：一个线程启动了一个子线程，并且调用了子线程的join方法则该线程会等待其子线程结束，那么当子线程结束后，父线程的接下来的所有操作都可以看到子线程run方法中的执行结果。

- 线程的中断规则：可以调用 interrupt 方法来中断线程，这个调用 happen-before 对该线程中断的检查(isInterrupted) 。



### CountDownLatch

Thread 类中的 join 方法在某种程度上实现：等另一个线程 die 之后该服务才进行执行，但是如果只想是：那个线程启动之后将主要内容都执行之后该主线程即启动，同时原来的线程可以继续往下执行。

主要作用：通过主线程创建几个子线程，然后对应的子线程都执行完之后，主线程才继续往下执行。

CountDownLatch 的 JavaDoc 分析（自行看）

主要：一种同步辅助工具，允许一个或多个线程等待一组在其他线程中执行的操作完成。

测试程序：

```java
package com.gjxaiou.countDownLatch;

import java.util.concurrent.CountDownLatch;
import java.util.stream.IntStream;

/**
 * 三个子任务都完成则主任务可以继续执行
 */
public class MyTest1 {
    public static void main(String[] args) {
        // 参数表示实际执行子任务的数量，该值传给了 countDownLatch 中的一个计数器
        CountDownLatch countDownLatch = new CountDownLatch(3);
        // 创建三个线程
        IntStream.range(0,3).forEach(i -> new Thread(() -> {
            try {
                Thread.sleep(2000);
                System.out.println("hello");
            }catch (InterruptedException ex){
                ex.printStackTrace();
            }finally {
                // 每执行一次 countDown() 方法，则 countDownLatch 中的计数器的值原子性减一
                // 如果放在 try 中，则如其他代码抛出异常则不再减一，导致所有调用 await 的方法的主线程一直处于等待状态无法执行
                countDownLatch.countDown();
            }
        }).start());

        System.out.println("启动子线程完毕");


        try {
            // 调用 await() 方法时会检查 countDownLatch 对象中的计数器值是否为 0，如果为 0 则 await 方法立刻返回。如果不为 0 则调用
            // await 方法的线程会进入阻塞队列中，等待计数器为 0 之后唤醒所有等待队列中的线程然后执行。
            countDownLatch.await();
        } catch (InterruptedException exception) {
            exception.printStackTrace();
        }

        System.out.println("主线程执行完毕");

    }

}
```

输出结果为：

```java
启动子线程完毕
hello
hello
hello
主线程执行完毕
```

针对 CountDownLatch 的源码分析，主要为 await 方法

```java
/*
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/*
 *
 *
 *
 *
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;

/**
 * 一种同步辅助工具，允许一个或多个线程等待一组在其他线程中执行的操作完成。
 * A synchronization aid that allows one or more threads to wait until
 * a set of operations being performed in other threads completes.
 *
 * <p>A {@code CountDownLatch} is initialized with a given <em>count</em>.
 * The {@link #await await} methods block until the current count reaches
 * zero due to invocations of the {@link #countDown} method, after which
 * all waiting threads are released and any subsequent invocations of
 * {@link #await await} return immediately.  This is a one-shot phenomenon
 * -- the count cannot be reset.  If you need a version that resets the
 * count, consider using a {@link CyclicBarrier}.
 *
 * <p>A {@code CountDownLatch} is a versatile synchronization tool
 * and can be used for a number of purposes.  A
 * {@code CountDownLatch} initialized with a count of one serves as a
 * simple on/off latch, or gate: all threads invoking {@link #await await}
 * wait at the gate until it is opened by a thread invoking {@link
 * #countDown}.  A {@code CountDownLatch} initialized to <em>N</em>
 * can be used to make one thread wait until <em>N</em> threads have
 * completed some action, or some action has been completed N times.
 *
 * <p>A useful property of a {@code CountDownLatch} is that it
 * doesn't require that threads calling {@code countDown} wait for
 * the count to reach zero before proceeding, it simply prevents any
 * thread from proceeding past an {@link #await await} until all
 * threads could pass.
 *
 * <p><b>Sample usage:</b> Here is a pair of classes in which a group
 * of worker threads use two countdown latches:
 * <ul>
 * <li>The first is a start signal that prevents any worker from proceeding
 * until the driver is ready for them to proceed;
 * <li>The second is a completion signal that allows the driver to wait
 * until all workers have completed.
 * </ul>
 *
 *  <pre> {@code
 * class Driver { // ...
 *   void main() throws InterruptedException {
 *     CountDownLatch startSignal = new CountDownLatch(1);
 *     CountDownLatch doneSignal = new CountDownLatch(N);
 *
 *     for (int i = 0; i < N; ++i) // create and start threads
 *       new Thread(new Worker(startSignal, doneSignal)).start();
 *
 *     doSomethingElse();            // don't let run yet
 *     startSignal.countDown();      // let all threads proceed
 *     doSomethingElse();
 *     doneSignal.await();           // wait for all to finish
 *   }
 * }
 *
 * class Worker implements Runnable {
 *   private final CountDownLatch startSignal;
 *   private final CountDownLatch doneSignal;
 *   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
 *     this.startSignal = startSignal;
 *     this.doneSignal = doneSignal;
 *   }
 *   public void run() {
 *     try {
 *       startSignal.await();
 *       doWork();
 *       doneSignal.countDown();
 *     } catch (InterruptedException ex) {} // return;
 *   }
 *
 *   void doWork() { ... }
 * }}</pre>
 *
 * <p>Another typical usage would be to divide a problem into N parts,
 * describe each part with a Runnable that executes that portion and
 * counts down on the latch, and queue all the Runnables to an
 * Executor.  When all sub-parts are complete, the coordinating thread
 * will be able to pass through await. (When threads must repeatedly
 * count down in this way, instead use a {@link CyclicBarrier}.)
 *
 *  <pre> {@code
 * class Driver2 { // ...
 *   void main() throws InterruptedException {
 *     CountDownLatch doneSignal = new CountDownLatch(N);
 *     Executor e = ...
 *
 *     for (int i = 0; i < N; ++i) // create and start threads
 *       e.execute(new WorkerRunnable(doneSignal, i));
 *
 *     doneSignal.await();           // wait for all to finish
 *   }
 * }
 *
 * class WorkerRunnable implements Runnable {
 *   private final CountDownLatch doneSignal;
 *   private final int i;
 *   WorkerRunnable(CountDownLatch doneSignal, int i) {
 *     this.doneSignal = doneSignal;
 *     this.i = i;
 *   }
 *   public void run() {
 *     try {
 *       doWork(i);
 *       doneSignal.countDown();
 *     } catch (InterruptedException ex) {} // return;
 *   }
 *
 *   void doWork() { ... }
 * }}</pre>
 *
 * <p>Memory consistency effects: Until the count reaches
 * zero, actions in a thread prior to calling
 * {@code countDown()}
 * <a href="package-summary.html#MemoryVisibility"><i>happen-before</i></a>
 * actions following a successful return from a corresponding
 * {@code await()} in another thread.
 *
 * @since 1.5
 * @author Doug Lea
 */
public class CountDownLatch {
    /**
     * Synchronization control For CountDownLatch.
     * Uses AQS state to represent count.
     */
    private static final class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 4982264981922014374L;

        Sync(int count) {
            setState(count);
        }

        int getCount() {
            return getState();
        }

        protected int tryAcquireShared(int acquires) {
            // getState 即获取计数器的值
            return (getState() == 0) ? 1 : -1;
        }

        protected boolean tryReleaseShared(int releases) {
            // 将计数器的值每次减一，当归零之后发出 signal
            // Decrement count; signal when transition to zero
            for (;;) {
                // 获取计数器的值
                int c = getState();
                if (c == 0)
                    // 当前计数器已经归零了，不能再减了，直接返回
                    return false;
                // 如果不为 0
                int nextc = c-1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0;
            }
        }
    }

    private final Sync sync;

    /**
     * Constructs a {@code CountDownLatch} initialized with the given count.
     *
     * @param count the number of times {@link #countDown} must be invoked
     *        before threads can pass through {@link #await}
     * @throws IllegalArgumentException if {@code count} is negative
     */
    public CountDownLatch(int count) {
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);
    }

    /**
     *  await 方法会导致当前详细进入等待状态，直到 latch 减到 0 或者线程被中断了。
     * Causes the current thread to wait until the latch has counted down to
     * zero, unless the thread is {@linkplain Thread#interrupt interrupted}.
     *
     * <p>If the current count is zero then this method returns immediately.
     *
     * <p>If the current count is greater than zero then the current
     * thread becomes disabled for thread scheduling purposes and lies
     * dormant until one of two things happen:
     * <ul>
     * <li>The count reaches zero due to invocations of the
     * {@link #countDown} method; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts}
     * the current thread.
     * </ul>
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while waiting,
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared.
     *
     * @throws InterruptedException if the current thread is interrupted
     *         while waiting
     */
    public void await() throws InterruptedException {
        // 调用 acquireSharedInterruptibly 方法，其中 1 的值无所谓多少，只是为了适配 AQS 方法必须有参数。该方法实现会判断
        // if (tryAcquireShared(arg) < 0)，内部实现为
        sync.acquireSharedInterruptibly(1);
    }

    /**
     * 主要是防止计数器一直减不到 0 导致主线程一直阻塞，重载版本中可以设置一个超时时间，过了超时时间就不再等待了。
     *
     * Causes the current thread to wait until the latch has counted down to
     * zero, unless the thread is {@linkplain Thread#interrupt interrupted},
     * or the specified waiting time elapses.
     *
     * <p>If the current count is zero then this method returns immediately
     * with the value {@code true}.
     *
     * <p>If the current count is greater than zero then the current
     * thread becomes disabled for thread scheduling purposes and lies
     * dormant until one of three things happen:
     * <ul>
     * <li>The count reaches zero due to invocations of the
     * {@link #countDown} method; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts}
     * the current thread; or
     * <li>The specified waiting time elapses.
     * </ul>
     *
     * <p>If the count reaches zero then the method returns with the
     * value {@code true}.
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while waiting,
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared.
     *
     * <p>If the specified waiting time elapses then the value {@code false}
     * is returned.  If the time is less than or equal to zero, the method
     * will not wait at all.
     *
     * @param timeout the maximum time to wait
     * @param unit the time unit of the {@code timeout} argument
     * @return {@code true} if the count reached zero and {@code false}
     *         if the waiting time elapsed before the count reached zero
     * @throws InterruptedException if the current thread is interrupted
     *         while waiting
     */
    public boolean await(long timeout, TimeUnit unit)
            throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }

    /**
     * Decrements the count of the latch, releasing all waiting threads if
     * the count reaches zero.
     *
     * <p>If the current count is greater than zero then it is decremented.
     * If the new count is zero then all waiting threads are re-enabled for
     * thread scheduling purposes.
     *
     * <p>If the current count equals zero then nothing happens.
     */
    public void countDown() {
        sync.releaseShared(1);
    }

    /**
     * Returns the current count.
     *
     * <p>This method is typically used for debugging and testing purposes.
     *
     * @return the current count
     */
    public long getCount() {
        return sync.getCount();
    }

    /**
     * Returns a string identifying this latch, as well as its state.
     * The state, in brackets, includes the String {@code "Count ="}
     * followed by the current count.
     *
     * @return a string identifying this latch, as well as its state
     */
    public String toString() {
        return super.toString() + "[Count = " + sync.getCount() + "]";
    }
}
```



### cyclicBarrier

作用：若干个线程相互等待，都到达之后一起继续执行。各个线程之间没有主次之分。

其和countDownLatch最大的区别就是CyclicBarrier是可以重复使用的。因为 countDownLatch 中的计数器归零之后就不动了，但是 CyclicBarrier 中的计数器每次满足数量的线程执行后，计数器会重置为原来状态，即可以实现每几个线程一起执行。

示例代码：

```java
package com.gjxaiou.cyclicBarrier;

import java.util.Random;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class MyTest1 {
    public static void main(String[] args) {

        // 参数表示参与方，即只有 3 个线程都到达了屏障才能继续往下执行
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);

        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                try {
                    // 每个线程随机睡眠一段时间
                    Thread.sleep((int) (Math.random() * 2000));

                    // 产生一个 0 ~ 500 之间的整数
                    int randomInt = new Random().nextInt(500);
                    System.out.println("hello" + randomInt);

                    // 检查一下是不是满足都到屏障了
                    // await 首先会等待屏障前是不是已经有三个线程了，如果没有则在屏障前等待。但是如果是第三个线程在调用 await 方法的一刹那会发现包括自己共有
                    // 3 个线程了则通知所有线程一起往下运行。当然唤醒的时候线程由先后顺序，所以每次执行 world + 随机数可能先后顺序都不一样。
                    cyclicBarrier.await();

                    System.out.println("world" + randomInt);

                } catch (InterruptedException | BrokenBarrierException exception) {
                    exception.printStackTrace();
                }
            }).start();
        }
    }
}
```

输出结果：

```java
hello423
hello403
hello143
world143
world423
world403
```

CyclicBarrier 的重用性示例：

共有两轮，然后每轮必须有 3 个线程到达屏障之后才能继续往下执行

```java
package com.gjxaiou.cyclicBarrier;

import java.util.Random;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class MyTest2 {

    public static void main(String[] args) {

        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);
        for (int n = 0; n < 2; n++) {
            for (int i = 0; i < 3; i++) {
                new Thread(() -> {
                    try {
                        Thread.sleep((int) (Math.random() * 2000));
                        int randomInt = new Random().nextInt(500);
                        System.out.println("hello" + randomInt);

                        cyclicBarrier.await();

                        System.out.println("world" + randomInt);
                    } catch (InterruptedException | BrokenBarrierException exception) {
                        exception.printStackTrace();
                    }
                }).start();
            }
        }
    }
}
```

输出结果：每 6 个是一个阶段。

```java
hello169
hello351
hello328
world328
world169
world351
hello16
hello336
hello448
world448
world16
world336
```

CyclicBarrier 的另一个构造函数为：

```java
public CyclicBarrier(int parties, Runnable barrierAction) {
```

其中第二个参数是一个 Runnable 实例，即当 parties 中的最后一个线程到达屏障时候会触发一次该操作。例如将上述第一个代码的构造换为：

```java
 CyclicBarrier cyclicBarrier = new CyclicBarrier(3, () ->{
            System.out.println("hello  world  GJXAIOU");
        });
```

则输出结果为：

```java
hello427
hello296
hello241
hello  world  GJXAIOU
world241
world427
world296
```



CyclicBarrier 的源码分析

#### 关于cyclicBarrier的底层执行流程

- 初始化 CyclicBarrier 中的各种成员变量，包括 parties、 count 以及 Runnable (可选)

- 当调用await方法时，底层会先检查计数器是否已经归零，如果是的话，那么就首先执行可选的Runnable,接下来开始下一个generation;

- 在下一个分代中，将会重置count值为parties,并且创建新的Generation实例。

- 同时会调用 Condition 的 signalAll 方法，唤醒所有在屏障前面等待的线程，让其开始继续执行。

- 如果计数器没有归零，那么当前的调用线程将会通过 Condition 的 await 方法，在屏障前进行等待。

- 以上所有执行流程均在 lock 锁的控制范围内，不会出现并发情况。（公用的数据是 count，通过 lock 来实现和避免多线程的情况）。

```java
package java.util.concurrent;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * A synchronization aid that allows a set of threads to all wait for
 * each other to reach a common barrier point.  CyclicBarriers are
 * useful in programs involving a fixed sized party of threads that
 * must occasionally wait for each other. The barrier is called
 * <em>cyclic</em> because it can be re-used after the waiting threads
 * are released.
 *
 * <p>A {@code CyclicBarrier} supports an optional {@link Runnable} command
 * that is run once per barrier point, after the last thread in the party
 * arrives, but before any threads are released.
 * This <em>barrier action</em> is useful
 * for updating shared-state before any of the parties continue.
 *
 * <p><b>Sample usage:</b> Here is an example of using a barrier in a
 * parallel decomposition design:
 *
 *  <pre> {@code
 * class Solver {
 *   final int N;
 *   final float[][] data;
 *   final CyclicBarrier barrier;
 *
 *   class Worker implements Runnable {
 *     int myRow;
 *     Worker(int row) { myRow = row; }
 *     public void run() {
 *       while (!done()) {
 *         processRow(myRow);
 *
 *         try {
 *           barrier.await();
 *         } catch (InterruptedException ex) {
 *           return;
 *         } catch (BrokenBarrierException ex) {
 *           return;
 *         }
 *       }
 *     }
 *   }
 *
 *   public Solver(float[][] matrix) {
 *     data = matrix;
 *     N = matrix.length;
 *     Runnable barrierAction =
 *       new Runnable() { public void run() { mergeRows(...); }};
 *     barrier = new CyclicBarrier(N, barrierAction);
 *
 *     List<Thread> threads = new ArrayList<Thread>(N);
 *     for (int i = 0; i < N; i++) {
 *       Thread thread = new Thread(new Worker(i));
 *       threads.add(thread);
 *       thread.start();
 *     }
 *
 *     // wait until done
 *     for (Thread thread : threads)
 *       thread.join();
 *   }
 * }}</pre>
 *
 * Here, each worker thread processes a row of the matrix then waits at the
 * barrier until all rows have been processed. When all rows are processed
 * the supplied {@link Runnable} barrier action is executed and merges the
 * rows. If the merger
 * determines that a solution has been found then {@code done()} will return
 * {@code true} and each worker will terminate.
 *
 * <p>If the barrier action does not rely on the parties being suspended when
 * it is executed, then any of the threads in the party could execute that
 * action when it is released. To facilitate this, each invocation of
 * {@link #await} returns the arrival index of that thread at the barrier.
 * You can then choose which thread should execute the barrier action, for
 * example:
 *  <pre> {@code
 * if (barrier.await() == 0) {
 *   // log the completion of this iteration
 * }}</pre>
 *
 * <p>The {@code CyclicBarrier} uses an all-or-none breakage model
 * for failed synchronization attempts: If a thread leaves a barrier
 * point prematurely because of interruption, failure, or timeout, all
 * other threads waiting at that barrier point will also leave
 * abnormally via {@link BrokenBarrierException} (or
 * {@link InterruptedException} if they too were interrupted at about
 * the same time).
 *
 * <p>Memory consistency effects: Actions in a thread prior to calling
 * {@code await()}
 * <a href="package-summary.html#MemoryVisibility"><i>happen-before</i></a>
 * actions that are part of the barrier action, which in turn
 * <i>happen-before</i> actions following a successful return from the
 * corresponding {@code await()} in other threads.
 *
 * @since 1.5
 * @see CountDownLatch
 *
 * @author Doug Lea
 */
public class CyclicBarrier {
    /**
     * 每次屏障被冲破之后就相当于进入了下一个 generation
     * Each use of the barrier is represented as a generation instance.
     * The generation changes whenever the barrier is tripped, or
     * is reset. There can be many generations associated with threads
     * using the barrier - due to the non-deterministic way the lock
     * may be allocated to waiting threads - but only one of these
     * can be active at a time (the one to which {@code count} applies)
     * and all the rest are either broken or tripped.
     * There need not be an active generation if there has been a break
     * but no subsequent reset.
     */
    private static class Generation {
        boolean broken = false;
    }

    /** The lock for guarding barrier entry */
    private final ReentrantLock lock = new ReentrantLock();
    /** Condition to wait on until tripped */
    private final Condition trip = lock.newCondition();
    /** The number of parties */
    private final int parties;
    /* The command to run when tripped */
    private final Runnable barrierCommand;
    /** The current generation */
    private Generation generation = new Generation();

    /**
     * Number of parties still waiting. Counts down from parties to 0
     * on each generation.  It is reset to parties on each new
     * generation or when broken.
     */
    private int count;

    /**
     * Updates state on barrier trip and wakes up everyone.
     * Called only while holding lock.
     */
    private void nextGeneration() {
        // signal completion of last generation
        // 唤醒所有等待的线程
        trip.signalAll();
        // set up next generation
        // count 恢复到初始情况
        count = parties;
        generation = new Generation();
    }

    /**
     * Sets current barrier generation as broken and wakes up everyone.
     * Called only while holding lock.
     */
    private void breakBarrier() {
        generation.broken = true;
        count = parties;
        trip.signalAll();
    }

    /**
     * Main barrier code, covering the various policies.
     */
    private int dowait(boolean timed, long nanos)
            throws InterruptedException, BrokenBarrierException,
            TimeoutException {
        // 获取锁
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            final Generation g = generation;

            if (g.broken)
                throw new BrokenBarrierException();

            if (Thread.interrupted()) {
                breakBarrier();
                throw new InterruptedException();
            }

            int index = --count;
            // index 为 0 则所有线程都到达了屏障前面
            if (index == 0) {  // tripped
                // 是否执行了后面的 Runnable 方法
                boolean ranAction = false;
                // 执行 Runnable 的调用
                try {
                    final Runnable command = barrierCommand;
                    if (command != null)
                        command.run();
                    ranAction = true;
                    // 切换到下一代
                    nextGeneration();
                    return 0;
                } finally {
                    if (!ranAction)
                        breakBarrier();
                }
            }

            // loop until tripped, broken, interrupted, or timed out
            for (;;) {
                try {
                    // 如果没有设置超时时间
                    if (!timed)
                        // trip 是 condition 的实例，等待条件变量 condition 发出 signal 或者 signalAll
                        trip.await();
                    // 设置了超时时间
                    else if (nanos > 0L)
                        nanos = trip.awaitNanos(nanos);
                } catch (InterruptedException ie) {
                    if (g == generation && ! g.broken) {
                        breakBarrier();
                        throw ie;
                    } else {
                        // We're about to finish waiting even if we had not
                        // been interrupted, so this interrupt is deemed to
                        // "belong" to subsequent execution.
                        Thread.currentThread().interrupt();
                    }
                }

                if (g.broken)
                    throw new BrokenBarrierException();

                if (g != generation)
                    return index;

                if (timed && nanos <= 0L) {
                    breakBarrier();
                    throw new TimeoutException();
                }
            }
        } finally {
            lock.unlock();
        }
    }

    /**
     * Creates a new {@code CyclicBarrier} that will trip when the
     * given number of parties (threads) are waiting upon it, and which
     * will execute the given barrier action when the barrier is tripped,
     * performed by the last thread entering the barrier.
     *
     * @param parties the number of threads that must invoke {@link #await}
     *        before the barrier is tripped
     * @param barrierAction the command to execute when the barrier is
     *        tripped, or {@code null} if there is no action
     * @throws IllegalArgumentException if {@code parties} is less than 1
     */
    public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties <= 0) throw new IllegalArgumentException();
        this.parties = parties;
        // count 为仍然在等待的参与方数量，扮演计数器的作用。当一个周期结束开始新的周期的时候，count 重新被赋值为 parties。parties 为 final
        // 不可变，但是 count 可变。
        this.count = parties;
        this.barrierCommand = barrierAction;
    }

    /**
     * Creates a new {@code CyclicBarrier} that will trip when the
     * given number of parties (threads) are waiting upon it, and
     * does not perform a predefined action when the barrier is tripped.
     *
     * @param parties the number of threads that must invoke {@link #await}
     *        before the barrier is tripped
     * @throws IllegalArgumentException if {@code parties} is less than 1
     */
    public CyclicBarrier(int parties) {
        this(parties, null);
    }

    /**
     * Returns the number of parties required to trip this barrier.
     *
     * @return the number of parties required to trip this barrier
     */
    public int getParties() {
        return parties;
    }

    /**
     * 等待，直到所有的参与方均在屏障前调用了 await 方法。
     * Waits until all {@linkplain #getParties parties} have invoked
     * {@code await} on this barrier.
     *
     * 如果当前线程不是最后一个到达的，那么其不会被调度，直到下面情况之一发生：
     * 最后一个线程到达
     * 其它线程中断了当前线程
     * 其它线程中断了其中一个已经等待的线程
     * 其它线程上等待通过该屏障的等待时间过了
     * 其它线程在该屏障上重置了
     * <p>If the current thread is not the last to arrive then it is
     * disabled for thread scheduling purposes and lies dormant until
     * one of the following things happens:
     * <ul>
     * <li>The last thread arrives; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts}
     * the current thread; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts}
     * one of the other waiting threads; or
     * <li>Some other thread times out while waiting for barrier; or
     * <li>Some other thread invokes {@link #reset} on this barrier.
     * </ul>
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while waiting
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared.
     *
     * <p>If the barrier is {@link #reset} while any thread is waiting,
     * or if the barrier {@linkplain #isBroken is broken} when
     * {@code await} is invoked, or while any thread is waiting, then
     * {@link BrokenBarrierException} is thrown.
     *
     * <p>If any thread is {@linkplain Thread#interrupt interrupted} while waiting,
     * then all other waiting threads will throw
     * {@link BrokenBarrierException} and the barrier is placed in the broken
     * state.
     *
     * <p>If the current thread is the last thread to arrive, and a
     * non-null barrier action was supplied in the constructor, then the
     * current thread runs the action before allowing the other threads to
     * continue.
     * If an exception occurs during the barrier action then that exception
     * will be propagated in the current thread and the barrier is placed in
     * the broken state.
     *
     * @return the arrival index of the current thread, where index
     *         {@code getParties() - 1} indicates the first
     *         to arrive and zero indicates the last to arrive
     * @throws InterruptedException if the current thread was interrupted
     *         while waiting
     * @throws BrokenBarrierException if <em>another</em> thread was
     *         interrupted or timed out while the current thread was
     *         waiting, or the barrier was reset, or the barrier was
     *         broken when {@code await} was called, or the barrier
     *         action (if present) failed due to an exception
     */
    public int await() throws InterruptedException, BrokenBarrierException {
        try {
            return dowait(false, 0L);
        } catch (TimeoutException toe) {
            throw new Error(toe); // cannot happen
        }
    }

    /**
     * Waits until all {@linkplain #getParties parties} have invoked
     * {@code await} on this barrier, or the specified waiting time elapses.
     *
     * <p>If the current thread is not the last to arrive then it is
     * disabled for thread scheduling purposes and lies dormant until
     * one of the following things happens:
     * <ul>
     * <li>The last thread arrives; or
     * <li>The specified timeout elapses; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts}
     * the current thread; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts}
     * one of the other waiting threads; or
     * <li>Some other thread times out while waiting for barrier; or
     * <li>Some other thread invokes {@link #reset} on this barrier.
     * </ul>
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while waiting
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared.
     *
     * <p>If the specified waiting time elapses then {@link TimeoutException}
     * is thrown. If the time is less than or equal to zero, the
     * method will not wait at all.
     *
     * <p>If the barrier is {@link #reset} while any thread is waiting,
     * or if the barrier {@linkplain #isBroken is broken} when
     * {@code await} is invoked, or while any thread is waiting, then
     * {@link BrokenBarrierException} is thrown.
     *
     * <p>If any thread is {@linkplain Thread#interrupt interrupted} while
     * waiting, then all other waiting threads will throw {@link
     * BrokenBarrierException} and the barrier is placed in the broken
     * state.
     *
     * <p>If the current thread is the last thread to arrive, and a
     * non-null barrier action was supplied in the constructor, then the
     * current thread runs the action before allowing the other threads to
     * continue.
     * If an exception occurs during the barrier action then that exception
     * will be propagated in the current thread and the barrier is placed in
     * the broken state.
     *
     * @param timeout the time to wait for the barrier
     * @param unit the time unit of the timeout parameter
     * @return the arrival index of the current thread, where index
     *         {@code getParties() - 1} indicates the first
     *         to arrive and zero indicates the last to arrive
     * @throws InterruptedException if the current thread was interrupted
     *         while waiting
     * @throws TimeoutException if the specified timeout elapses.
     *         In this case the barrier will be broken.  如果发生超时时间，屏障 Barrier 就会被破坏，当 Barrier
     *         被破坏就会触发下面 BrokenBarrierException 异常。
     * @throws BrokenBarrierException if <em>another</em> thread was
     *         interrupted or timed out while the current thread was
     *         waiting, or the barrier was reset, or the barrier was broken
     *         when {@code await} was called, or the barrier action (if
     *         present) failed due to an exception 当当前的线程正在等待的时候另一个线程超时了，
     */
    public int await(long timeout, TimeUnit unit)
            throws InterruptedException,
            BrokenBarrierException,
            TimeoutException {
        return dowait(true, unit.toNanos(timeout));
    }

    /**
     * Queries if this barrier is in a broken state.
     *
     * @return {@code true} if one or more parties broke out of this
     *         barrier due to interruption or timeout since
     *         construction or the last reset, or a barrier action
     *         failed due to an exception; {@code false} otherwise.
     */
    public boolean isBroken() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return generation.broken;
        } finally {
            lock.unlock();
        }
    }

    /**
     * Resets the barrier to its initial state.  If any parties are
     * currently waiting at the barrier, they will return with a
     * {@link BrokenBarrierException}. Note that resets <em>after</em>
     * a breakage has occurred for other reasons can be complicated to
     * carry out; threads need to re-synchronize in some other way,
     * and choose one to perform the reset.  It may be preferable to
     * instead create a new barrier for subsequent use.
     */
    public void reset() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            breakBarrier();   // break the current generation
            nextGeneration(); // start a new generation
        } finally {
            lock.unlock();
        }
    }

    /**
     * Returns the number of parties currently waiting at the barrier.
     * This method is primarily useful for debugging and assertions.
     *
     * @return the number of parties currently blocked in {@link #await}
     */
    public int getNumberWaiting() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return parties - count;
        } finally {
            lock.unlock();
        }
    }
}
```



针对 await 构造方法中设置超时时间：`public int await(long timeout, TimeUnit unit)`，即将每个线程的等待超时时间进行设置，示例如下：

```java
package com.gjxaiou.cyclicBarrier;

import java.util.Random;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class MyTest3 {

    public static void main(String[] args) {

        CyclicBarrier cyclicBarrier = new CyclicBarrier(3, () -> {
            System.out.println("hello  world  GJXAIOU");
        });
        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                try {
                    Thread.sleep((int) (Math.random() * 2000));
                    int randomInt = new Random().nextInt(500);
                    System.out.println("hello" + randomInt);

                    cyclicBarrier.await(20, TimeUnit.MILLISECONDS);

                    System.out.println("world" + randomInt);
                } catch (InterruptedException | BrokenBarrierException exception) {
                    exception.printStackTrace();
                } catch (TimeoutException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

执行结果为：

```java
hello104
java.util.concurrent.TimeoutException
	at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257)
	at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)
	at com.gjxaiou.cyclicBarrier.MyTest3.lambda$main$1(MyTest3.java:23)
	at java.lang.Thread.run(Thread.java:748)
hello475
java.util.concurrent.BrokenBarrierException
	at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)
	at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)
	at com.gjxaiou.cyclicBarrier.MyTest3.lambda$main$1(MyTest3.java:23)
	at java.lang.Thread.run(Thread.java:748)
hello272
java.util.concurrent.BrokenBarrierException
	at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)
	at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)
	at com.gjxaiou.cyclicBarrier.MyTest3.lambda$main$1(MyTest3.java:23)
	at java.lang.Thread.run(Thread.java:748)
```

具体异常原因可以看上面的 CyclicBarrier 中的 await 方法分析；

CountDownLatch 超时了则主线程正常执行，而 CyclicBarrier 会抛出异常，因为 CyclicBarrier 各个线程之间关系平等，一般都到达之后将他们的数据进行一个整合，有一个超时则这些线程汇聚的值就不准确了，本质上就没用了。



### CAS(Compare And Swap)

#### 6.1 什么是CAS

- synchronized 关键字与 Lock 等锁机制都是悲观锁：无论做何种操作，首先都需要先上锁，接下来再去执行后续操作，从而确保了接下来的所有 操作都是由当前这个线程来执行的。

- 乐观锁：线程在操作之前不会做任何预先的处理，而是直接去执行；当在最后执行变量更新的时候， 当前线程需要有一种机制来确保当前被操作的变量是没有被其他线程修改的。CAS 是乐观锁的一种极为重要的实现方式。

 

比较与交换：这是一个不断循环的过程，一直到变量值被修改成功为止。CAS 本身是由硬件指令来提供支持的，换句话说，硬件中是通过一个原子指令来实现比较与交换的；因此，CAS 可以确保变量操作的原子性。

示例代码：计数器

```java
package com.gjxaiou.cas;

public class MyTest1 {
    private int count;

    public int getCount() {
        return count;
    }

    public void increaseCount() {
        // 这行在多线程运行时会出问题，通过字节码进行分析
        // 读取 =》 修改 =》 写入：这三个操作并非原子操作
        ++this.count;
    }
}
```

对应的字节码为：

```java
E:\Program\Project\NotesProject\JavaConcurrency\ProficientInJavaConcurrency\src\main\java\com\gjxaiou\cas>javap -v MyTest1
警告: 二进制文件MyTest1包含com.gjxaiou.cas.MyTest1
Classfile /E:/Program/Project/NotesProject/JavaConcurrency/ProficientInJavaConcurrency/src/main/java/com/gjxaiou/cas/MyTest1.class
  Last modified 2021-3-21; size 363 bytes
  MD5 checksum e802d2bde735dc5b83f98a2355d03dd1
  Compiled from "MyTest1.java"
public class com.gjxaiou.cas.MyTest1
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#16         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#17         // com/gjxaiou/cas/MyTest1.count:I
   #3 = Class              #18            // com/gjxaiou/cas/MyTest1
   #4 = Class              #19            // java/lang/Object
   #5 = Utf8               count
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               getCount
  #12 = Utf8               ()I
  #13 = Utf8               increaseCount
  #14 = Utf8               SourceFile
  #15 = Utf8               MyTest1.java
  #16 = NameAndType        #7:#8          // "<init>":()V
  #17 = NameAndType        #5:#6          // count:I
  #18 = Utf8               com/gjxaiou/cas/MyTest1
  #19 = Utf8               java/lang/Object
{
  public com.gjxaiou.cas.MyTest1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 4: 0

  public int getCount();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field count:I
         4: ireturn
      LineNumberTable:
        line 8: 0

  public void increaseCount();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: aload_0
         1: dup
         2: getfield      #2                 // Field count:I // 获取成员变量，然后放入栈顶
         5: iconst_1                          // 将数字 1 放到当前栈的栈顶
         6: iadd                              // 将当前栈栈顶和下面一个元素进行求和
         7: putfield      #2                  // Field count:I // 将求和之后结果放到栈顶
        10: return
      LineNumberTable:
        line 13: 0
        line 14: 10
}
SourceFile: "MyTest1.java"s
```

保证正确性，方式一将该读和写方法加上 synchronized 关键字。缺点就是：读方法不应该只能当线程访问，但是加上 synchronized 之后也只能单个线程访问。

```java
package com.gjxaiou.cas;

public class MyTest1 {
    private int count;

    public synchronized int getCount() {
        return count;
    }

    public synchronized void increaseCount() {
        // 这行在多线程运行时会出问题，通过字节码进行分析
        ++this.count;
    }
}
```

为什么在读取操作前面也需要加上 synchronized 关键字：

因为 synchronized 除了进行上锁进行资源隔离的作用外，还可以实现变量的可见性，通过在两个方法上都加入 synchronized 关键字，即在 `increaseCount` 方法中完成 ++this.count 并且写入的时候，根据 happen-before 原则，写入值会立刻刷新到高速缓存上。即如果不在 `getCount()` 方法上加上 synchronized 修饰则其他线程获取到的可能是旧的值。

CAS 代码示例：

```java
package com.gjxaiou.cas;

import java.util.concurrent.atomic.AtomicInteger;

public class MyTest2 {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(5);

        System.out.println(atomicInteger.get());
        // 将值设置为 8 并且返回旧的值
        System.out.println(atomicInteger.getAndSet(8));
        System.out.println(atomicInteger.get());
        // 将值自增 1 然后返回旧值
        System.out.println(atomicInteger.getAndIncrement());
        System.out.println(atomicInteger.get());
    }
}
```

输出结果为：

```java
5
5
8
8
9
```

针对 atomicInteger 的源码分析为：

```java
// 其中主要分析 getAndSet 方法
public final int getAndSet(int newValue) {
    // 三个参数含义：当前被操作的 AtomicInteger 对象，操作的值在 AtomicInteger 对象中的内存偏移位置，将要被写入的新的值。
    return unsafe.getAndSetInt(this, valueOffset, newValue);
}

// OpenJDK 中的 unsafe 类中的 getAndSetInt 方法为
public final int getAndSetInt(Object o, long offset, int newValue) {
    int v;
    do {
        v = getIntVolatile(o, offset);
        // compareAndSwapInt 是 Native 方法，是由 C++ 实现的，参数为：要操作对象，即 AtomicInteger 的引用，映射到 C++
        // 就是其内存位置；要操作的变量在当前对象中的内存偏移位置；变量预期的值；即将要写入的新的值
    } while (!compareAndSwapInt(o, offset, v, newValue));
    return v;
}
```

[Unsafe 类分析](https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html)





#### 6.2 CAS执行过程

对于CAS来说，其操作数主要涉及到如下三个:

- 需要被操作的内存值 v

- 需要进行比较的值 A

- 需要进行写入的值 B

只有当 V==A 的时候，CAS 才会通过原子操作的手段来将 v 的值更新为 B。

 

关于CAS的限制或是问题: .

- 循环开销问题：本质上通过 do-while 循环实现，并发量大的情况下会导致线程一直自旋 

- 只能保证一个变量的原子操作：可以通过 AtomicReference 来实现对多个变量的原子操作 ，即将多个变量放在同一个对象中进行原子操作。

- ABA 问题：采用时间戳或者版本号来做标记，从执行的结果是没有错但是语义出现了错误。可以看一下 TimeStampLock 源码。



### Future 模式

简单来说就是一个线程来执行未来的任务，但是在使用 get 方法的时候主线程会出现阻塞的过程。

缺点就是 get 时候可能阻塞。

Future 源码分析：

```java


package java.util.concurrent;

/**
 * Future 表示异步计算的结果。提供了检查计算是否完成、是否等待其完成以及获取计算结果的方法。只有在计算完成时，才能使用方法 get
 *获取结果，必要时阻塞，直到它准备好为止。取消由{@code cancel}方法执行。提供了其他方法来确定任务是正常完成还是取消。一旦计算完成，就不能取消计算。如果为了可取消性而想使用
 * {@code Future}，但不提供可用的结果，那么可以使用{@code Future<？>}并返回{@code null}，作为基础任务的结果
 */

/**
 * A {@code Future} represents the result of an asynchronous
 * computation.  Methods are provided to check if the computation is
 * complete, to wait for its completion, and to retrieve the result of
 * the computation.  The result can only be retrieved using method
 * {@code get} when the computation has completed, blocking if
 * necessary until it is ready.  Cancellation is performed by the
 * {@code cancel} method.  Additional methods are provided to
 * determine if the task completed normally or was cancelled. Once a
 * computation has completed, the computation cannot be cancelled.
 * If you would like to use a {@code Future} for the sake
 * of cancellability but not provide a usable result, you can
 * declare types of the form {@code Future<?>} and
 * return {@code null} as a result of the underlying task.
 *
 * <p>
 * <b>Sample Usage</b> (Note that the following classes are all
 * made-up.)
 * <pre> {@code
 * interface ArchiveSearcher { String search(String target); }
 * class App {
 *   ExecutorService executor = ...
 *   ArchiveSearcher searcher = ...
 *   void showSearch(final String target)
 *       throws InterruptedException {
 *     Future<String> future
 *       = executor.submit(new Callable<String>() {
 *         public String call() {
 *             return searcher.search(target);
 *         }});
 *     displayOtherThings(); // do other things while searching
 *     try {
 *       displayText(future.get()); // use future
 *     } catch (ExecutionException ex) { cleanup(); return; }
 *   }
 * }}</pre>
 * <p>
 * The {@link FutureTask} class is an implementation of {@code Future} that
 * implements {@code Runnable}, and so may be executed by an {@code Executor}.
 * For example, the above construction with {@code submit} could be replaced by:
 * <pre> {@code
 * FutureTask<String> future =
 *   new FutureTask<String>(new Callable<String>() {
 *     public String call() {
 *       return searcher.search(target);
 *   }});
 * executor.execute(future);}</pre>
 *
 * <p>Memory consistency effects: Actions taken by the asynchronous computation
 * <a href="package-summary.html#MemoryVisibility"> <i>happen-before</i></a>
 * actions following the corresponding {@code Future.get()} in another thread.
 *
 * @param <V> The result type returned by this Future's {@code get} method
 * @author Doug Lea
 * @see FutureTask
 * @see Executor
 * @since 1.5
 */
public interface Future<V> {

    /**
     * Attempts to cancel execution of this task.  This attempt will
     * fail if the task has already completed, has already been cancelled,
     * or could not be cancelled for some other reason. If successful,
     * and this task has not started when {@code cancel} is called,
     * this task should never run.  If the task has already started,
     * then the {@code mayInterruptIfRunning} parameter determines
     * whether the thread executing this task should be interrupted in
     * an attempt to stop the task.
     *
     * <p>After this method returns, subsequent calls to {@link #isDone} will
     * always return {@code true}.  Subsequent calls to {@link #isCancelled}
     * will always return {@code true} if this method returned {@code true}.
     *
     * @param mayInterruptIfRunning {@code true} if the thread executing this
     *                              task should be interrupted; otherwise, in-progress tasks are
     *                              allowed
     *                              to complete
     * @return {@code false} if the task could not be cancelled,
     * typically because it has already completed normally;
     * {@code true} otherwise
     */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
     * Returns {@code true} if this task was cancelled before it completed
     * normally.
     *
     * @return {@code true} if this task was cancelled before it completed
     */
    boolean isCancelled();

    /**
     * Returns {@code true} if this task completed.
     * <p>
     * Completion may be due to normal termination, an exception, or
     * cancellation -- in all of these cases, this method will return
     * {@code true}.
     *
     * @return {@code true} if this task completed
     */
    boolean isDone();

    /**
     * 当任务尚未完成，则 get 方法会一直等待
     * Waits if necessary for the computation to complete, and then
     * retrieves its result.
     *
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException    if the computation threw an
     *                               exception
     * @throws InterruptedException  if the current thread was interrupted
     *                               while waiting
     */
    V get() throws InterruptedException, ExecutionException;

    /**
     * Waits if necessary for at most the given time for the computation
     * to complete, and then retrieves its result, if available.
     *
     * @param timeout the maximum time to wait
     * @param unit    the time unit of the timeout argument
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException    if the computation threw an
     *                               exception
     * @throws InterruptedException  if the current thread was interrupted
     *                               while waiting
     * @throws TimeoutException      if the wait timed out
     */
    V get(long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException;
}
```

该接口在使用过程中，常用的实现类为 FutureTask 类。



使用示例：

```java
package com.gjxaiou.future;

import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * 需要 Callable 对象封装任务执行逻辑
 * 用 FutureTask 包装任务
 * 启动一个线程来执行包装后的任务
 * 从主程序中调用 FutureTask 中 get 方法获取执行结果
 */
public class MyTest1 {
    public static void main(String[] args) {
        Callable<Integer> callable = () -> {
            System.out.println("pre execution");
            // 子线程睡眠 5s
            Thread.sleep(5000);
            int randomNumber = new Random().nextInt(500);
            System.out.println("post execution");

            return randomNumber;
        };

        FutureTask futureTask = new FutureTask<Integer>(callable);

        new Thread(futureTask).start();

        System.out.println("thread has started");

        try {
            // 主线程睡眠 2s
            Thread.sleep(2000);
            System.out.println(futureTask.get());
        } catch (InterruptedException exception) {
            exception.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

首先线程启动之后，主流程开始执行，输出 `thread has started`，然后在调用 get  方法时候等待 callable 中执行完成。

```java
thread has started
pre execution   // 这个输出之后等待 3s 后面才出来，因为 2s 之后主线程醒来，执行 get 方法时候需要等待
post execution
43
```

如果将主线程的 get 方法换成带超时时间的，即：

```
// 主线程等待 1s
System.out.println(futureTask.get(1, TimeUnit.MILLISECONDS));
```

则执行结果为：

```java
thread has started
pre execution
java.util.concurrent.TimeoutException
	at java.util.concurrent.FutureTask.get(FutureTask.java:205)
	at com.gjxaiou.future.MyTest2.main(MyTest2.java:34)
post execution
```

主线程会抛出异常，但是不影响子线程正常执行。

### CompletableFuture

保证任务执行的异步性和获取结果的异步性。

这是对 Future 的增强。提供异步获取执行结果。测试代码

```java
package com.gjxaiou.completableFuture;

import java.time.temporal.ValueRange;
import java.util.concurrent.CompletableFuture;

public class MyTest1 {
    public static void main(String[] args) {
        // 体现 CompletableFuture 的 stage 功能  => 对结果进行转换
        String result =
                CompletableFuture.supplyAsync(() -> "hello").thenApplyAsync(value -> value +
                        " world").join();

        System.out.println(result);

        System.out.println("================");

        // 对结果进行消费
        CompletableFuture.supplyAsync(() -> "hello").thenAccept(value -> System.out.println(
                " welcome" + value));

        System.out.println("=================");

        // 两个操作都是异步的，相互独立执行，然后使用 thenCombine 将两个结果进行组合
        String result2 = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
            return "hello";
        }).thenCombine(CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
            return "world";
            // thenCombine 第二个参数为 BiFunction,即输入两个，输出一个，对应下面的结构。本质上是对上面两个返回结果进行合并
        }), (s1, s2) -> s1 + " " + s2).join();

        System.out.println(result2);


        System.out.println("======重要重要========");
        /*
         首先会执行回调  completableFuture.whenComplete 但是因为该线程还在休眠中
         2s，并且该方法非阻塞，因此主线程会继续往下走，所以首先打印“主线程执行完毕”。
         然后主线程在 7s 那里进行了休眠。
         然后 2s 时间过了之后执行的任务执行完了，打印“task finished”
        然后 whenComplete 回调进行执行，打印“执行完成”
         */


        // get 不阻塞
        CompletableFuture completableFuture = CompletableFuture.runAsync(() -> {
            try {
                // 模拟这是一个相对耗时的任务，这里面就是真正要执行的任务
                Thread.sleep(2000);
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
            System.out.println("task finished");
        });

        // 不阻塞主线程主线程。
        completableFuture.whenComplete((t, action) -> System.out.println("执行完成"));

        System.out.println("主线程执行完毕");
        try {
            Thread.sleep(7000);
        } catch (InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
```

执行结果为：

```java
hello world
================
 welcomehello
=================
hello world
======重要重要========
主线程执行完毕
task finished
执行完成
```



### ThreadLocal

本质上，ThreadLocal 是通过空间换取时间，从而实现每个线程中都会有一个变量的副本，这样每个线程就都会操作该副本，从而完全规避了多线程的并发问题。

使用场景：如 web 项目中，用户访问会经过 controller、service、dao 层，如果想实现三层之间的数据共享，一般就是将这个数据作为一个参数，在 controller 调用 service 时候传入，在 service 调用 dao 时候传入。也可以将该变量放入 ThreadLocal 中实现各个方法中的共享。因为 ThreadLocal 是和线程进行绑定的。

ThreadLocal 本身并不持有数据，只作为底层 Entry 对象的 key 而存在。再 Thread 类中持有一个 ThreadLocalMap 的引用，该引用中存在一个 Entry 类型的数组，Entry 类型的数组中的每个 Entry 对象就是我们真正持有的信息，每个 Entry 对象的 key 就是一个对当前 ThreadLocal 对象的弱引用，value 就是通过 ThreadLocal 的 set 方法放入的值。

常用的 get 和 set 方法示例：

```java
package com.gjxaiou.threadLocal;

public class MyTest1 {
    public static void main(String[] args) {
        // 常用的 api 主要就是 get 和 set 方法
        ThreadLocal<String> threadLocal = new ThreadLocal<>();

        threadLocal.set("hello world");
        System.out.println(threadLocal.get());
        // 再次 set 会覆盖原有的值
        threadLocal.set("welcome");
        System.out.println(threadLocal.get());
    }
}
```

针对部分原理解析：`threadLocal.set("hello world");` 不是将 `hello world` 放置到 ThreadLocal 中，而是以 ThreadLocal 对象为 key，`hello world` 为值放置到 ThreadLocalMap 的 Entry 数组中。

在线程类 Thread 类中有一个 threadLocals 属性，该属性为 `ThreadLocal.ThreadLocalMap` 类型，因此在 Thread 和 ThreadLocalMap 之间是通过静态内部类 ThreadLocalMap 来进行交互和数据传递。



**引用**：

ThreadLocal 的内部类 ThreadLocalMap 的内部类 Entry 继承了  WeakReference（弱引用）。

Java 中存在四种类型的引用；

- 强引用：如使用 new 方式：  A a = new A();

    将 new A(); 创建的实例的引用赋值给了变量 a，则 a 就是对新创建对象的强引用。

- 软引用：

    垃圾回收时候会将软引用的对象清理

- 弱引用

- 虚引用

除了强引用是通过 New 方式创建，其他三种引用都要继承抽象类 Reference，然后实现其中方法。

这里让 Entry 继承 WeakReference 是为了防止内存泄露。但是即是继承如果代码写的有问题还是会发生内存泄露。

![image-20210322201754018](部分一：线程.resource/image-20210322201754018.png)

为什么是虚引用：

- 假设如果是强引用，则当持有 ThreadLocal 对象引用的对象不在需要 ThreadLocal 实例，如这个对象本身就被销毁了，则这个对象自身的所有成员变量也会消失，则栈中 tl 引用就为空，则 tl 指向堆中 ThreadLocal 实例的引用也就没有了。这个对象本身消亡了，则也会认为其引用的对象也都消亡了，则任务 ThreadLocal 实例也就没有了，然后因为某个 Entry 对象的 key 持有堆中该 ThreadLocal 实例的强引用， 则该 ThreadLocal 实例永远无法释放，对应着有这个引用的 Entry 对象永远无法释放，则 ThreadLocalMap 中的 Entry 数组会不断的增大，永远不会减小。同时因为栈中对该 ThreadLocal 实例的引用已经消亡，则该对象实例用于无法使用。导致内存泄露。
- 使用虚引用的话，针对上面的情况，因为下一次 GC 时候发现该 ThreadLocal 对象只被一个弱引用对象进行引用，则会将其回收该实例。

还有问题：当 ThreadLocal 实例被 GC 回收之后，Entry 中的 key 则指向了 null，则导致获取值获取不到，但是值又是存在的，使得 Entry 中存在很多 key 为 null 但是 value 存在的对象。则同样会造成内存泄露。ThreadLocal 在 get 和 set 方法中除了正常操作之外，还会将 Entry 数组中所有 key 为 null 的键值对 remove 掉。源码如下：

```java
private void set(ThreadLocal<?> key, Object value) {
    // XXXXX 
    for (Entry e = tab[i];
         //   XXXXXX
         if (k == null) {
             replaceStaleEntry(key, value, i);
             return;
         }
     }
         //  XXXXXX
}
```

最终使用的是 replaceStaleEntry 方法中的 expungeStaleEntry 方法的 expungeStaleEntry() 方法实现对所有键为 null 的Entry 对象清理。

**常规正确使用方式**：

```java
package com.gjxaiou.threadLocal;

public class MyTest2 {
    // static 保证 MyTest2 类的所有实例对象能共享该对象
    private static final ThreadLocal<String> th = new ThreadLocal<>();

    // 如果不需要 ThreadLocal 对象，需要在 finally 中显示调用 remove，调用 remove 操作：首先移除 ThreadLocal 对象，然后将 Entry 中
    // key 为 null 的对象也移除
    try{
        // 正常执行逻辑
    }finally{
        th.remove();
    }
}
```



### AQS（AbstractQueueSynchronized）

AQS 的设计思想几乎完全基于 synchronized 在 C++ 层面的实现，只是在此基础上进行了改良使得粒度更小。

该类中除了常规的成员方法之外还有两个子类：ConditionObject 和 Node（Ctrl + F12)。其中 ConditionObject 继承了 Condition。这些 Condition 是通过 AQS 中的 Lock 进行创建的，因为对于一个 Lock 而言，其 Condition 可以拥有多个。Node 是一个 FIFO 双向队列，该对象中的线程都处于被阻塞的状态，Node 中封装了 Thread 类。

示例代码验证 AQS 的执行逻辑：

```java
package com.gjxaiou.aqs;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.IntStream;

public class MyTest1 {
    private Lock lock = new ReentrantLock();

    public void method() {
        try {
            lock.lock();

            try {
                Thread.sleep(1000);
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
            System.out.println("method");
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        // 创建 5 个线程执行上面方法
        MyTest1 myTest1 = new MyTest1();

        IntStream.range(0, 5).forEach(i -> {
            new Thread(() -> {
                myTest1.method();
            }).start();
        });
    }
}
```

执行结果为：

```java
method
method
method
method
method
```



#### 可重入锁  ReentrantLock 是基于 AQS 实现的互斥锁（无论读写只有一个线程可以获取锁）。

在 Java 并发包中，凡是使用 AQS 实现的都会该当前类中封装一个属性 Sync，该类继承 AQS，同时复写 AQS 中的 Protected 修饰的方法。

因为 AQS 本身为抽象类，因此无法直接使用，同时该抽象类中定义了若干 protected 修饰的方法，这些方法的具体执行应该取决于子类的业务场景和子类含义。

ReentrantLock 中的内部 Sync 类就实现了 tryAcqured 和 tryRelease 方法。ReentrantLock 通过构造方法传入的 boolean 类型变量来决定采用公平锁还是非公平锁，默认是非公平锁。（公平锁就是通过 signal 或者 signalAll 唤醒 Condition 中等待的线程之后，将该线程放入阻塞队列的最后面，会依次执行阻塞队列中的线程。非公平锁就是唤醒之后就会尝试抢占资源，如果抢到锁就直接执行，没有抢到则想上面一样排队执行）。

因此 ReentrantLock 中的 Sync 类没有重写 AQS 中的 tryAcquired() 方法，而是使用 FairSync 和 NonFairSync  继承了 Sync 并且实现了不同的 tryAcquired() 方法。

```java
static final class FairSync extends Sync {
        private static final long serialVersionUID = -3000897897090466540L;

        final void lock() {
            acquire(1);
        }

        /**
         * Fair version of tryAcquire.  Don't grant access unless
         * recursive call or no waiters or is first.
         */
        protected final boolean tryAcquire(int acquires) {
            // 首先获取当前线程（该线程即尝试获取锁的线程）
            final Thread current = Thread.currentThread();
            // 获取成员变量 state 的值，在排它锁的语境下，该值表示已经持有锁的线程的个数
            int c = getState();
            // c = 0 表示当前没有任何线程获取到这把锁
            if (c == 0) {
                // hasQueue.. 就是判断阻塞队列中有没有等待的线程。然后 尝试用 CAS 模式将 0 变成传入进来的 acquires 值。
                if (!hasQueuedPredecessors() &&
                        compareAndSetState(0, acquires)) {
                    // 前面没有等待线程了并且通过 CAS 将 state 值替换成功了，则当前线程获取到锁了。
                    setExclusiveOwnerThread(current);
                    return true;
                }
                // 判断当前线程是不是排它锁的拥有者
            } else if (current == getExclusiveOwnerThread()) {
                // 如果 state 为 1，则 nextc 新该锁新的重入次数
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            // 当前线程没有获取锁
            return false;
        }
    }
```

如果是非公平锁：

```java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    // c = 0 表示当前没有任何线程持有锁
    if (c == 0) {
        // 非公平情况下则直接使用 CAS 替换 state 的值，然后设置当前线程拥有该锁；即直接尝试获取锁
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
        // 重入性判断
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

因为调用上面代码的 AQS  中方法结构为：

```java
public final void acquire(int arg) {
    // 首先执行 NonfairSync 的 tryAcquire，如果返回 false 即没有获取锁，则通过 acquireQueued 来放入后面的阻塞队列
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

**什么时候触发新的线程获取锁**：
只有调用 unlock 之后才可能触发阻塞队列中的线程去获取锁。

调用步骤为：`lock.unlock()`-> `Reentrant.unlock()` ->`sync.release(1);`-> `release()方法`

AQS 中的 release 方法为：

```java
public final boolean release(int arg) {
    // 首先通过  tryRelease，如果返回 true 则表示当前线程不管重入多少次都已经将该锁释放了。
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            // 唤醒已经释放锁的线程后面的线程
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

ReentrantLock 的 tryRelease() 方法为：

```java
protected final boolean tryRelease(int releases) {
    // 首先将 state 值减一
    int c = getState() - releases;
    // 判断当前线程是不是获取该排它锁的线程，用于防止使用 A 线程的 lock，然后调用 B 线程的 unlock 进行上锁
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    // c 为 0 表示当前已经没有线程持有这把锁了
    if (c == 0) {
        // 将锁的状态 free 设置为真，同时将排它锁的线程持有者设置为 null，表示当前没有线程持有这个排它锁
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    // 如果 free 为 false，则表示 c 不为 0，则表示这把锁被重入了
    return free;
}
```

AQS 里面的  unparkSuccessor ()  方法为：

```java
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    // s 就是释放锁的线程后面的Node节点
    if (s != null)
        // 最后调用 LockSupport（Native 返回）的后面线程的 unpark 方法来唤醒。
        LockSupport.unpark(s.thread);
}
```



**总结： ReentrantLock 的执行逻辑**：

- 当前线程尝试获取对象的锁，如果是已拥有锁的线程则可以再次获取到锁（可重入），如果获取不到（意味着已经有其它线程持有了锁，并且尚未释放），那么当前线程会进入 AQS 的阻塞队列中。
- 如果获取到，那么根据锁是公平锁还是非公平锁来进行不同的处理。
    - 如果是公平锁，那么线程会直接放置到 AQS 阻塞队列的末尾；
    - 如果是非公平锁，那么线程会首先尝试进行 CAS 计算，如果成功则直接获取到锁；如果失败，这与公平锁的处理方式一致，被放到阻塞队列的末尾。
- 当锁被释放了（调用了 unlock 方法），那么底层会调用 release 方法对 state 成员变量值进行减一操作，如果减一后，state 值不为 0，那么 release 操作就执行完毕；如果减一操作后， state 值为 0（锁被释放了），则调用  LockSupport 的 unpark() 方法唤醒该线程后的等待队列中的第一个后继线程（底层 C++ 使用 pthread_mutex_unlock 方法），将其唤醒。使之能够获取到对象得到锁（release 时候，对于公平锁和非公平锁的处理逻辑是一致的）；之所以调用 release 方法之后state 的值可能不为 0， 原因在于 ReentrantLock 是可重入锁，表示线程可以可以多次调用 lock() 方法。导致每调用一次， state 值就会减一。

**上锁**：针对 Synchronized 上锁就是针对每个对象头中的 ObjectMonitor 进行标识。

针对 ReentrantLock 来说，所谓的上锁，本质上就是对 AQS 中的 state 成员变量的操作：对该成员变量 + 1，表示上锁；对该成员变量 -1，表示释放锁。





#### ReadWriteLock  和 ReentrantReadWriteLock

示例代码：

```java
package com.gjxaiou.aqs;

import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.stream.IntStream;

/**
 * 验证使用 ReadWriteLock
 */
public class MyTest2 {
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    public void method() {
        try {
            // 获取到对象里面的一把读锁，然后上锁
            readWriteLock.readLock().lock();

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("method");
        } finally {
            readWriteLock.readLock().unlock();
        }
    }

    public static void main(String[] args) {
        MyTest2 myTest2 = new MyTest2();
        IntStream.range(0, 5).forEach(i -> new Thread(myTest2::method).start());
    }
}
```

结果为：

```java
method
method
method
method
method
```

输出的过程：大约等待 1s 之后，然后这 5 个语句几乎同时输出。

如果将上面的 ` readWriteLock.readLock()` 换成 `readWriteLock.writeLock()` 之后的执行效果类似于 ReentrantLock 的一秒输出一个。

因为读锁可以多次获取，获取完之后每个线程等待 1s 之后进行输出，但是写锁是严格互斥的，因此一个线程获取锁之后其它线程只能等待，直到原有线程将锁释放之后其它线程才能获取。



ReadWriteLock 接口比较简洁，主要关注其实现类 ReentrantReadWriteLock 

ReentrantReadWriteLock 默认也是非公平锁，和 ReentrantLock 一样通过构造方法实现公平与非公平锁。

`readWriteLock.readLock().lock()` 执行过程：

首先因为已经通过 `private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();` 创建了一个 readWriteLock 对象，同时在创建时候同时创建了 ReadLock  和 WriteLock 对象。

```java
 public ReentrantReadWriteLock() {
        this(false);
    }

    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }
```

然后调用 lock() 方法，该方法对应的是 ReentrantReadWriteLock 类中的 ReadLock 类的 lock() 方法：

```java
public static class ReadLock implements Lock, java.io.Serializable {
    private static final long serialVersionUID = -5992448646407690164L;
    private final Sync sync;

    // 获取对象中的读锁，读锁是共享锁，即多个线程可以获取该锁
    public void lock() {
        sync.acquireShared(1);
    }
}
```

AQS 中的 `acquireShared()` 方法为：

```java
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
```

这里 AQS 中的 tryAcquiredShared() 方法是直接抛出异常，所以我们还是要看子类 ReentrantReadWriteLock 中的 Sync 类进行实现。

```java
protected final int tryAcquireShared(int unused) {

    // 获取当前线程对象和当前 state 值
    Thread current = Thread.currentThread();
    int c = getState();
    // exclusiveCount 返回低 16 位的值（记录写锁的持有数量）
    // !=0 表示当前有线程在持有写锁，并且持有的线程不是当前线程，返回 -1，如果是当前线程则可以重入的，所以两个判断都必不可少。
    if (exclusiveCount(c) != 0 &&
        getExclusiveOwnerThread() != current)
        return -1;
    // -----------------进入这里说明当前没有线程持有写锁，则可能获取读锁--------------------------
    // sharedCount 获取高 16 位值
    int r = sharedCount(c);
    // readerShouldBlock 的实现分为公平锁和非公平锁，针对公平锁：判断这个阻塞队列前面是不是有其他线程在等待。如果是非公平：是不是可以进行插入操作。
    // MAX_COUNT：读锁和写锁的上锁次数都是有上限的，
    if (!readerShouldBlock() &&
        r < MAX_COUNT &&
        compareAndSetState(c, c + SHARED_UNIT)) {
        // 如果共享锁的数量 r 为 0，说明之前之前并没有任何的读锁进行上锁
        if (r == 0) {
            // 当前线程为第一个读锁线程，并且读锁的数量为 1
            firstReader = current;
            firstReaderHoldCount = 1;
            // 如果已经有共享锁（可能为其他线程或者是该线程本身已经给这个对象上了一把读锁）。
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}
```

**针对读锁的判断流程**：

首先进行判断当前对象有没有被上写锁，如果有并且当前已经上锁的线程和当前线程还不是同一个线程，则直接返回。然后即如果没有上写锁，则上读锁是一定可以成功的，如果之前没有线程给上读锁的话则上锁数量置为 1，如果有则上锁数量进行加一。



当使用 `readWriteLock.writeLock().lock()` 时候：

整体流程和上述类似，只是在调用 tryAcquire() 方法的时候，调用的是 ReentrantReadWriteLock 的内部类 Sync 的 tryAcquire() 方法。该方法逻辑为：

```java
protected final boolean tryAcquire(int acquires) {
    /*
             * Walkthrough:
             * 1. If read count nonzero or write count nonzero
             *    and owner is a different thread, fail.
             * 2. If count would saturate, fail. (This can only
             *    happen if count is already nonzero.)
             * 3. Otherwise, this thread is eligible for lock if
             *    it is either a reentrant acquire or
             *    queue policy allows it. If so, update state
             *    and set owner.
             */
    Thread current = Thread.currentThread();
    int c = getState();
    // 获取写锁的数量, c 不为 0 表示该对象的排它锁已经被某个线程持有了。
    int w = exclusiveCount(c);
    if (c != 0) {
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) > MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // Reentrant acquire
        // 本身获取锁的线程就是当前线程，即将写锁又进行了重入
        setState(c + acquires);
        return true;
    }
    // c = 0 表示当前对象没有锁（既没有读锁，也没有写锁）
    // 尝试获取写锁，并且 CAS 操作失败（即当前有另一个线程和当前线程竞争写锁，并且当前线程没有竞争过，则返回 false）
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    // 获取成功
    setExclusiveOwnerThread(current);
    return true;
}
```





**总结：关于 ReentrantReadWriteLock 的 Lock 的操作逻辑**：

- 读锁：

    - 在获取读锁时，会尝试判断当前对象是否拥有了写锁，如果已经拥有则直接失败。
    - 如果没有写锁，就表示当前对象没有排它锁，则当前线程会尝试给对象加锁。
    - 如果当前线程已经持有了该对象的锁，那么直接将读锁的数量加一。

- 写锁：

    - 在获取写锁时，会尝试判断当前对象是否拥有了锁（读锁和写锁），如果已经拥有且持有的线程并非当前线程则直接失败。
    - 如果当前对象没有被加锁，那么写锁就会为当前对象上锁，并且将写锁的数量加一。
    - 将当前对象的排它锁线程持有者设为自己。

    

    

    - 如果读锁数量或者写锁数量非零并且拥有锁的线程不是当前对象，则直接报错。（因为写锁一定是互斥的，则在给当前对象加锁的时候，当前对象即不能有读锁，也不能有写锁）。
    
        

##### 针对读写锁的 unlock() 方法执行流程

**首先针对 readLock**：

调用流程为：`readWriteLock.readLock().unlock()`，其中 `unlock()` 方法的实现为 ReentrantReadWriteLock 类中的 `unlock()` 方法，代码如下：

```java
public void unlock() {
    // 释放掉共享锁，即将计数器减一
    // 这里的 sync 是 ReadLock 里面的成员变量，但是同时通过 ReadLock 的构造方法使其关联到外部的 ReentrantReadWriteLock 的 sync
    sync.releaseShared(1);
}
```

其中 `releaseShared()` 方法是 AQS 中，具体为：

```java
public final boolean releaseShared(int arg) {
    // tryReleaseShared() 方法在 AQS 中的实现就是抛出异常，因此不同子类需要进行自定义
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
```

tryReleaseShared() 方法在 ReentrantReadWriteLock  类的 Sync 类的实现为：

```java
protected final boolean tryReleaseShared(int unused) {
    Thread current = Thread.currentThread();
    // firstReader 是 ReentrantReadWriteLock 中定义的一个成员变量，表示已经获取到读锁的第一个线程
    if (firstReader == current) {
        // assert firstReaderHoldCount > 0;
        // firstXXcount 就是上面 firstReader 线程重入的次数
        if (firstReaderHoldCount == 1)
            // 如果为 1 则当下面减一之后就相当于没有任何读锁了，所以直接置为 null，表示没有读线程在持有这把锁。
            firstReader = null;
        else
            // 如果不为 1 则说明调用了多次 lock,则第一个读线程 firstReader 不变，但是因为调用了 unlock，所以重入次数减一
            firstReaderHoldCount--;
        // 当前的线程并不是第一个读的线程，因为读锁是共享锁，多个线程都可以获取
    } else {
        // HoldCounter 是持有锁的计数器对象，同时针对每个线程进行匹配。里面的 count 表示当前读线程持有锁的数量（重入次数），写线程没有，因为写线程是排它的
        // 每个线程都会对应一个 HoldCounter 实例，里面的变量 count 表示当前线程持有的读锁的数量，使用 ThreadLocal 实现。
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != getThreadId(current))
            rh = readHolds.get();
        int count = rh.count;
        if (count <= 1) {
            readHolds.remove();
            if (count <= 0)
                throw unmatchedUnlockException();
        }
        // 持有的读锁的数量减一
        --rh.count;
    }

    for (;;) {
        int c = getState();
        // state 值减去读锁的高 16 位的值
        int nextc = c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            // 释放读锁对读线程是没有任何影响的，但是可以让尝试获取写锁的线程继续执行，如果读锁和写锁的数量都是 0
            // Releasing the read lock has no effect on readers,
            // but it may allow waiting writers to proceed if
            // both read and write locks are now free.
            // 如果是 0 则写线程和读线程就可竞争获取锁了。
            return nextc == 0;
    }
}
```

如果上面的方法返回 true，则表示读锁都释放了，可以执行 AQS 中的 `doReleaseShared()`

```java
private void doReleaseShared() {
    for (; ; ) {
        Node h = head;
        // 判断阻塞链表是不是为空
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            // 判断是不是该线程要获取到通知
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                // 唤醒后面一个线程。内部还是 LockSupport.unpark() 
                unparkSuccessor(h);
            } else if (ws == 0 &&
                       !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
```

**针对写锁 writeLock 的 unlock**：  => 排它锁的释放 

使用 `readWriteLock.writeLock().unlock();` 调用的 `unlock()` 方法，本质上是调用 ReentrantReadWriteLock 的内部类 WriteLock 的 `unlock()` 方法

```java
public void unlock() {
    sync.release(1);
}
```

其中进入 AQS 中的 `release()` 方法具体为：

```java
public final boolean release(int arg) {
    // 首先通过  tryRelease，如果返回 true 则表示当前线程不管重入多少次都已经将该锁释放了。后面线程可以尝试获取了
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            // 唤醒已经释放锁的线程后面的线程
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

针对 `tryRelease()` 方法本质上在 AQS 仅仅是抛出一个异常，需要子类进行对应的实现。这里选择 ReentrantReadWriteLock 中的 Sync 的实现

```java
protected final boolean tryRelease(int releases) {
    // isHeldExclusively() 返回真表示当前锁为排它锁，否则为共享锁
    if (!isHeldExclusively())
        // 这里尝试进行写锁的释放，但是如果当前线程并不是拥有写锁的线程则直接抛出异常
        throw new IllegalMonitorStateException();
    int nextc = getState() - releases;
    // 减完之后获取当前排它锁的数量，是否为 0，如果为 0 则表示当前的排它锁不被任何线程锁持有。因为写锁也是可重入的，所以可能不为 0
    boolean free = exclusiveCount(nextc) == 0;
    if (free)
        // 当前获取排它锁的线程直接设置为 null，表示没有线程持有该排它锁
        setExclusiveOwnerThread(null);
    setState(nextc);
    return free;
}
```



**Condition 回顾**：

Condition 是通过生成的 Lock 对象调用 newCondition() 方法创建的，一个 Lock 可以创建多个 Condition 对象，各个 Condition 之间没有任何关系，只有每个 Condition 内部的各个等待线程之间可以相互进行唤醒，不同 Condition 之间的线程是没有任何关系的。

具体分析 AQS  中的 await() 方法的实现，

AQS 可以下挂多个 Condition 等待队列，每个 Condition 里面的节点都是 Node 类型，不断的往后追加。调用某一个 Condition 的 signal 或者 signalAll 方法会将该 Condition 中等待的线程进行唤醒。调用某个 condition 对象的 `await()` 方法之后所执行的逻辑为 AQS 子类 ConditionObject 的 `await()` 方法：

```java
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    // Node 实例中是封装了当前的线程
    // addConditionWaiter 就是往 Condition 的等待队列（条件队列）中增加一个等待者，因为条件队列本身也是关于 Node
    // 的链表，这里就是将其加入条件队列的尾端。
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    // 判断一些中断性，不重要
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
```

针对AQS 中的 signal 方法

因为每个 Condition 队列都是先进先出的，signal 方法会将等待时间最长的线程移除出Condition 的等待队列，移动到拥有锁的等待队列中。这里移除之后如果是非公平锁，直接抢占，如果是非公平锁，则移动到阻塞队列的最后面。transferForSignal 实现将一个 Node 从一个 Condition 队列中移动到同步（阻塞）队列。

```java
// 将 Condition 中等待时间最长的线程移除并且放置到拥有锁的阻塞队列
public final void signal() {
    // 首先判断是不是排它锁
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    // 获取双向阻塞队列的第一个等待着
    Node first = firstWaiter;
    // 如果不为空，说明已经有线程（Node 节点）阻塞了
    if (first != null)
        // 进行节点移动
        doSignal(first);
}
```

其中 AQS 中的 `doSignal()` 方法为：

```java
private void doSignal(Node first) {
    do {
        if ((firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
        // transferForSignal 实现将一个 Node 从一个 Condition 队列中移动到同步（阻塞）队列
    } while (!transferForSignal(first) &&
             (first = firstWaiter) != null);
}
```

![image-20210325140720672](部分一：线程.resource/image-20210325140720672.png)

#### AQS 和 Synchronized 关键字之间的关系

- Synchronized 关键字在底层的 C++ 实现中，存在两个重要的数据结构（集合）：WaitSet 和 EntryList
    - WaitSet 中存放的是调用了 Object 类的 wait 方法的线程对象（即被陷入等待状态的线程对象）（被封装成了 C++ 的 Node 对象）。
    - EntryList 中存放的是陷入到阻塞状态、需要获取 monitor 的线程对象。
    - 当一个线程被 notify 之后，它就会从 WaitSet 中移动到 EntryList 中。
    - 进入 EntryList 中后，该线程依然需要与其他陷入阻塞的线程争抢 monitor 对象
    - 如果争抢到，就表示该线程获取到了对象的锁，它就可以以排它的方式执行对应的同步代码。

- AQS 中存在两种队列，分别是 Condition 对象上的条件队列以及 AQS 本身的阻塞队列
    - 这两个队列中的每一个对象都是 Node 实例（里面封装了线程对象）
    - 当位于 Condition 条件队列中的线程被其他线程 signal 唤醒之后，该线程就会从条件队列中移动到 AQS 的阻塞队列中【针对公平锁】，如果是非公平锁着唤醒之后进行锁资源的争抢，抢到就执行，没抢到再进入阻塞队列。
    - 位于 AQS 阻塞队列中的 Node 对象本质上都是一个双向链表来构成的。
    - 在获取 AQS 锁时，这些进入到阻塞队列中的线程会按照在队列中的排序向后尝试获取。
    - 当 AQS 阻塞队列中的线程获取到锁后，就表示该线程可以正常执行了，没有获取到则还是需要等待
    - 陷入到阻塞状态的线程，依然需要进入到操作系统的内核态，进入阻塞（通过 park() 方法实现）。



AQS 比 synchronized 优势

- Synchronized 只有排它锁，但是 AQS 既有排它锁也有共享锁。
- synchronized 中只能调用一个对象的 wait() 和 notify() 来进行阻塞等待和唤醒，但是一个 AQS 对象上可以有多个 Condition 对象，即有多个条件。
- AQS 中的等待是以队列的形式来存储，但是 Synchronized 中底层是 EntryList 中。



### 线程池

高并发情况下频繁的创建和销毁线程还是会消耗不少的系统资源。

**Excutor 接口**：

- 执行用户获取其它线程提交过来的任务。
- 将任务的提交和任务的执行进行解耦。

该接口的实现较多，其中比较重要的是 `ExecutorService`，该接口继承 Excutor 接口同时新增了一些方法。该接口的进一步抽象继承类为 AbstractExecutorService，对 ExecutorService 接口中部分方法进行了默认实现。进一步的最重要的实现类为 ThreadPoolExecutor 类。



**创建线程池示例**：Executors 的工厂方法

```java
package com.gjxaiou.threadPool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.IntStream;

public class MyTest1 {
    public static void main(String[] args) {
        /**
         * 创建线程池
         * 方式一：直接 new ThreadPoolExecutor
         * 方式二：通过 Executors 创建
         */

        // 创建一个包括 3 个线程的固定大小的线程池
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        // submit 中是待执行的任务
        executorService.submit(() -> {
            // 循环 5 次输出当前线程名称
            IntStream.range(0, 5).forEach(i -> {
                System.out.println(Thread.currentThread().getName());
            });
        });
        
        // 补充关闭线程池的地方
    }
}
```

执行结果为：

```java
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
```

输出以上结果之后，程序并没有停止，即 JVM 并没有退出。

因为线程池中创建的线程并不是守护线程，而是用户线程。JVM 退出需要在主线程执行完成并且没有任何的用户线程在执行。如果需要退出 JVM ，需要在执行完之后显式的关闭线程池：`executorService.shutdown();`

上面代码仅仅是向线程池中提交了一个任务，下面是多次提交任务。线程池中共 3 个线程，执行 5 个任务

```java
package com.gjxaiou.threadPool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.IntStream;

public class MyTest2 {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        IntStream.range(0, 5).forEach(i -> {
            executorService.submit(() -> {
                IntStream.range(0, 2).forEach(j -> {
                    System.out.println(Thread.currentThread().getName());
                });
            });
        });
        executorService.shutdown();
    }
}
```

输出结果为：

```java
pool-1-thread-1
pool-1-thread-1
pool-1-thread-2
pool-1-thread-2
pool-1-thread-2
pool-1-thread-2
pool-1-thread-1
pool-1-thread-1
pool-1-thread-3
pool-1-thread-3
```

使用工厂的方式创建线程池，注意这里建议在自己创建线程池的时候不要使用工程模式来创建线程池。为什么呢？

因为ThreadPoolExecutor构造方法有很多参数，所有很多时候是根据具体业务需求进行定制的。比如阻塞队列使用 工厂模式来进行创建话默认是创建无限大小的阻塞队列（然后在高并发的情况下，很有可能会出现内存溢出的情况），还有就是其默认是使用的拒绝策略就是抛异常（即使不抛异常使用内置的四种拒绝方法依然不符合实际要求）



#### ThreadPoolExecutor 分析

**构造方法中的参数分析**：

- `int  corePoolSize`：线程池当中所一直维护的线程数量，如果线程池处于任务空闲期间，那么该线程也并不会被回收掉
- `int maximumPoolSize`：线程池中所维护的线程数的最大数量

- `long keepAliverime`：超过了 corePoolSize 的线程在经过 keepAliverime 时间后如果一直处于空闲状态，那么超过的这部分线程将会被回收掉

- `TimeUnit unit`：指的是 keepAliveTime 的时间单位
- `BlockingQueue<Runnable> workQueue`：向线程池所提交的任务位于的阻塞队列，它的实现有多种方式（BlockingQueue 是一个接口，具体实现方式有很多种）

- `ThreadFactory  threadFactory`：线程工厂，用于创建新的线程并被线程池所管理，默认线程工厂所创建的线程都是用户线程且优先级为正常优先级。该接口的常用实现类为：Executors 类中的`DefaultThreadFactory` 类。

    ```java
      static class DefaultThreadFactory implements ThreadFactory {
            // 因为在系统中可能创建多个线程池，并且则多个线程池可能都是由 DefaultThreadFactory 来创建生成的，所以该变量设置为 static
            // 之后，所有线程池都基于该变量进行增加。Pool-1
            private static final AtomicInteger poolNumber = new AtomicInteger(1);
            private final ThreadGroup group;
            // 线程是归属于线程池的，一个线程不可能归属多个线程池，所以一定是归属于某一个工厂对象的。
            private final AtomicInteger threadNumber = new AtomicInteger(1);
            private final String namePrefix;
    
            DefaultThreadFactory() {
                SecurityManager s = System.getSecurityManager();
                group = (s != null) ? s.getThreadGroup() :
                        Thread.currentThread().getThreadGroup();
                namePrefix = "pool-" +
                        poolNumber.getAndIncrement() +
                        "-thread-";
            }
    
            public Thread newThread(Runnable r) {
                Thread t = new Thread(group, r,
                        namePrefix + threadNumber.getAndIncrement(),
                        0);
                // 如果创建的线程是守护线程
                if (t.isDaemon())
                    // 将其变成用户线程
                    t.setDaemon(false);
                // 设置新建线程的优先级为默认优先级
                if (t.getPriority() != Thread.NORM_PRIORITY)
                    t.setPriority(Thread.NORM_PRIORITY);
                return t;
            }
        }
    ```

- `RejectedExecutionHandler  handler`：表示当线程池中的线程都在忙于执行任务且阻塞队列也已经满了的情况下，新到来的任务该如何被对待和处理。
    它有四种实现策略，对应该接口在 ThreadPoolExecutor 类中四个内部类：

1. - AbortPolicy：直接抛出一个运行期异常，抛给调用者。【默认】
    - DiscardPolicy：默默地丢弃掉提交的任务，什么都不做且不抛出任何异常
    - DiscardoldestPolicy：丢弃掉阻塞队列中存放时间最久的任务(队头元素)，并且为当前所提交的任务留出一个队列中的空闲空间，以便将其放进到队列中（不一定能放入，因为可能刚刚丢弃其他线程就提交任务占据空闲空间了）
    - callerRunsPolicy：直接由提交任务的线程来运行这个提交的任务（不是使用线程池中线程）。

   针对阻塞队列的 BlockingQueue 进行分析：
   
   其具体实现包括：LinkedBlockingQueue、ArrayBlockingQueue 等等
   

 

针对 newFixedThreadPool 分析：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

提供一个无界队列（的阻塞队列），拒绝策略为 `defaultHandler` 即直接抛出异常的固定大小线程池。

针对 newSingleThreadExecutor，同上，只是线程数固定为 1。

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

针对 newCachedThreadPool，默认保持的线程数为 0，最多创建 Int 的最大值数目，拒绝策略也是 defaultHandler

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

其中阻塞队列是 SynchronizedQueue，是一个同步队列【插入操作必须等移除操作完成才行，反之亦然】，该队列中只有一个元素。

**为什么不推荐使用上述的三种工厂方法创建线程池**：

- 所有的拒绝策略都是 `defaultHandler`，即都是抛出异常。
- 前两种的阻塞队列都是无界的 `LinkedBlockingQueue`，因此当并发大的情况下造成任务过多使得该阻塞队列不断的增大，从而会出现 OOM 问题。

**在线程池中，尽量将偏向锁的标记关闭（因为线程池本来就是用来处理多线程的）**



#### ThreadPoolExecutor 使用

示例一：

```java
package com.gjxaiou.threadPool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class MyTest3 {
    public static void main(String[] args) {
        // 核心线程数为 3，最大为 5， 等待时间为 0， 阻塞队列长度为 3， 拒绝策略是直接抛异常
        ExecutorService executorService = new ThreadPoolExecutor(3, 5, 0,
                TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(3),
                new ThreadPoolExecutor.AbortPolicy());

        // 向线程池提交 9 个任务
        IntStream.range(0, 9).forEach(i -> {
            executorService.submit(() -> {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException exception) {
                    exception.printStackTrace();
                }

                IntStream.range(0, 2).forEach(j -> {
                    System.out.println(Thread.currentThread().getName());
                });
            });
        });

        // 关闭线程池
        executorService.shutdown();
    }
}
```

当向上述代码所示，向线程池提交 9 或以上任务时候，会抛出异常，如下所示：

```java
 Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@568db2f2 rejected from java.util.concurrent.ThreadPoolExecutor@378bf509[Running, pool size = 5, active threads = 5, queued tasks = 3, completed tasks = 0]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)
	at com.gjxaiou.threadPool.MyTest3.lambda$main$2(MyTest3.java:18)
	at java.util.stream.Streams$RangeIntSpliterator.forEachRemaining(Streams.java:110)
	at java.util.stream.IntPipeline$Head.forEach(IntPipeline.java:559)
	at com.gjxaiou.threadPool.MyTest3.main(MyTest3.java:17)
pool-1-thread-2
pool-1-thread-2
pool-1-thread-3
pool-1-thread-3
pool-1-thread-1
pool-1-thread-1
pool-1-thread-4
pool-1-thread-4
pool-1-thread-5
pool-1-thread-5
pool-1-thread-3
pool-1-thread-3
pool-1-thread-2
pool-1-thread-2
pool-1-thread-1
pool-1-thread-1
```

如结果所示，已经创建了 5 个线程来执行任务。报错结果中信息为：`[Running, pool size = 5, active threads = 5, queued tasks = 3, completed tasks = 0]` 。因为最多创建  5 个线程，同时执行最多只能执行 5 个任务，然后阻塞队列大小为 3，即最多处理 8 个任务，现在出现 9 个任务，同时因为调用 sleep 则所有线程都在执行任务，所以针对第九个任务则需要使用拒绝策略，即直接抛出了异常。

如果将上述代码中的拒绝策略修改为：`DiscardPolicy()`。即

```java
 ExecutorService executorService = new ThreadPoolExecutor(3, 5, 0,
                TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(3),
                new ThreadPoolExecutor.DiscardPolicy());
```

输出结果为：将最后一个任务进行丢弃处理了。

```java
pool-1-thread-2
pool-1-thread-2
pool-1-thread-4
pool-1-thread-4
pool-1-thread-5
pool-1-thread-5
pool-1-thread-3
pool-1-thread-3
pool-1-thread-1
pool-1-thread-1
pool-1-thread-5
pool-1-thread-5
pool-1-thread-4
pool-1-thread-4
pool-1-thread-2
pool-1-thread-2
```

因为每个任务是输出两行，一共 16 行，即丢弃了一个任务。

如果拒绝策略为：`DiscardOldestPolicy()`。结果同样为 16 行，这里是将阻塞队列的第一个任务进行丢弃了。

如果拒绝策略为：`CallerRunsPolicy()`，执行结果为：

```java
pool-1-thread-5
pool-1-thread-5
pool-1-thread-2
pool-1-thread-2
pool-1-thread-3
pool-1-thread-3
pool-1-thread-1
pool-1-thread-1
pool-1-thread-4
pool-1-thread-4
main
main
pool-1-thread-3
pool-1-thread-3
pool-1-thread-5
pool-1-thread-5
pool-1-thread-2
pool-1-thread-2
```

最后一个任务无法放入线程池和阻塞队列，则该任务就由提交该任务的线程执行，这里就是 main 线程。（因为该任务是由 main() 方法提交，即由 main() 方法所在线程进行执行）。

#### 线程池内部执行机理解读

最顶层的 Executor 只提供了 execute() 方法，里面接收的是 Runnable 实例。而其实现类 ExecutorService 中提供了一个 submit() 方法，接收的是 Callable 实例，可以有返回值。但是其实 submit() 方法有多个重载版本，既可以接收 Runnable 也可以接收 Callable 实例。



**submit和execute**

对于线程池来说，其提供了execute与submit两种方式来向线程池提交任务

总体来说，submit方法是 可以取代execute方法的，因为它既可以接收Callable任务, 也可以接收Runnable任务。

关于线程池的总体执行策略:

1.如果线程池中正在执行的线程数< corePoolSize, 那么线程池就会优先选择创建新的线程而非将提交的任务加到阻塞队列中。

2.如果线程池中正在执行的线程数>= corePoolSize, 那么线程池就会优先选择对提交的任务进行阻塞排队而非创建新的线程。

3.如果提交的任务无法加入到阻塞队列当中，那么线程池就会创建新的线程;如果创建的线程数超过了maximumPoolSize,那么拒绝策略就会起作用。

 

关于线程池任务提交的总结:

1.两种提交方式: submit与execute

\2. submit有 三种方式，无论哪种方式，最终都是将传递进来的任务转换为- -个callable对象进行处理

3.当callable对象构造完毕后， 最终都会调用Executor接口中声明的execute方法进行统- -的处理

对于线程池来说，存在两个状态需要维护:

1.线程池本身的状态: ct1的高三位来表示

2.线程池中所运行着的线程的数量: ct1的其余29位来表示

 

这里需要使用代码的截图来进行证实上面的观点。（基本的分析从submit->Executor->addworker->work->runwork（awaittermination，processworkExit，shutdown，shutdownnow））

















