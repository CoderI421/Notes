{"compress":true,"commitItems":[["01c41992-df89-414d-a15a-e5c930560f11",1562764199559,"",[[1562764145630,["GJX@GJXAIOU",[[1,0,"# 粒子群算法\n\n\n\n"]],[0,0],[10,10]]]],null,"GJX@GJXAIOU"],["c726849c-d785-4d56-a231-174dadb20abf",1562825062209,"# 粒子群算法\n\n\n\n",[[1562825005789,["GJX@GJXAIOU",[[1,9,"一.产生背景\n\n   \n\n❃粒子群算法(particleswarm optimization，PSO)由Kennedy和Eberhart在1995年提出，该算法对于Hepper的模拟鸟群(鱼群)的模型进行修正，以使粒子能够飞向解空间，并在最好解处降落，从而得到了粒子群优化算法。\n\n❃同遗传算法类似，也是一种基于群体叠代的，但并没有遗传算法用的交叉以及变异，而是粒子在解空间追随最优的粒子进行搜索。\n\n❃PSO的优势在于简单，容易实现，无需梯度信息，参数少，特别是其天然的实数编码特点特别适合于处理实优化问题。同时又有深刻的智能背景，既适合科学研究，又特别适合工程应用。\n\n\n设想这样一个场景：一群鸟在随机的搜索食物。在这个区域里只有一块食物，所有的鸟都不知道食物在哪。但是它们知道自己当前的位置距离食物还有多远。\n\n                         那么找到食物的最优策略是什么？\n\n最简单有效的就是搜寻目前离食物最近的鸟的周围区域。\n\n二.算法介绍\n(1)简述\n❃每个寻优的问题解都被想像成一只鸟，称为“粒子”。所有粒子都在一个D维空间进行搜索。\n\n❃所有的粒子都由一个fitness-function确定适应值以判断目前的位置好坏。\n\n❃每一个粒子必须赋予记忆功能，能记住所搜寻到的最佳位置。\n\n❃每一个粒子还有一个速度以决定飞行的距离和方向。这个速度根据它本身的飞行经验以及同伴的飞行经验进行动态调整。 \n\n(2)基本PSO算法\n  a.  D维空间中，有m个粒子；\n\n  粒子i位置：xi=(xi1,xi2,…xiD)\n\n  粒子i速度：vi=(vi1,vi2,…viD)，1≤i≤m,1 ≤d ≤D\n\n  粒子i经历过的历史最好位置：pi=(pi1,pi2,…piD)\n\n  群体内（或领域内）所有粒子所经历过的最好位置：\n\n  pg =(pg1,pg2,…pgD)\n\n  PS:一般来说，粒子的位置和速度都是在连续的实数空间内进行取值。\n\n\n\n   b.基本PSO公式\n\n\n\n(3)基本PSO算法流程图\n\n\n\n关于每个粒子的更新速度和位置的公式如下:\n\n\n\n三.简单应用\n\n  \n\n\n(1)•编码：因为问题的维数为5，所以每个粒子为5维的实数向量。\n(2)•初始化范围：根据问题要求，设定为[-30，30]。根据前面的参数分析，我们知道，可以将最大速度设定为Vmax=60。\n(3)•种群大小：为了说明方便，这里采用一个较小的种群规模，m=5。\n(4)•停止准则：设定为最大迭代次数100次。\n(5)•惯性权重：采用固定权重0.5。\n(6)邻域拓扑结构：使用星形拓扑结构，即全局版本的粒子群优化算法\n算法执行的过程如下:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n四.代码实现:运用粒子群算法解决TSP问题\n1.matlab实现\nclose all;\nclear all;\n\nPopSize=500;%种群大小\nCityNum = 14;%城市数\n\nOldBestFitness=0;%旧的最优适应度值\n\nIteration=0;%迭代次数\nMaxIteration =2000;%最大迭代次数\nIsStop=0;%程序停止标志 \nNum=0;%取得相同适应度值的迭代次数\n\nc1=0.5;%认知系数\nc2=0.7;%社会学习系数\nw=0.96-Iteration/MaxIteration;%惯性系数,随迭代次数增加而递减\n\n%节点坐标\nnode=[16.47 96.10; 16.47 94.44; 20.09 92.54; 22.39 93.37; 25.23 97.24;...\n     22.00 96.05; 20.47 97.02; 17.20 96.29; 16.30 97.38; 14.05 98.12;...\n     16.53 97.38; 21.52 95.59; 19.41 97.13; 20.09 94.55];\n\n%初始化各粒子，即产生路径种群\nGroup=ones(CityNum,PopSize);   \nfor i=1:PopSize\n    Group(:,i)=randperm(CityNum)';\nend\nGroup=Arrange(Group);\n\n%初始化粒子速度（即交换序）\nVelocity =zeros(CityNum,PopSize);   \nfor i=1:PopSize\n    Velocity(:,i)=round(rand(1,CityNum)'*CityNum); %round取整\nend\n\n%计算每个城市之间的距离\nCityBetweenDistance=zeros(CityNum,CityNum);   \nfor i=1:CityNum\n    for j=1:CityNum\n        CityBetweenDistance(i,j)=sqrt((node(i,1)-node(j,1))^2+(node(i,2)-node(j,2))^2);\n    end\nend\n\n%计算每条路径的距离\nfor i=1:PopSize   \n        EachPathDis(i) = PathDistance(Group(:,i)',CityBetweenDistance);\nend\n\nIndivdualBest=Group;%记录各粒子的个体极值点位置,即个体找到的最短路径\nIndivdualBestFitness=EachPathDis;%记录最佳适应度值,即个体找到的最短路径的长度\n[GlobalBestFitness,index]=min(EachPathDis);%找出全局最优值和相应序号 \n\n%初始随机解\nfigure;\nsubplot(2,2,1);\nPathPlot(node,CityNum,index,IndivdualBest);\ntitle('随机解');\n\n%寻优\nwhile(IsStop == 0) & (Iteration < MaxIteration) \n    %迭代次数递增\n    Iteration = Iteration +1;  \n    \n    %更新全局极值点位置,这里指路径\n    for i=1:PopSize   \n        GlobalBest(:,i) = Group(:,index);\n      \n    end\n    \n    %求pij-xij ,pgj-xij交换序，并以概率c1，c2的保留交换序\n    pij_xij=GenerateChangeNums(Group,IndivdualBest);  \n    pij_xij=HoldByOdds(pij_xij,c1); \n    pgj_xij=GenerateChangeNums(Group,GlobalBest);\n    pgj_xij=HoldByOdds(pgj_xij,c2);\n    \n    %以概率w保留上一代交换序\n    Velocity=HoldByOdds(Velocity,w);\n\n    Group = PathExchange(Group,Velocity); %根据交换序进行路径交换\n    Group = PathExchange(Group,pij_xij);\n    Group = PathExchange(Group,pgj_xij);\n    for i = 1:PopSize    % 更新各路径总距离\n          EachPathDis(i) = PathDistance(Group(:,i)',CityBetweenDistance);\n    \n    end\n\n    IsChange = EachPathDis<IndivdualBestFitness;%更新后的距离优于更新前的，记录序号\n    IndivdualBest(:, find(IsChange)) = Group(:, find(IsChange));%更新个体最佳路径\n    IndivdualBestFitness = IndivdualBestFitness.*( ~IsChange) + EachPathDis.*IsChange;%更新个体最佳路径距离\n    [GlobalBestFitness, index] = min(EachPathDis);%更新全局最佳路径,记录相应的序号\n   \n    if GlobalBestFitness==OldBestFitness %比较更新前和更新后的适应度值;\n        Num=Num+1; %相等时记录加一;\n    else\n        OldBestFitness=GlobalBestFitness;%不相等时更新适应度值，并记录清零;\n        Num=0;\n    end    \n    if Num >= 20 %多次迭代的适应度值相近时程序停止\n        IsStop=1;\n    end\n\n     BestFitness(Iteration) =GlobalBestFitness;%每一代的最优适应度\n\n\nend\n\n%最优解\nsubplot(2,2,2);\nPathPlot(node,CityNum,index,IndivdualBest);\ntitle('优化解');\n%进化曲线\nsubplot(2,2,3);\nplot((1:Iteration),BestFitness(1:Iteration));\ngrid on;\ntitle('进化曲线');\n%最小路径值\nGlobalBestFitness\n\n运行结果如下:\n\n2.java 实现\npackage pso;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\n \nimport javax.swing.*;\nimport javax.swing.event.*;\npublic class Pso extends Frame implements Runnable\n{\n    private static int particleNumber;  //粒子的数量\n    private static int iterations;      //迭代的次数\n    private static int k=1;             //记录迭代的次数\n    final private static float C1=2;    //学习因子\n    final private static float C2=2;\n    final private static float WMIN=-200;\n    final private static float WMAX=200;\n    final private static float VMAX=200;\n    private static float r1;           //随机数0-1之间\n    private static float r2;\n    private static float x[][];\n    private static float v[][];\n    private static float xpbest[][];\n    private static float pbest[];      \n    private static float gbest=0;\n    private static float xgbest[];\n    private static float w;           //惯性因子\n    private static float s;\n    private static float h;\n    private static float fit[];\n    public Sounds sound;\n    \n    //粒子群的迭代函数\npublic void lzqjs()\n{\n\t  \n\t\tw=(float)(0.9-k*(0.9-0.4)/iterations);\n        for(int i=0;i<particleNumber;i++)\n        {\n                   fit[i]= (float)(1/(Math.pow(x[i][0],2)+Math.pow(x[i][1],2))); //求适值函数最大值\n                   System.out.print(\"粒子\"+i+\"本次适应值函数f为：\" + fit[i]);\n                   System.out.println();\n                   if(fit[i]>pbest[i])\n                   {\n                   \tpbest[i]=fit[i];\n                   \txpbest[i][0]=x[i][0];\n                   \txpbest[i][1]=x[i][1];\n                   }\n                   if(pbest[i]>gbest)\n                   {\n                   \tgbest=pbest[i];\n                   \txgbest[0]=xpbest[i][0];\n                   \txgbest[1]=xpbest[i][1];\n                   }\n         }\n         for(int i=0;i<particleNumber;i++)\n         {\n                   for(int j=0;j<2;j++)\n                   {\n                \t   //粒子速度和位置迭代方程:\n                   \tv[i][j]=(float)(w*v[i][j]+C1*Math.random()*(xpbest[i][j]-x[i][j])+C2*Math.random()*(xgbest[j]-x[i][j]));\n                   \n                   \tx[i][j]=(float)(x[i][j]+v[i][j]);\n                   \n                   }\n               \tSystem.out.print(\"粒子\"+i+\"本次X1的速度变化幅度:\"+v[i][0]+\";本次X2的速度变化幅度:\"+v[i][1]);\n                System.out.println();\n            \tSystem.out.print(\"粒子\"+i+\"本次X1为：\"+x[i][0]+\";本次X2为：\"+x[i][1]);\n                System.out.println();\n         }\n}\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tparticleNumber=Integer.parseInt(JOptionPane.showInputDialog(\"请输入粒子个数1-500）\"));\n\t\titerations=Integer.parseInt(JOptionPane.showInputDialog(\"请输入迭代次数\"));\n\t\tx=new float [particleNumber][2];\n\t\tv=new float [particleNumber][2];\n\t\tfit=new float [particleNumber];    //存储适值函数值\n\t\tpbest=new float [particleNumber];  //存储整个粒子群的最有位置\n\t\txpbest=new float [particleNumber][2];\n\t\txgbest=new float [2];\n\t\tfor(int i=0;i<particleNumber;i++)\n\t\t{\n\t\t\t\n\t\t\t//对数组的初始化操作\n\t\t\tpbest[i]=0;\n\t\t\txpbest[i][0]=0;\n\t\t\txpbest[i][1]=0;\n\t\t}\n\t\txgbest[0]=0;\n\t\txgbest[1]=0;\n\t\t System.out.println(\"开始初始化：\");\n\t\tfor(int i=0;i<particleNumber;i++)\n\t\t{\n\t\t\t\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\t//任意给定每个位置一定的位置值和速度值\n\t\t\t\tx[i][j]=(float)(WMAX*Math.random()+WMIN);\n\t\t\t\tv[i][j]=(float)(VMAX*Math.random());\n\t\t\t}\n\t\t\tSystem.out.print(\"粒子\"+i+\"本次X1的变化幅度:\"+v[i][0]+\";本次X2的变化幅度:\"+v[i][1]);\n\t\t \t System.out.println();\n\t\t \tSystem.out.print(\"粒子\"+i+\"本次X1为：\"+x[i][0]+\";本次X2为：\"+x[i][1]);\n\t\t\t System.out.println();\n\t\t}\n\t\tSystem.out.println(\"初始化数据结束，开始迭代.....\");\n\tPso threada=new Pso();\n\tthreada.setTitle(\"基于粒子群的粒子位置动态显示\");\n\tthreada.setSize(800,800);\n\tthreada.addWindowListener(new gbck());\n\tthreada.setVisible(true);\n        Thread threadc=new Thread(threada);\n        threadc.start();\n\t}\n\tstatic class gbck extends WindowAdapter\n\t{\n\t\tpublic void windowClosing(WindowEvent e)\n\t\t{\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\t\n\t//开启的额外线程用于声音的播放\n\tpublic void run()\n\t{\n       \n\t\trepaint();\n        \n        for(int i=0;i<iterations;i++){\n        \tsound();\n        }\n\t}\n\tpublic void paint(Graphics g)\n\t{\n\t\t \n\t\t   g.setColor(new Color(0,0,0));\n\t       for(int i=0;i<particleNumber;i++)\n\t       {\n\t       \tg.drawString(\"*\",(int)(x[i][0]+200),(int)(x[i][1]+200));\n\t       }\n\t       g.setColor(new Color(255,0,0));\n\t       g.drawString(\"全局最优适应度函数值：\"+gbest+\"      参数1：\"+xgbest[0]+\"     参数2：\"+xgbest[1]+\"    迭代次数：\"+ k,50,725);\n \n    try\n\t{\n\tlzqjs();  //开始迭代\n\t\n\tif(k>=iterations)\n\t{\n\t\t\n\t\tThread.sleep((int)(5000));\n\t\tSystem.exit(0);\n\t}\n\tk=k+1;  //每次迭代一次加1操作\n\tThread.sleep((int)(1000));\n\t}\n    catch(InterruptedException e)\n    {\n\t\t System.out.println(e.toString());\n    }\n    repaint();\n\t}\n\tpublic  void sound(){\n\t\t  sound =new Sounds(\"050.wav\");\n\t\t  InputStream stream =new ByteArrayInputStream(sound.getSamples());\n\t\t  // play the sound\n\t\t  sound.play(stream);\n\t\t  // exit\n \n\t}\n}\n运行的结果如下:\n\n\n\n"]],[9,9],[8813,8813]]],[1562825018324,["GJX@GJXAIOU",[[-1,21,"\n"]],[22,22],[21,21]]],[1562825018826,["GJX@GJXAIOU",[[-1,20,"\n"]],[21,21],[20,20]]],[1562825020186,["GJX@GJXAIOU",[[-1,18,"  "]],[20,20],[18,18]]],[1562825027362,["GJX@GJXAIOU",[[1,9,"## "]],[9,9],[18,18]]],[1562825029732,["GJX@GJXAIOU",[[1,436,"## "]],[436,436],[445,445]]],[1562825045770,["GJX@GJXAIOU",[[-1,295,"\n"]],[295,295],[294,294]]],[1562825047170,["GJX@GJXAIOU",[[-1,365,"\n"]],[365,365],[364,364]]],[1562825050114,["GJX@GJXAIOU",[[-1,365,"                         "]],[365,390],[365,365]]],[1562825056666,["GJX@GJXAIOU",[[1,390,"**"],[1,406,"**"]],[390,406],[390,410]]],[1562825065242,["GJX@GJXAIOU",[[1,150,"**"],[1,206,"**"]],[150,206],[150,210]]],[1562825088485,["GJX@GJXAIOU",[[1,427,"### "]],[427,427],[436,436]]],[1562825100747,["GJX@GJXAIOU",[[-1,480,"\n"]],[480,480],[479,479]]],[1562825102898,["GJX@GJXAIOU",[[-1,524,"❃"]],[525,525],[524,524]]],[1562825105028,["GJX@GJXAIOU",[[-1,523,"\n"]],[524,524],[523,523]]],[1562825107162,["GJX@GJXAIOU",[[-1,551,"\n"]],[551,551],[550,550]]],[1562825110322,["GJX@GJXAIOU",[[-1,437,"❃"]],[438,438],[437,437]]],[1562825111576,["GJX@GJXAIOU",[[-1,20," "],[1,21," "],[-1,437,""],[1,437,"-"],[-1,604," "],[1,605," "],[-1,618," "],[1,619," "],[-1,623," "],[1,624," "],[-1,638," "],[1,639," "],[-1,665," "],[1,666," "],[-1,706," "],[1,707," "],[-1,741," "],[1,742," "],[-1,768," "],[1,769," "],[-1,790," "],[1,791," "],[-1,828,"  "],[1,830,"  "],[-1,893,"  "],[1,895,"  "]],[437,437],[438,438]]],[1562825111750,["GJX@GJXAIOU",[[1,438," "]],[438,438],[439,439]]],[1562825113420,["GJX@GJXAIOU",[[-1,481,"❃"]],[482,482],[481,481]]],[1562825114124,["GJX@GJXAIOU",[[1,481,"- "]],[481,481],[483,483]]],[1562825115857,["GJX@GJXAIOU",[[-1,553,"❃"]],[554,554],[553,553]]],[1562825116044,["GJX@GJXAIOU",[[-1,552,"\n"]],[553,553],[552,552]]],[1562825116590,["GJX@GJXAIOU",[[1,552,"- "]],[552,552],[554,554]]],[1562825118685,["GJX@GJXAIOU",[[1,552,"\n"]],[552,552],[553,553]]],[1562825123130,["GJX@GJXAIOU",[[1,611,"### "]],[611,611],[625,625]]],[1562825142586,["GJX@GJXAIOU",[[1,626,"#### "]],[628,628],[649,649]]],[1562825157193,["GJX@GJXAIOU",[[1,534,"**"],[1,538,"**"]],[534,538],[534,542]]],[1562825162513,["GJX@GJXAIOU",[[1,576,"**"],[1,581,"**"]],[576,581],[576,585]]],[1562825180859,["GJX@GJXAIOU",[[1,821,"**"],[1,844,"**"]],[821,844],[821,848]]],[1562825186441,["GJX@GJXAIOU",[[-1,685,"\n"]],[685,685],[684,684]]],[1562825187328,["GJX@GJXAIOU",[[-1,725,"\n"]],[725,725],[724,724]]],[1562825188075,["GJX@GJXAIOU",[[-1,759,"\n"]],[759,759],[758,758]]],[1562825188834,["GJX@GJXAIOU",[[-1,785,"\n"]],[785,785],[784,784]]],[1562825190768,["GJX@GJXAIOU",[[-1,785,"  "]],[787,787],[785,785]]],[1562825191201,["GJX@GJXAIOU",[[-1,784,"\n"]],[785,785],[784,784]]],[1562825195802,["GJX@GJXAIOU",[[1,661,"* "],[1,686," *"],[1,727,"* "],[1,760," *"]],[661,791],[663,799]]],[1562825201403,["GJX@GJXAIOU",[[-1,853,"\n"]],[853,853],[852,852]]],[1562825201553,["GJX@GJXAIOU",[[-1,852,"\n"]],[852,852],[851,851]]],[1562825204913,["GJX@GJXAIOU",[[1,852,"#### "]],[854,854],[869,869]]],[1562825304763,["GJX@GJXAIOU",[[1,871,"$V_{\\mathrm{iD}}^{k+1}=V_{i D}^{k}+c_{1} r_{1}\\left(p_{i D}^{k}-X_{i D}^{k}\\right)+c_{2} r_{2}\\left(p_{g D}^{k}-X_{i D}^{k}\\right)$\n$X_{\\mathrm{iD}}^{k+1}=X_{i D}^{k}+V_{i D}^{k+1}$"]],[871,871],[1052,1052]]],[1562825317545,["GJX@GJXAIOU",[[-1,1054,"(3)"],[1,1057,"C"]],[1054,1054],[1055,1055]]],[1562825320274,["GJX@GJXAIOU",[[1,1054,"#### "]],[1054,1054],[1070,1070]]],[1562825322908,["GJX@GJXAIOU",[[1,1060,"，。"]],[1060,1060],[1062,1062]]],[1562825324209,["GJX@GJXAIOU",[[-1,1060,"，。"]],[1062,1062],[1060,1060]]],[1562825325046,["GJX@GJXAIOU",[[1,1060,"."]],[1060,1060],[1061,1061]]],[1562825332273,["GJX@GJXAIOU",[[1,1054,"\n"]],[1052,1052],[1053,1053]]],[1562825337115,["GJX@GJXAIOU",[[1,1053,"C1"]],[1053,1053],[1055,1055]]],[1562825338169,["GJX@GJXAIOU",[[-1,1054,"1"]],[1055,1055],[1054,1054]]],[1562825339292,["GJX@GJXAIOU",[[1,1054,"c"]],[1054,1054],[1055,1055]]],[1562825340699,["GJX@GJXAIOU",[[-1,1053,"Cc"]],[1055,1055],[1053,1053]]],[1562825378266,["GJX@GJXAIOU",[[1,1053,"qwizho"]],[1053,1053],[1059,1059]]],[1562825379505,["GJX@GJXAIOU",[[-1,1053,"qwizho"]],[1059,1059],[1053,1053]]],[1562825383300,["GJX@GJXAIOU",[[1,1053,"其中C1"]],[1053,1053],[1057,1057]]],[1562825383338,["GJX@GJXAIOU",[[1,1055," "]],[1057,1057],[1058,1058]]],[1562825407653,["GJX@GJXAIOU",[[1,1058,"、C2：学习因子或者加速系数，一般为正常数。通常为2"]],[1058,1058],[1084,1084]]],[1562825407689,["GJX@GJXAIOU",[[1,1083," "]],[1084,1084],[1085,1085]]],[1562825407852,["GJX@GJXAIOU",[[1,1085,"；"]],[1085,1085],[1086,1086]]],[1562825408256,["GJX@GJXAIOU",[[1,1088,"\n"]],[1086,1086],[1087,1087]]],[1562825411132,["GJX@GJXAIOU",[[1,1087,"人"]],[1087,1087],[1088,1088]]],[1562825411976,["GJX@GJXAIOU",[[-1,1087,"人"]],[1088,1088],[1087,1087]]],[1562825415411,["GJX@GJXAIOU",[[1,1087,"r1/r2"]],[1087,1087],[1092,1092]]],[1562825416978,["GJX@GJXAIOU",[[-1,1089,"/"]],[1090,1090],[1089,1089]]],[1562825417643,["GJX@GJXAIOU",[[1,1089,","]],[1089,1089],[1090,1090]]],[1562825420819,["GJX@GJXAIOU",[[1,1092,"："]],[1092,1092],[1093,1093]]],[1562825426374,["GJX@GJXAIOU",[[1,1093,"取值范围为【"]],[1093,1093],[1099,1099]]],[1562825426705,["GJX@GJXAIOU",[[-1,1098,"【"]],[1099,1099],[1098,1098]]],[1562825427766,["GJX@GJXAIOU",[[1,1098,"[1"]],[1098,1098],[1100,1100]]],[1562825428241,["GJX@GJXAIOU",[[-1,1099,"1"]],[1100,1100],[1099,1099]]],[1562825447901,["GJX@GJXAIOU",[[1,1099,"0,1] ，是该区间内均匀分布的伪随机数；"]],[1099,1099],[1120,1120]]],[1562825448139,["GJX@GJXAIOU",[[1,1122,"\n"]],[1120,1120],[1121,1121]]],[1562825466977,["GJX@GJXAIOU",[[1,1121,"Vmax：粒子速度能达到的最大是"]],[1121,1121],[1137,1137]]],[1562825467569,["GJX@GJXAIOU",[[-1,1136,"是"]],[1137,1137],[1136,1136]]],[1562825468546,["GJX@GJXAIOU",[[1,1136,"值；"]],[1136,1136],[1138,1138]]],[1562825521706,["GJX@GJXAIOU",[[1,1158,"![PSO流程图]($resource/PSO%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg)"]],[1158,1158],[1214,1214]]],[1562825553521,["GJX@GJXAIOU",[[1,1293,"## "]],[1293,1293],[1302,1302]]],[1562825555720,["GJX@GJXAIOU",[[-1,1308,"\n"]],[1307,1307],[1306,1306]]],[1562825555897,["GJX@GJXAIOU",[[-1,1305," "]],[1306,1306],[1305,1305]]],[1562825576950,["GJX@GJXAIOU",[[1,1306,"![20161202143848292]($resource/20161202143848292.jpg)"]],[1305,1305],[1360,1360]]]],null,"GJX@GJXAIOU"],["89cbcdbd-4321-4540-98ad-b40494023647",1562829192806,"# 粒子群算法\n\n## 一.产生背景\n\n ❃粒子群算法(particleswarm optimization，PSO)由Kennedy和Eberhart在1995年提出，该算法对于Hepper的模拟鸟群(鱼群)的模型进行修正，以使粒子能够飞向解空间，并在最好解处降落，从而得到了粒子群优化算法。\n\n❃**同遗传算法类似，也是一种基于群体叠代的，但并没有遗传算法用的交叉以及变异，而是粒子在解空间追随最优的粒子进行搜索**。\n\n❃PSO的优势在于简单，容易实现，无需梯度信息，参数少，特别是其天然的实数编码特点特别适合于处理实优化问题。同时又有深刻的智能背景，既适合科学研究，又特别适合工程应用。\n\n设想这样一个场景：一群鸟在随机的搜索食物。在这个区域里只有一块食物，所有的鸟都不知道食物在哪。但是它们知道自己当前的位置距离食物还有多远。\n那么找到食物的最优策略是什么？\n\n最简单有效的就是**搜寻目前离食物最近的鸟的周围区域**。\n\n## 二.算法介绍\n### (1)简述\n- 每个寻优的问题解都被想像成一只鸟，称为“粒子”。所有粒子都在一个D维空间进行搜索。\n- 所有的粒子都由一个fitness-function确定适应值以判断目前的位置好坏。\n每一个粒子必须赋予**记忆功能**，能记住所搜寻到的最佳位置。\n- 每一个粒子还有一个速度以决定飞行的**距离和方向**。这个速度根据它本身的飞行经验以及同伴的飞行经验进行动态调整。 \n\n### (2)基本PSO算法\n####   a.  D维空间中，有m个粒子；\n\n  * 粒子i位置：xi=(xi1,xi2,…xiD)\n  * 粒子i速度：vi=(vi1,vi2,…viD)，1≤i≤m,1 ≤d ≤D\n  * 粒子i经历过的历史最好位置：pi=(pi1,pi2,…piD)\n  * 群体内（或领域内）所有粒子所经历过的最好位置：pg =(pg1,pg2,…pgD)\n\n  PS:一般来说，**粒子的位置和速度都是在连续的实数空间内进行取值**。\n\n####    b.基本PSO公式\n\n$V_{\\mathrm{iD}}^{k+1}=V_{i D}^{k}+c_{1} r_{1}\\left(p_{i D}^{k}-X_{i D}^{k}\\right)+c_{2} r_{2}\\left(p_{g D}^{k}-X_{i D}^{k}\\right)$\n$X_{\\mathrm{iD}}^{k+1}=X_{i D}^{k}+V_{i D}^{k+1}$\n其中 C1、C2：学习因子或者加速系数，一般为正常数。通常为 2；\nr1,r2：取值范围为[0,1] ，是该区间内均匀分布的伪随机数；\nVmax：粒子速度能达到的最大值；\n\n#### C.基本PSO算法流程图\n![PSO流程图]($resource/PSO%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg)\n\n\n关于每个粒子的更新速度和位置的公式如下:\n![20161202143639869]($resource/20161202143639869.jpg)\n\n\n## 三.简单应用\n\n \n![20161202143848292]($resource/20161202143848292.jpg)\n(1)•编码：因为问题的维数为5，所以每个粒子为5维的实数向量。\n(2)•初始化范围：根据问题要求，设定为[-30，30]。根据前面的参数分析，我们知道，可以将最大速度设定为Vmax=60。\n(3)•种群大小：为了说明方便，这里采用一个较小的种群规模，m=5。\n(4)•停止准则：设定为最大迭代次数100次。\n(5)•惯性权重：采用固定权重0.5。\n(6)邻域拓扑结构：使用星形拓扑结构，即全局版本的粒子群优化算法\n算法执行的过程如下:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n四.代码实现:运用粒子群算法解决TSP问题\n1.matlab实现\nclose all;\nclear all;\n\nPopSize=500;%种群大小\nCityNum = 14;%城市数\n\nOldBestFitness=0;%旧的最优适应度值\n\nIteration=0;%迭代次数\nMaxIteration =2000;%最大迭代次数\nIsStop=0;%程序停止标志 \nNum=0;%取得相同适应度值的迭代次数\n\nc1=0.5;%认知系数\nc2=0.7;%社会学习系数\nw=0.96-Iteration/MaxIteration;%惯性系数,随迭代次数增加而递减\n\n%节点坐标\nnode=[16.47 96.10; 16.47 94.44; 20.09 92.54; 22.39 93.37; 25.23 97.24;...\n     22.00 96.05; 20.47 97.02; 17.20 96.29; 16.30 97.38; 14.05 98.12;...\n     16.53 97.38; 21.52 95.59; 19.41 97.13; 20.09 94.55];\n\n%初始化各粒子，即产生路径种群\nGroup=ones(CityNum,PopSize);   \nfor i=1:PopSize\n    Group(:,i)=randperm(CityNum)';\nend\nGroup=Arrange(Group);\n\n%初始化粒子速度（即交换序）\nVelocity =zeros(CityNum,PopSize);   \nfor i=1:PopSize\n    Velocity(:,i)=round(rand(1,CityNum)'*CityNum); %round取整\nend\n\n%计算每个城市之间的距离\nCityBetweenDistance=zeros(CityNum,CityNum);   \nfor i=1:CityNum\n    for j=1:CityNum\n        CityBetweenDistance(i,j)=sqrt((node(i,1)-node(j,1))^2+(node(i,2)-node(j,2))^2);\n    end\nend\n\n%计算每条路径的距离\nfor i=1:PopSize   \n        EachPathDis(i) = PathDistance(Group(:,i)',CityBetweenDistance);\nend\n\nIndivdualBest=Group;%记录各粒子的个体极值点位置,即个体找到的最短路径\nIndivdualBestFitness=EachPathDis;%记录最佳适应度值,即个体找到的最短路径的长度\n[GlobalBestFitness,index]=min(EachPathDis);%找出全局最优值和相应序号 \n\n%初始随机解\nfigure;\nsubplot(2,2,1);\nPathPlot(node,CityNum,index,IndivdualBest);\ntitle('随机解');\n\n%寻优\nwhile(IsStop == 0) & (Iteration < MaxIteration) \n    %迭代次数递增\n    Iteration = Iteration +1;  \n    \n    %更新全局极值点位置,这里指路径\n    for i=1:PopSize   \n        GlobalBest(:,i) = Group(:,index);\n      \n    end\n    \n    %求pij-xij ,pgj-xij交换序，并以概率c1，c2的保留交换序\n    pij_xij=GenerateChangeNums(Group,IndivdualBest);  \n    pij_xij=HoldByOdds(pij_xij,c1); \n    pgj_xij=GenerateChangeNums(Group,GlobalBest);\n    pgj_xij=HoldByOdds(pgj_xij,c2);\n    \n    %以概率w保留上一代交换序\n    Velocity=HoldByOdds(Velocity,w);\n\n    Group = PathExchange(Group,Velocity); %根据交换序进行路径交换\n    Group = PathExchange(Group,pij_xij);\n    Group = PathExchange(Group,pgj_xij);\n    for i = 1:PopSize    % 更新各路径总距离\n          EachPathDis(i) = PathDistance(Group(:,i)',CityBetweenDistance);\n    \n    end\n\n    IsChange = EachPathDis<IndivdualBestFitness;%更新后的距离优于更新前的，记录序号\n    IndivdualBest(:, find(IsChange)) = Group(:, find(IsChange));%更新个体最佳路径\n    IndivdualBestFitness = IndivdualBestFitness.*( ~IsChange) + EachPathDis.*IsChange;%更新个体最佳路径距离\n    [GlobalBestFitness, index] = min(EachPathDis);%更新全局最佳路径,记录相应的序号\n   \n    if GlobalBestFitness==OldBestFitness %比较更新前和更新后的适应度值;\n        Num=Num+1; %相等时记录加一;\n    else\n        OldBestFitness=GlobalBestFitness;%不相等时更新适应度值，并记录清零;\n        Num=0;\n    end    \n    if Num >= 20 %多次迭代的适应度值相近时程序停止\n        IsStop=1;\n    end\n\n     BestFitness(Iteration) =GlobalBestFitness;%每一代的最优适应度\n\n\nend\n\n%最优解\nsubplot(2,2,2);\nPathPlot(node,CityNum,index,IndivdualBest);\ntitle('优化解');\n%进化曲线\nsubplot(2,2,3);\nplot((1:Iteration),BestFitness(1:Iteration));\ngrid on;\ntitle('进化曲线');\n%最小路径值\nGlobalBestFitness\n\n运行结果如下:\n\n2.java 实现\npackage pso;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\n \nimport javax.swing.*;\nimport javax.swing.event.*;\npublic class Pso extends Frame implements Runnable\n{\n    private static int particleNumber;  //粒子的数量\n    private static int iterations;      //迭代的次数\n    private static int k=1;             //记录迭代的次数\n    final private static float C1=2;    //学习因子\n    final private static float C2=2;\n    final private static float WMIN=-200;\n    final private static float WMAX=200;\n    final private static float VMAX=200;\n    private static float r1;           //随机数0-1之间\n    private static float r2;\n    private static float x[][];\n    private static float v[][];\n    private static float xpbest[][];\n    private static float pbest[];      \n    private static float gbest=0;\n    private static float xgbest[];\n    private static float w;           //惯性因子\n    private static float s;\n    private static float h;\n    private static float fit[];\n    public Sounds sound;\n    \n    //粒子群的迭代函数\npublic void lzqjs()\n{\n\t  \n\t\tw=(float)(0.9-k*(0.9-0.4)/iterations);\n        for(int i=0;i<particleNumber;i++)\n        {\n                   fit[i]= (float)(1/(Math.pow(x[i][0],2)+Math.pow(x[i][1],2))); //求适值函数最大值\n                   System.out.print(\"粒子\"+i+\"本次适应值函数f为：\" + fit[i]);\n                   System.out.println();\n                   if(fit[i]>pbest[i])\n                   {\n                   \tpbest[i]=fit[i];\n                   \txpbest[i][0]=x[i][0];\n                   \txpbest[i][1]=x[i][1];\n                   }\n                   if(pbest[i]>gbest)\n                   {\n                   \tgbest=pbest[i];\n                   \txgbest[0]=xpbest[i][0];\n                   \txgbest[1]=xpbest[i][1];\n                   }\n         }\n         for(int i=0;i<particleNumber;i++)\n         {\n                   for(int j=0;j<2;j++)\n                   {\n                \t   //粒子速度和位置迭代方程:\n                   \tv[i][j]=(float)(w*v[i][j]+C1*Math.random()*(xpbest[i][j]-x[i][j])+C2*Math.random()*(xgbest[j]-x[i][j]));\n                   \n                   \tx[i][j]=(float)(x[i][j]+v[i][j]);\n                   \n                   }\n               \tSystem.out.print(\"粒子\"+i+\"本次X1的速度变化幅度:\"+v[i][0]+\";本次X2的速度变化幅度:\"+v[i][1]);\n                System.out.println();\n            \tSystem.out.print(\"粒子\"+i+\"本次X1为：\"+x[i][0]+\";本次X2为：\"+x[i][1]);\n                System.out.println();\n         }\n}\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tparticleNumber=Integer.parseInt(JOptionPane.showInputDialog(\"请输入粒子个数1-500）\"));\n\t\titerations=Integer.parseInt(JOptionPane.showInputDialog(\"请输入迭代次数\"));\n\t\tx=new float [particleNumber][2];\n\t\tv=new float [particleNumber][2];\n\t\tfit=new float [particleNumber];    //存储适值函数值\n\t\tpbest=new float [particleNumber];  //存储整个粒子群的最有位置\n\t\txpbest=new float [particleNumber][2];\n\t\txgbest=new float [2];\n\t\tfor(int i=0;i<particleNumber;i++)\n\t\t{\n\t\t\t\n\t\t\t//对数组的初始化操作\n\t\t\tpbest[i]=0;\n\t\t\txpbest[i][0]=0;\n\t\t\txpbest[i][1]=0;\n\t\t}\n\t\txgbest[0]=0;\n\t\txgbest[1]=0;\n\t\t System.out.println(\"开始初始化：\");\n\t\tfor(int i=0;i<particleNumber;i++)\n\t\t{\n\t\t\t\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\t//任意给定每个位置一定的位置值和速度值\n\t\t\t\tx[i][j]=(float)(WMAX*Math.random()+WMIN);\n\t\t\t\tv[i][j]=(float)(VMAX*Math.random());\n\t\t\t}\n\t\t\tSystem.out.print(\"粒子\"+i+\"本次X1的变化幅度:\"+v[i][0]+\";本次X2的变化幅度:\"+v[i][1]);\n\t\t \t System.out.println();\n\t\t \tSystem.out.print(\"粒子\"+i+\"本次X1为：\"+x[i][0]+\";本次X2为：\"+x[i][1]);\n\t\t\t System.out.println();\n\t\t}\n\t\tSystem.out.println(\"初始化数据结束，开始迭代.....\");\n\tPso threada=new Pso();\n\tthreada.setTitle(\"基于粒子群的粒子位置动态显示\");\n\tthreada.setSize(800,800);\n\tthreada.addWindowListener(new gbck());\n\tthreada.setVisible(true);\n        Thread threadc=new Thread(threada);\n        threadc.start();\n\t}\n\tstatic class gbck extends WindowAdapter\n\t{\n\t\tpublic void windowClosing(WindowEvent e)\n\t\t{\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\t\n\t//开启的额外线程用于声音的播放\n\tpublic void run()\n\t{\n       \n\t\trepaint();\n        \n        for(int i=0;i<iterations;i++){\n        \tsound();\n        }\n\t}\n\tpublic void paint(Graphics g)\n\t{\n\t\t \n\t\t   g.setColor(new Color(0,0,0));\n\t       for(int i=0;i<particleNumber;i++)\n\t       {\n\t       \tg.drawString(\"*\",(int)(x[i][0]+200),(int)(x[i][1]+200));\n\t       }\n\t       g.setColor(new Color(255,0,0));\n\t       g.drawString(\"全局最优适应度函数值：\"+gbest+\"      参数1：\"+xgbest[0]+\"     参数2：\"+xgbest[1]+\"    迭代次数：\"+ k,50,725);\n \n    try\n\t{\n\tlzqjs();  //开始迭代\n\t\n\tif(k>=iterations)\n\t{\n\t\t\n\t\tThread.sleep((int)(5000));\n\t\tSystem.exit(0);\n\t}\n\tk=k+1;  //每次迭代一次加1操作\n\tThread.sleep((int)(1000));\n\t}\n    catch(InterruptedException e)\n    {\n\t\t System.out.println(e.toString());\n    }\n    repaint();\n\t}\n\tpublic  void sound(){\n\t\t  sound =new Sounds(\"050.wav\");\n\t\t  InputStream stream =new ByteArrayInputStream(sound.getSamples());\n\t\t  // play the sound\n\t\t  sound.play(stream);\n\t\t  // exit\n \n\t}\n}\n运行的结果如下:\n\n\n\n\n\n",[[1562829135779,["GJX@GJXAIOU",[[1,1580,"****"]],[1580,1580],[1582,1582]]],[1562829138793,["GJX@GJXAIOU",[[1,1582,"初始化位置："]],[1582,1582],[1588,1588]]],[1562829140535,["GJX@GJXAIOU",[[1,1605,"\n"]],[1590,1590],[1591,1591]]],[1562829141783,["GJX@GJXAIOU",[[1,1591,"$X_{1}^{0}=(-15.061812,-23.799465,25.508911,4.867607,-4.6115036)$\n$X_{2}^{0}=(29.855438,-25.405956,6.2448387,10.079713,-26.621386)$\n$X_{3}^{0}=(23.805588,19.57822,-8.61554,9.441231,-29.898735)$\n$X_{4}^{0}=(7.1804657,-13.258207-29.63405,-27.048172,2.24227979)$\n$X_{5}^{0}=(-4.7385902,-17.732449-24,78365-3.8092823,4.3552284)$"]],[1591,1591],[1915,1915]]],[1562829150575,["GJX@GJXAIOU",[[1,1917,"****"]],[1917,1917],[1919,1919]]],[1562829156080,["GJX@GJXAIOU",[[1,1919,"初始化速度："]],[1919,1919],[1925,1925]]],[1562829157560,["GJX@GJXAIOU",[[1,1940,"\n"]],[1927,1927],[1928,1928]]],[1562829174534,["GJX@GJXAIOU",[[1,1928,"$V_{1}^{0}=(-5.2273927,15.964569-11.821243,42.65571,-48.36218)$\n$V_{2}^{0}=(-0.42986897,-0.5701652,-18.416643,-51.86605,-33.90133)$\n$V_{3}^{0}=(13.069403,-48.511078,28.80003,-8.051167,-28.049505)$\n$V_{4}^{0}=(-8.85361,12.998845,-13.325946,18.722532,-26.033237)$\n$V_{5}^{0}=(-5.7461033,-7.451118,29.135513,-14.144024,-41.325256)$"]],[1928,1928],[2256,2256]]],[1562829249043,["GJX@GJXAIOU",[[1,1884,"，"]],[1884,1884],[1885,1885]]],[1562829252358,["GJX@GJXAIOU",[[-1,1884,"，"]],[1885,1885],[1884,1884]]],[1562829253705,["GJX@GJXAIOU",[[1,1884,","]],[1884,1884],[1885,1885]]],[1562829255646,["GJX@GJXAIOU",[[-1,1888,","]],[1889,1889],[1888,1888]]],[1562829261034,["GJX@GJXAIOU",[[1,1893,","]],[1893,1893],[1894,1894]]],[1562829266810,["GJX@GJXAIOU",[[1,1817,","]],[1817,1817],[1818,1818]]],[1562829293553,["GJX@GJXAIOU",[[1,2260,"****"]],[2260,2260],[2262,2262]]],[1562829294610,["GJX@GJXAIOU",[[1,2262,"gege"]],[2262,2262],[2266,2266]]],[1562829295286,["GJX@GJXAIOU",[[-1,2262,"gege"]],[2266,2266],[2262,2262]]],[1562829298042,["GJX@GJXAIOU",[[1,2262,"各个例子的"]],[2262,2262],[2267,2267]]],[1562829300062,["GJX@GJXAIOU",[[-1,2264,"例子的"]],[2267,2267],[2264,2264]]],[1562829307203,["GJX@GJXAIOU",[[1,2264,"粒子的初试适应值："]],[2264,2264],[2273,2273]]],[1562829308631,["GJX@GJXAIOU",[[1,2286,"\n"]],[2275,2275],[2276,2276]]],[1562829326701,["GJX@GJXAIOU",[[1,2276,"$f_{1}^{0}=7.733296 \\mathrm{E} 7$\n$f_{2}^{0}=1.26632864 \\mathrm{E} 8$\n$f_{3}^{0}=4.7132888 \\mathrm{E} 7$\n$f_{4}^{0}=1.39781552 \\mathrm{E} 8$\n$f_{5}^{0}=4.98773 \\mathrm{E} 7$"]],[2276,2276],[2449,2449]]],[1562829369467,["GJX@GJXAIOU",[[1,2451,"此时取得最好"]],[2451,2451],[2457,2457]]],[1562829380938,["GJX@GJXAIOU",[[1,2457,"解的是粒子3"]],[2457,2457],[2463,2463]]],[1562829380977,["GJX@GJXAIOU",[[1,2462," "]],[2463,2463],[2464,2464]]],[1562829381874,["GJX@GJXAIOU",[[1,2464,"."]],[2464,2464],[2465,2465]]],[1562829382679,["GJX@GJXAIOU",[[1,2474,"\n"]],[2465,2465],[2466,2466]]],[1562829383750,["GJX@GJXAIOU",[[1,2475,"\n"]],[2466,2466],[2467,2467]]],[1562829397074,["GJX@GJXAIOU",[[1,2467,"经过一次迭代之后粒子的位置变化为："]],[2467,2467],[2484,2484]]],[1562829397471,["GJX@GJXAIOU",[[1,2493,"\n"]],[2484,2484],[2485,2485]]],[1562829419110,["GJX@GJXAIOU",[[1,2486,"$X_{1}^{1}=(2.4265985,29.665405,18.387815,29.66393,-39.97371)$\n$X_{1}^{1}=(22.56745,-3.999012,-19.23571,-16.373426,-45.417023)$\n$X_{3}^{1}=(30.34029,-4.6773186,5.7844753 .5 .4156475,-43.92349)$\n$X_{4}^{1}=(2.7943296,19.942759,-24.861498,16.060974,-57.757202)$\n$X_{5}^{1}=(27.509708,28.379063,13.016331,11.539068,-53.676777)$"]],[2486,2486],[2810,2810]]],[1562829461972,["GJX@GJXAIOU",[[1,2812,"从上面的数据可以看到，粒子有的"]],[2812,2812],[2827,2827]]],[1562829546746,["GJX@GJXAIOU",[[1,2827,"分量跑出了初始化范围，"]],[2827,2827],[2838,2838]]],[1562829547463,["GJX@GJXAIOU",[[-1,2837,"，"]],[2838,2838],[2837,2837]]],[1562829551386,["GJX@GJXAIOU",[[1,2837,"。需要说明的"]],[2837,2837],[2843,2843]]],[1562829552235,["GJX@GJXAIOU",[[1,2843,"屙屎"]],[2843,2843],[2845,2845]]],[1562829552854,["GJX@GJXAIOU",[[-1,2843,"屙屎"]],[2845,2845],[2843,2843]]],[1562829610891,["GJX@GJXAIOU",[[1,2843,"是，在这种情况下，我们一般不强行将粒子拉回到初始化空间，即使初始化空间也是粒子的约束空间。因为"]],[2843,2843],[2890,2890]]],[1562829636059,["GJX@GJXAIOU",[[1,2890,"，即使粒子跑出初始化坤宁宫"]],[2890,2890],[2903,2903]]],[1562829637103,["GJX@GJXAIOU",[[-1,2900,"坤宁宫"]],[2903,2903],[2900,2900]]],[1562829659678,["GJX@GJXAIOU",[[1,2900,"空间，随着迭代的进行，如果在初始化空间内有更高"]],[2900,2900],[2923,2923]]],[1562829660414,["GJX@GJXAIOU",[[-1,2922,"高"]],[2923,2923],[2922,2922]]],[1562829670099,["GJX@GJXAIOU",[[1,2922,"好的解存在，那么粒子"]],[2922,2922],[2932,2932]]],[1562829690532,["GJX@GJXAIOU",[[1,2932,"也可以自行返回到初始化空间。"]],[2932,2932],[2946,2946]]],[1562829691017,["GJX@GJXAIOU",[[1,2952,"\n"]],[2946,2946],[2947,2947]]],[1562829729551,["GJX@GJXAIOU",[[1,2947,"有研究表明，即使将初始化空间不设定为问题的约束空间，粒子也可能找到最优解"]],[2947,2947],[2983,2983]]],[1562829731833,["GJX@GJXAIOU",[[1,2983,"。"]],[2983,2983],[2984,2984]]],[1562829739814,["GJX@GJXAIOU",[[1,2990,"\n"]],[2984,2984],[2985,2985]]],[1562829739942,["GJX@GJXAIOU",[[1,2991,"\n"]],[2985,2985],[2986,2986]]],[1562829740995,["GJX@GJXAIOU",[[1,2986,"****"]],[2986,2986],[2988,2988]]],[1562829751705,["GJX@GJXAIOU",[[1,2988,"第一次迭代之后，自个粒子的适应值为："]],[2988,2988],[3006,3006]]],[1562829753142,["GJX@GJXAIOU",[[1,3014,"\n"]],[3008,3008],[3009,3009]]],[1562829763296,["GJX@GJXAIOU",[[1,3010,"$f_{1}^{1}=1.68403632 E 8$\n$f_{2}^{1}=5.122986 E 7$\n$f_{3}^{1}=8.6243528 E 7$\n$f_{4}^{1}=6.4084752 E 7$\n$f_{5}^{1}=1.21824928 E 8$"]],[3010,3010],[3140,3140]]],[1562829777881,["GJX@GJXAIOU",[[1,3141,"此时，取得最后解的是粒子2"]],[3141,3141],[3154,3154]]],[1562829777924,["GJX@GJXAIOU",[[1,3153," "]],[3154,3154],[3155,3155]]],[1562829778594,["GJX@GJXAIOU",[[1,3155,"."]],[3155,3155],[3156,3156]]],[1562829779878,["GJX@GJXAIOU",[[1,3160,"\n"]],[3156,3156],[3157,3157]]],[1562829780839,["GJX@GJXAIOU",[[1,3161,"\n"]],[3157,3157],[3158,3158]]],[1562829782123,["GJX@GJXAIOU",[[1,3158,"****"]],[3158,3158],[3160,3160]]],[1562829784667,["GJX@GJXAIOU",[[1,3160,"100次"]],[3160,3160],[3164,3164]]],[1562829784708,["GJX@GJXAIOU",[[1,3163," "]],[3164,3164],[3165,3165]]],[1562829789884,["GJX@GJXAIOU",[[1,3165,"迭代之后，锂离子"]],[3165,3165],[3173,3173]]],[1562829790808,["GJX@GJXAIOU",[[-1,3170,"锂离子"]],[3173,3173],[3170,3170]]],[1562829797728,["GJX@GJXAIOU",[[1,3170,"粒子的位置及其适应值为："]],[3170,3170],[3182,3182]]],[1562829799233,["GJX@GJXAIOU",[[1,3188,"\n"]],[3184,3184],[3185,3185]]],[1562829857033,["GJX@GJXAIOU",[[1,3185,"$\\vec{x}_{1}^{100}=(0.83243910 .71345127,0.4540729 .19283025-0.01689619)$\n$\\vec{x}_{2}^{100}=(0.7039059,0.759277460 .423554480 .205723421 .0952349)$\n$\\vec{x}_{3}^{100}=(0.8442569,0.6770473,0.458679320 .194917720 .016728058)$\n$\\vec{x}_{4}^{100}=(0.82389680 .6769957,0.454853180 .19670130 .015787406)$\n$\\vec{x}_{5}^{100}=(0.8273693,0.6775995,0.454610380 .19740629,01580313)$"]],[3185,3185],[3557,3557]]],[1562829895487,["GJX@GJXAIOU",[[1,3559,"$\\begin{aligned} f_{1}^{100} &=1.7138834 \\\\ f_{2}^{100} &=121.33863 \\\\ f_{3}^{100} &=1.2665054 \\\\ f_{4}^{100} &=1.1421927 \\\\ f_{5}^{100} &=1.1444693 \\end{aligned}$"]],[3559,3559],[3722,3722]]],[1562829898376,["GJX@GJXAIOU",[[1,3724,"\n"]],[3722,3722],[3723,3723]]],[1562829910286,["GJX@GJXAIOU",[[1,3723,"此时，取得最好解的是粒子4"]],[3723,3723],[3736,3736]]],[1562829910329,["GJX@GJXAIOU",[[1,3735," "]],[3736,3736],[3737,3737]]],[1562829910490,["GJX@GJXAIOU",[[1,3737,"；"]],[3737,3737],[3738,3738]]],[1562829915705,["GJX@GJXAIOU",[[1,3740,"## "]],[3740,3740],[3764,3764]]],[1562829918191,["GJX@GJXAIOU",[[1,3765,"### "]],[3765,3765],[3779,3779]]],[1562829920735,["GJX@GJXAIOU",[[1,3780,"\n"]],[3780,3780],[3781,3781]]],[1562829922451,["GJX@GJXAIOU",[[1,3780,"···"]],[3780,3780],[3783,3783]]],[1562829923599,["GJX@GJXAIOU",[[-1,3780,"···"]],[3783,3783],[3780,3780]]],[1562829924721,["GJX@GJXAIOU",[[1,3780,"```"]],[3780,3780],[3783,3783]]],[1562829924770,["GJX@GJXAIOU",[[1,3783,"language\n```\n"]],[3783,3783],[3783,3791]]],[1562829926169,["GJX@GJXAIOU",[[-1,3783,"language"],[1,3791,"m"]],[3783,3791],[3784,3784]]],[1562829927489,["GJX@GJXAIOU",[[1,3784,"atlab"]],[3784,3784],[3789,3789]]],[1562829931815,["GJX@GJXAIOU",[[-1,3790,"```"]],[3790,3793],[3790,3790]]],[1562829933400,["GJX@GJXAIOU",[[-1,3791,"\n"]],[3791,3791],[3790,3790]]],[1562829933734,["GJX@GJXAIOU",[[-1,3790,"\n"]],[3790,3790],[3789,3789]]],[1562829949750,["GJX@GJXAIOU",[[1,6633,"```"]],[6633,6633],[6636,6636]]],[1562830043520,["GJX@GJXAIOU",[[1,6645,"![20161202164959477]($resource/20161202164959477.jpg)"]],[6645,6645],[6699,6699]]],[1562830045662,["GJX@GJXAIOU",[[1,6699,"\n"]],[6699,6699],[6700,6700]]],[1562830045815,["GJX@GJXAIOU",[[1,6700,"\n"]],[6700,6700],[6701,6701]]],[1562830047191,["GJX@GJXAIOU",[[1,6701,"### "]],[6701,6701],[6714,6714]]],[1562830049095,["GJX@GJXAIOU",[[1,6715,"\n"]],[6714,6714],[6715,6715]]],[1562830050521,["GJX@GJXAIOU",[[1,6715,"```"]],[6715,6715],[6718,6718]]],[1562830050564,["GJX@GJXAIOU",[[1,6718,"language\n```\n"]],[6718,6718],[6718,6726]]],[1562830051907,["GJX@GJXAIOU",[[-1,6718,"language"],[1,6726,"j"]],[6718,6726],[6719,6719]]],[1562830052365,["GJX@GJXAIOU",[[1,6719,"ava"]],[6719,6719],[6722,6722]]],[1562830055551,["GJX@GJXAIOU",[[-1,6723,"```\n"]],[6723,6727],[6723,6723]]],[1562830057518,["GJX@GJXAIOU",[[-1,6723,"\n"]],[6723,6723],[6722,6722]]],[1562830070358,["GJX@GJXAIOU",[[1,11477,"\n"]],[11476,11476],[11477,11477]]],[1562830070936,["GJX@GJXAIOU",[[1,11477,"```\n"]],[11477,11477],[11481,11481]]],[1562830107541,["GJX@GJXAIOU",[[1,11492,"![2]($resource/2.jpg)\n![20161202163203062]($resource/20161202163203062.jpg)\n![3]($resource/3.jpg)"]],[11492,11492],[11590,11590]]],[1562830110303,["GJX@GJXAIOU",[[-1,11514,"![20161202163203062]($resource/20161202163203062.jpg)"]],[11514,11567],[11514,11514]]],[1562830111656,["GJX@GJXAIOU",[[1,11491,"![20161202163203062]($resource/20161202163203062.jpg)"]],[11491,11491],[11544,11544]]]],null,"GJX@GJXAIOU"],["2d96195b-0a50-40e1-9e35-468bac56d152",1562896305612,"# 粒子群算法\n\n## 一.产生背景\n\n ❃粒子群算法(particleswarm optimization，PSO)由Kennedy和Eberhart在1995年提出，该算法对于Hepper的模拟鸟群(鱼群)的模型进行修正，以使粒子能够飞向解空间，并在最好解处降落，从而得到了粒子群优化算法。\n\n❃**同遗传算法类似，也是一种基于群体叠代的，但并没有遗传算法用的交叉以及变异，而是粒子在解空间追随最优的粒子进行搜索**。\n\n❃PSO的优势在于简单，容易实现，无需梯度信息，参数少，特别是其天然的实数编码特点特别适合于处理实优化问题。同时又有深刻的智能背景，既适合科学研究，又特别适合工程应用。\n\n设想这样一个场景：一群鸟在随机的搜索食物。在这个区域里只有一块食物，所有的鸟都不知道食物在哪。但是它们知道自己当前的位置距离食物还有多远。\n那么找到食物的最优策略是什么？\n\n最简单有效的就是**搜寻目前离食物最近的鸟的周围区域**。\n\n## 二.算法介绍\n### (1)简述\n- 每个寻优的问题解都被想像成一只鸟，称为“粒子”。所有粒子都在一个D维空间进行搜索。\n- 所有的粒子都由一个fitness-function确定适应值以判断目前的位置好坏。\n每一个粒子必须赋予**记忆功能**，能记住所搜寻到的最佳位置。\n- 每一个粒子还有一个速度以决定飞行的**距离和方向**。这个速度根据它本身的飞行经验以及同伴的飞行经验进行动态调整。 \n\n### (2)基本PSO算法\n####   a.  D维空间中，有m个粒子；\n\n  * 粒子i位置：xi=(xi1,xi2,…xiD)\n  * 粒子i速度：vi=(vi1,vi2,…viD)，1≤i≤m,1 ≤d ≤D\n  * 粒子i经历过的历史最好位置：pi=(pi1,pi2,…piD)\n  * 群体内（或领域内）所有粒子所经历过的最好位置：pg =(pg1,pg2,…pgD)\n\n  PS:一般来说，**粒子的位置和速度都是在连续的实数空间内进行取值**。\n\n####    b.基本PSO公式\n\n$V_{\\mathrm{iD}}^{k+1}=V_{i D}^{k}+c_{1} r_{1}\\left(p_{i D}^{k}-X_{i D}^{k}\\right)+c_{2} r_{2}\\left(p_{g D}^{k}-X_{i D}^{k}\\right)$\n$X_{\\mathrm{iD}}^{k+1}=X_{i D}^{k}+V_{i D}^{k+1}$\n其中 C1、C2：学习因子或者加速系数，一般为正常数。通常为 2；\nr1,r2：取值范围为[0,1] ，是该区间内均匀分布的伪随机数；\nVmax：粒子速度能达到的最大值；\n\n#### C.基本PSO算法流程图\n![PSO流程图]($resource/PSO%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg)\n\n\n关于每个粒子的更新速度和位置的公式如下:\n![20161202143639869]($resource/20161202143639869.jpg)\n\n\n## 三.简单应用\n\n \n![20161202143848292]($resource/20161202143848292.jpg)\n(1)•编码：因为问题的维数为5，所以每个粒子为5维的实数向量。\n(2)•初始化范围：根据问题要求，设定为[-30，30]。根据前面的参数分析，我们知道，可以将最大速度设定为Vmax=60。\n(3)•种群大小：为了说明方便，这里采用一个较小的种群规模，m=5。\n(4)•停止准则：设定为最大迭代次数100次。\n(5)•惯性权重：采用固定权重0.5。\n(6)邻域拓扑结构：使用星形拓扑结构，即全局版本的粒子群优化算法\n算法执行的过程如下:\n\n**初始化位置：**\n$X_{1}^{0}=(-15.061812,-23.799465,25.508911,4.867607,-4.6115036)$\n$X_{2}^{0}=(29.855438,-25.405956,6.2448387,10.079713,-26.621386)$\n$X_{3}^{0}=(23.805588,19.57822,-8.61554,9.441231,-29.898735)$\n$X_{4}^{0}=(7.1804657,-13.258207,-29.63405,-27.048172,2.24227979)$\n$X_{5}^{0}=(-4.7385902,-17.732449,-2478365,-3.8092823,4.3552284)$\n\n**初始化速度：**\n$V_{1}^{0}=(-5.2273927,15.964569-11.821243,42.65571,-48.36218)$\n$V_{2}^{0}=(-0.42986897,-0.5701652,-18.416643,-51.86605,-33.90133)$\n$V_{3}^{0}=(13.069403,-48.511078,28.80003,-8.051167,-28.049505)$\n$V_{4}^{0}=(-8.85361,12.998845,-13.325946,18.722532,-26.033237)$\n$V_{5}^{0}=(-5.7461033,-7.451118,29.135513,-14.144024,-41.325256)$\n\n**各个粒子的初试适应值：**\n$f_{1}^{0}=7.733296 \\mathrm{E} 7$\n$f_{2}^{0}=1.26632864 \\mathrm{E} 8$\n$f_{3}^{0}=4.7132888 \\mathrm{E} 7$\n$f_{4}^{0}=1.39781552 \\mathrm{E} 8$\n$f_{5}^{0}=4.98773 \\mathrm{E} 7$\n\n此时取得最好解的是粒子 3.\n\n经过一次迭代之后粒子的位置变化为：\n\n$X_{1}^{1}=(2.4265985,29.665405,18.387815,29.66393,-39.97371)$\n$X_{1}^{1}=(22.56745,-3.999012,-19.23571,-16.373426,-45.417023)$\n$X_{3}^{1}=(30.34029,-4.6773186,5.7844753 .5 .4156475,-43.92349)$\n$X_{4}^{1}=(2.7943296,19.942759,-24.861498,16.060974,-57.757202)$\n$X_{5}^{1}=(27.509708,28.379063,13.016331,11.539068,-53.676777)$\n\n从上面的数据可以看到，粒子有的分量跑出了初始化范围。需要说明的是，在这种情况下，我们一般不强行将粒子拉回到初始化空间，即使初始化空间也是粒子的约束空间。因为，即使粒子跑出初始化空间，随着迭代的进行，如果在初始化空间内有更好的解存在，那么粒子也可以自行返回到初始化空间。\n有研究表明，即使将初始化空间不设定为问题的约束空间，粒子也可能找到最优解。\n\n**第一次迭代之后，自个粒子的适应值为：**\n\n$f_{1}^{1}=1.68403632 E 8$\n$f_{2}^{1}=5.122986 E 7$\n$f_{3}^{1}=8.6243528 E 7$\n$f_{4}^{1}=6.4084752 E 7$\n$f_{5}^{1}=1.21824928 E 8$\n此时，取得最后解的是粒子 2.\n\n**100 次迭代之后，粒子的位置及其适应值为：**\n$\\vec{x}_{1}^{100}=(0.83243910 .71345127,0.4540729 .19283025-0.01689619)$\n$\\vec{x}_{2}^{100}=(0.7039059,0.759277460 .423554480 .205723421 .0952349)$\n$\\vec{x}_{3}^{100}=(0.8442569,0.6770473,0.458679320 .194917720 .016728058)$\n$\\vec{x}_{4}^{100}=(0.82389680 .6769957,0.454853180 .19670130 .015787406)$\n$\\vec{x}_{5}^{100}=(0.8273693,0.6775995,0.454610380 .19740629,01580313)$\n\n$\\begin{aligned} f_{1}^{100} &=1.7138834 \\\\ f_{2}^{100} &=121.33863 \\\\ f_{3}^{100} &=1.2665054 \\\\ f_{4}^{100} &=1.1421927 \\\\ f_{5}^{100} &=1.1444693 \\end{aligned}$\n此时，取得最好解的是粒子 4；\n\n## 四.代码实现:运用粒子群算法解决TSP问题\n### 1.matlab实现\n```matlab\nclose all;\nclear all;\n\nPopSize=500;%种群大小\nCityNum = 14;%城市数\n\nOldBestFitness=0;%旧的最优适应度值\n\nIteration=0;%迭代次数\nMaxIteration =2000;%最大迭代次数\nIsStop=0;%程序停止标志 \nNum=0;%取得相同适应度值的迭代次数\n\nc1=0.5;%认知系数\nc2=0.7;%社会学习系数\nw=0.96-Iteration/MaxIteration;%惯性系数,随迭代次数增加而递减\n\n%节点坐标\nnode=[16.47 96.10; 16.47 94.44; 20.09 92.54; 22.39 93.37; 25.23 97.24;...\n     22.00 96.05; 20.47 97.02; 17.20 96.29; 16.30 97.38; 14.05 98.12;...\n     16.53 97.38; 21.52 95.59; 19.41 97.13; 20.09 94.55];\n\n%初始化各粒子，即产生路径种群\nGroup=ones(CityNum,PopSize);   \nfor i=1:PopSize\n    Group(:,i)=randperm(CityNum)';\nend\nGroup=Arrange(Group);\n\n%初始化粒子速度（即交换序）\nVelocity =zeros(CityNum,PopSize);   \nfor i=1:PopSize\n    Velocity(:,i)=round(rand(1,CityNum)'*CityNum); %round取整\nend\n\n%计算每个城市之间的距离\nCityBetweenDistance=zeros(CityNum,CityNum);   \nfor i=1:CityNum\n    for j=1:CityNum\n        CityBetweenDistance(i,j)=sqrt((node(i,1)-node(j,1))^2+(node(i,2)-node(j,2))^2);\n    end\nend\n\n%计算每条路径的距离\nfor i=1:PopSize   \n        EachPathDis(i) = PathDistance(Group(:,i)',CityBetweenDistance);\nend\n\nIndivdualBest=Group;%记录各粒子的个体极值点位置,即个体找到的最短路径\nIndivdualBestFitness=EachPathDis;%记录最佳适应度值,即个体找到的最短路径的长度\n[GlobalBestFitness,index]=min(EachPathDis);%找出全局最优值和相应序号 \n\n%初始随机解\nfigure;\nsubplot(2,2,1);\nPathPlot(node,CityNum,index,IndivdualBest);\ntitle('随机解');\n\n%寻优\nwhile(IsStop == 0) & (Iteration < MaxIteration) \n    %迭代次数递增\n    Iteration = Iteration +1;  \n    \n    %更新全局极值点位置,这里指路径\n    for i=1:PopSize   \n        GlobalBest(:,i) = Group(:,index);\n      \n    end\n    \n    %求pij-xij ,pgj-xij交换序，并以概率c1，c2的保留交换序\n    pij_xij=GenerateChangeNums(Group,IndivdualBest);  \n    pij_xij=HoldByOdds(pij_xij,c1); \n    pgj_xij=GenerateChangeNums(Group,GlobalBest);\n    pgj_xij=HoldByOdds(pgj_xij,c2);\n    \n    %以概率w保留上一代交换序\n    Velocity=HoldByOdds(Velocity,w);\n\n    Group = PathExchange(Group,Velocity); %根据交换序进行路径交换\n    Group = PathExchange(Group,pij_xij);\n    Group = PathExchange(Group,pgj_xij);\n    for i = 1:PopSize    % 更新各路径总距离\n          EachPathDis(i) = PathDistance(Group(:,i)',CityBetweenDistance);\n    \n    end\n\n    IsChange = EachPathDis<IndivdualBestFitness;%更新后的距离优于更新前的，记录序号\n    IndivdualBest(:, find(IsChange)) = Group(:, find(IsChange));%更新个体最佳路径\n    IndivdualBestFitness = IndivdualBestFitness.*( ~IsChange) + EachPathDis.*IsChange;%更新个体最佳路径距离\n    [GlobalBestFitness, index] = min(EachPathDis);%更新全局最佳路径,记录相应的序号\n   \n    if GlobalBestFitness==OldBestFitness %比较更新前和更新后的适应度值;\n        Num=Num+1; %相等时记录加一;\n    else\n        OldBestFitness=GlobalBestFitness;%不相等时更新适应度值，并记录清零;\n        Num=0;\n    end    \n    if Num >= 20 %多次迭代的适应度值相近时程序停止\n        IsStop=1;\n    end\n\n     BestFitness(Iteration) =GlobalBestFitness;%每一代的最优适应度\n\n\nend\n\n%最优解\nsubplot(2,2,2);\nPathPlot(node,CityNum,index,IndivdualBest);\ntitle('优化解');\n%进化曲线\nsubplot(2,2,3);\nplot((1:Iteration),BestFitness(1:Iteration));\ngrid on;\ntitle('进化曲线');\n%最小路径值\nGlobalBestFitness\n```\n运行结果如下:\n![20161202164959477]($resource/20161202164959477.jpg)\n\n\n### 2.java 实现\n```java\npackage pso;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\n \nimport javax.swing.*;\nimport javax.swing.event.*;\npublic class Pso extends Frame implements Runnable\n{\n    private static int particleNumber;  //粒子的数量\n    private static int iterations;      //迭代的次数\n    private static int k=1;             //记录迭代的次数\n    final private static float C1=2;    //学习因子\n    final private static float C2=2;\n    final private static float WMIN=-200;\n    final private static float WMAX=200;\n    final private static float VMAX=200;\n    private static float r1;           //随机数0-1之间\n    private static float r2;\n    private static float x[][];\n    private static float v[][];\n    private static float xpbest[][];\n    private static float pbest[];      \n    private static float gbest=0;\n    private static float xgbest[];\n    private static float w;           //惯性因子\n    private static float s;\n    private static float h;\n    private static float fit[];\n    public Sounds sound;\n    \n    //粒子群的迭代函数\npublic void lzqjs()\n{\n\t  \n\t\tw=(float)(0.9-k*(0.9-0.4)/iterations);\n        for(int i=0;i<particleNumber;i++)\n        {\n                   fit[i]= (float)(1/(Math.pow(x[i][0],2)+Math.pow(x[i][1],2))); //求适值函数最大值\n                   System.out.print(\"粒子\"+i+\"本次适应值函数f为：\" + fit[i]);\n                   System.out.println();\n                   if(fit[i]>pbest[i])\n                   {\n                   \tpbest[i]=fit[i];\n                   \txpbest[i][0]=x[i][0];\n                   \txpbest[i][1]=x[i][1];\n                   }\n                   if(pbest[i]>gbest)\n                   {\n                   \tgbest=pbest[i];\n                   \txgbest[0]=xpbest[i][0];\n                   \txgbest[1]=xpbest[i][1];\n                   }\n         }\n         for(int i=0;i<particleNumber;i++)\n         {\n                   for(int j=0;j<2;j++)\n                   {\n                \t   //粒子速度和位置迭代方程:\n                   \tv[i][j]=(float)(w*v[i][j]+C1*Math.random()*(xpbest[i][j]-x[i][j])+C2*Math.random()*(xgbest[j]-x[i][j]));\n                   \n                   \tx[i][j]=(float)(x[i][j]+v[i][j]);\n                   \n                   }\n               \tSystem.out.print(\"粒子\"+i+\"本次X1的速度变化幅度:\"+v[i][0]+\";本次X2的速度变化幅度:\"+v[i][1]);\n                System.out.println();\n            \tSystem.out.print(\"粒子\"+i+\"本次X1为：\"+x[i][0]+\";本次X2为：\"+x[i][1]);\n                System.out.println();\n         }\n}\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tparticleNumber=Integer.parseInt(JOptionPane.showInputDialog(\"请输入粒子个数1-500）\"));\n\t\titerations=Integer.parseInt(JOptionPane.showInputDialog(\"请输入迭代次数\"));\n\t\tx=new float [particleNumber][2];\n\t\tv=new float [particleNumber][2];\n\t\tfit=new float [particleNumber];    //存储适值函数值\n\t\tpbest=new float [particleNumber];  //存储整个粒子群的最有位置\n\t\txpbest=new float [particleNumber][2];\n\t\txgbest=new float [2];\n\t\tfor(int i=0;i<particleNumber;i++)\n\t\t{\n\t\t\t\n\t\t\t//对数组的初始化操作\n\t\t\tpbest[i]=0;\n\t\t\txpbest[i][0]=0;\n\t\t\txpbest[i][1]=0;\n\t\t}\n\t\txgbest[0]=0;\n\t\txgbest[1]=0;\n\t\t System.out.println(\"开始初始化：\");\n\t\tfor(int i=0;i<particleNumber;i++)\n\t\t{\n\t\t\t\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\t//任意给定每个位置一定的位置值和速度值\n\t\t\t\tx[i][j]=(float)(WMAX*Math.random()+WMIN);\n\t\t\t\tv[i][j]=(float)(VMAX*Math.random());\n\t\t\t}\n\t\t\tSystem.out.print(\"粒子\"+i+\"本次X1的变化幅度:\"+v[i][0]+\";本次X2的变化幅度:\"+v[i][1]);\n\t\t \t System.out.println();\n\t\t \tSystem.out.print(\"粒子\"+i+\"本次X1为：\"+x[i][0]+\";本次X2为：\"+x[i][1]);\n\t\t\t System.out.println();\n\t\t}\n\t\tSystem.out.println(\"初始化数据结束，开始迭代.....\");\n\tPso threada=new Pso();\n\tthreada.setTitle(\"基于粒子群的粒子位置动态显示\");\n\tthreada.setSize(800,800);\n\tthreada.addWindowListener(new gbck());\n\tthreada.setVisible(true);\n        Thread threadc=new Thread(threada);\n        threadc.start();\n\t}\n\tstatic class gbck extends WindowAdapter\n\t{\n\t\tpublic void windowClosing(WindowEvent e)\n\t\t{\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\t\n\t//开启的额外线程用于声音的播放\n\tpublic void run()\n\t{\n       \n\t\trepaint();\n        \n        for(int i=0;i<iterations;i++){\n        \tsound();\n        }\n\t}\n\tpublic void paint(Graphics g)\n\t{\n\t\t \n\t\t   g.setColor(new Color(0,0,0));\n\t       for(int i=0;i<particleNumber;i++)\n\t       {\n\t       \tg.drawString(\"*\",(int)(x[i][0]+200),(int)(x[i][1]+200));\n\t       }\n\t       g.setColor(new Color(255,0,0));\n\t       g.drawString(\"全局最优适应度函数值：\"+gbest+\"      参数1：\"+xgbest[0]+\"     参数2：\"+xgbest[1]+\"    迭代次数：\"+ k,50,725);\n \n    try\n\t{\n\tlzqjs();  //开始迭代\n\t\n\tif(k>=iterations)\n\t{\n\t\t\n\t\tThread.sleep((int)(5000));\n\t\tSystem.exit(0);\n\t}\n\tk=k+1;  //每次迭代一次加1操作\n\tThread.sleep((int)(1000));\n\t}\n    catch(InterruptedException e)\n    {\n\t\t System.out.println(e.toString());\n    }\n    repaint();\n\t}\n\tpublic  void sound(){\n\t\t  sound =new Sounds(\"050.wav\");\n\t\t  InputStream stream =new ByteArrayInputStream(sound.getSamples());\n\t\t  // play the sound\n\t\t  sound.play(stream);\n\t\t  // exit\n \n\t}\n}\n```\n\n运行的结果如下:\n![20161202163203062]($resource/20161202163203062.jpg)\n![2]($resource/2.jpg)\n\n![3]($resource/3.jpg)\n\n\n\n",[[1562896284456,["GJX@GJXAIOU",[[1,661,"  "]],[686,686],[688,688]]]],null,"GJX@GJXAIOU"]]}