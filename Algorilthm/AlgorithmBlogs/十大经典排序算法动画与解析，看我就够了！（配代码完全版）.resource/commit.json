{"compress":true,"commitItems":[["a76b9dbe-0e23-47b7-a229-5f5a99a4a484",1566826961899,"## 十大经典排序算法动画与解析，看我就够了！（配代码完全版）\n\n原创： 程序员小吴 [五分钟学算法](javascript:void(0);) _2018-12-07_\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaxpdAd0jDFxeIyicj9vpeZqmAFffrqWIlh3icEicN8TqohCfXfMLmMQNBg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n前段时间笔者整理发布了[《十大经典排序算法动画，看我就够了！》](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484095&idx=1&sn=174a8b95900448c73507955250b759cc&chksm=fa0e6d3ecd79e428aac5c52d77c335678b583926e3d3c973513c1a8444951f3e03f820375d61&scene=21#wechat_redirect)，很多读者在后台留言肯定了这种动画的表达方式，觉得这比一些课本上的死板讲解方式好太多了:），也有些很多读者表示如果在本文中添加配套的代码效果会更好，笔者觉得这个提议不错，于是更新了一下文章^_^。\n\n**排序算法是《数据结构与算法》中最基本的算法之一。**\n\n排序算法可以分为**内部排序**和**外部排序**。\n\n内部排序是数据记录在内存中进行排序。\n\n而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。\n\n常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。\n\n用一张图概括：\n\n![](https://mmbiz.qpic.cn/mmbiz_png/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaKhGcwh6KibXbSiadtHqwgjmmzBYCa2DNuj5Vhw3lHc96z1wge3ZbDAeg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 \"image\")\n\n时间复杂度与空间复杂度\n\n#### 关于时间复杂度：\n\n1.  平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。\n\n2.  线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；\n\n3.  O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序\n\n4.  线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。\n\n#### 关于稳定性：\n\n1.  稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。\n\n2.  不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。\n\n### 1\\. 冒泡排序\n\n#### 1.1 算法步骤\n\n*   比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n\n*   对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n\n*   针对所有的元素重复以上的步骤，除了最后一个。\n\n*   持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n#### 1.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaC1S2jpXRzXcZVn0aP6BYnkO2FJicNstxicHmf9wMIic5FV0I75ptv5jYA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n冒泡排序动画演示\n\n#### 1.3 参考代码\n\n```\n 1// Java 代码实现 2public class BubbleSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        for (int i = 1; i < arr.length; i++) {10            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。11            boolean flag = true;1213            for (int j = 0; j < arr.length - i; j++) {14                if (arr[j] > arr[j + 1]) {15                    int tmp = arr[j];16                    arr[j] = arr[j + 1];17                    arr[j + 1] = tmp;1819                    flag = false;20                }21            }2223            if (flag) {24                break;25            }26        }27        return arr;28    }29}\n```\n\n### 2\\. 选择排序\n\n#### 2.1 算法步骤\n\n*   首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n\n*   再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n*   重复第二步，直到所有元素均排序完毕。\n\n#### 2.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaB2dW1vA5SganRPChytYTFiaJL2PkXlL7XmhYmqIAzBHj0VvgJZs0vmA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n选择排序动画演示\n\n#### 2.3 参考代码\n\n```\n 1//Java 代码实现 2public class SelectionSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 7 8        // 总共要经过 N-1 轮比较 9        for (int i = 0; i < arr.length - 1; i++) {10            int min = i;1112            // 每轮需要比较的次数 N-i13            for (int j = i + 1; j < arr.length; j++) {14                if (arr[j] < arr[min]) {15                    // 记录目前能找到的最小值元素的下标16                    min = j;17                }18            }1920            // 将找到的最小值和i位置所在的值进行交换21            if (i != min) {22                int tmp = arr[i];23                arr[i] = arr[min];24                arr[min] = tmp;25            }2627        }28        return arr;29    }30}\n```\n\n### 3\\. 插入排序\n\n#### 3.1 算法步骤\n\n*   将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n\n*   从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\n#### 3.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaiatKZU4exjwcluduiclJOdZB0oZQicCrpIEaSJJg8iaia58viauSK3nhofqA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n插入排序动画演示\n\n#### 3.3 参考代码\n\n```\n 1//Java 代码实现 2public class InsertSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的10        for (int i = 1; i < arr.length; i++) {1112            // 记录要插入的数据13            int tmp = arr[i];1415            // 从已经排序的序列最右边的开始比较，找到比其小的数16            int j = i;17            while (j > 0 && tmp < arr[j - 1]) {18                arr[j] = arr[j - 1];19                j--;20            }2122            // 存在比其小的数，插入23            if (j != i) {24                arr[j] = tmp;25            }2627        }28        return arr;29    }30}\n```\n\n### 4\\. 希尔排序\n\n#### 4.1 算法步骤\n\n*   选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n\n*   按增量序列个数 k，对序列进行 k 趟排序；\n\n*   每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n#### 4.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiadtZekLQySMDdNsZTx6jyaO6spIkjPFjwqfdhd2XfRUnic1PjV1yRxrw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n希尔排序动画演示\n\n#### 4.3 参考代码\n\n```\n 1//Java 代码实现 2public class ShellSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int gap = 1;10        while (gap < arr.length) {11            gap = gap * 3 + 1;12        }1314        while (gap > 0) {15            for (int i = gap; i < arr.length; i++) {16                int tmp = arr[i];17                int j = i - gap;18                while (j >= 0 && arr[j] > tmp) {19                    arr[j + gap] = arr[j];20                    j -= gap;21                }22                arr[j + gap] = tmp;23            }24            gap = (int) Math.floor(gap / 3);25        }2627        return arr;28    }29}\n```\n\n### 5\\. 归并排序\n\n#### 5.1 算法步骤\n\n*   申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n\n*   设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n\n*   比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n\n*   重复步骤 3 直到某一指针达到序列尾；\n\n*   将另一序列剩下的所有元素直接复制到合并序列尾。\n\n#### 5.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaUbPILFO9cjn2Uy1roWIcGDOC3owGFLvuVicasstic1UjSGXmTZj5oHDw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n归并排序动画演示\n\n#### 5.3 参考代码\n\n```\n 1//Java 代码实现     public class MergeSort implements IArraySort { 2 3    @Override 4    public int[] sort(int[] sourceArray) throws Exception { 5        // 对 arr 进行拷贝，不改变参数内容 6        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 7 8        if (arr.length < 2) { 9            return arr;10        }11        int middle = (int) Math.floor(arr.length / 2);1213        int[] left = Arrays.copyOfRange(arr, 0, middle);14        int[] right = Arrays.copyOfRange(arr, middle, arr.length);1516        return merge(sort(left), sort(right));17    }1819    protected int[] merge(int[] left, int[] right) {20        int[] result = new int[left.length + right.length];21        int i = 0;22        while (left.length > 0 && right.length > 0) {23            if (left[0] <= right[0]) {24                result[i++] = left[0];25                left = Arrays.copyOfRange(left, 1, left.length);26            } else {27                result[i++] = right[0];28                right = Arrays.copyOfRange(right, 1, right.length);29            }30        }3132        while (left.length > 0) {33            result[i++] = left[0];34            left = Arrays.copyOfRange(left, 1, left.length);35        }3637        while (right.length > 0) {38            result[i++] = right[0];39            right = Arrays.copyOfRange(right, 1, right.length);40        }4142        return result;43    }4445}\n```\n\n### 6\\. 快速排序\n\n#### 6.1 算法步骤\n\n*   从数列中挑出一个元素，称为 “基准”（pivot）;\n\n*   重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n\n*   递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n#### 6.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaAY3VU8iaziaYcxAasTdrIu69BOVPYtfvqdvicmlJDS94cG2tjwZhVkdHA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n快速排序动画演示\n\n#### 6.3 参考代码\n\n```\n 1//Java 代码实现 2public class QuickSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        return quickSort(arr, 0, arr.length - 1);10    }1112    private int[] quickSort(int[] arr, int left, int right) {13        if (left < right) {14            int partitionIndex = partition(arr, left, right);15            quickSort(arr, left, partitionIndex - 1);16            quickSort(arr, partitionIndex + 1, right);17        }18        return arr;19    }2021    private int partition(int[] arr, int left, int right) {22        // 设定基准值（pivot）23        int pivot = left;24        int index = pivot + 1;25        for (int i = index; i <= right; i++) {26            if (arr[i] < arr[pivot]) {27                swap(arr, i, index);28                index++;29            }30        }31        swap(arr, pivot, index - 1);32        return index - 1;33    }3435    private void swap(int[] arr, int i, int j) {36        int temp = arr[i];37        arr[i] = arr[j];38        arr[j] = temp;39    }4041}\n```\n\n### 7\\. 堆排序\n\n#### 7.1 算法步骤\n\n*   创建一个堆 H[0……n-1]；\n\n*   把堆首（最大值）和堆尾互换；\n\n*   把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；\n\n*   重复步骤 2，直到堆的尺寸为 1。\n\n#### 7.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRian1jgiaGZE9k1xZTp9B1icHia0jIXiba3ibgnIBibdfSN4I5US4WtrQJQMiakw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                     堆排序动画演示\n\n#### 7.3 参考代码\n\n```\n 1//Java 代码实现 2public class HeapSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int len = arr.length;1011        buildMaxHeap(arr, len);1213        for (int i = len - 1; i > 0; i--) {14            swap(arr, 0, i);15            len--;16            heapify(arr, 0, len);17        }18        return arr;19    }2021    private void buildMaxHeap(int[] arr, int len) {22        for (int i = (int) Math.floor(len / 2); i >= 0; i--) {23            heapify(arr, i, len);24        }25    }2627    private void heapify(int[] arr, int i, int len) {28        int left = 2 * i + 1;29        int right = 2 * i + 2;30        int largest = i;3132        if (left < len && arr[left] > arr[largest]) {33            largest = left;34        }3536        if (right < len && arr[right] > arr[largest]) {37            largest = right;38        }3940        if (largest != i) {41            swap(arr, i, largest);42            heapify(arr, largest, len);43        }44    }4546    private void swap(int[] arr, int i, int j) {47        int temp = arr[i];48        arr[i] = arr[j];49        arr[j] = temp;50    }5152}\n```\n\n### 8\\. 计数排序\n\n#### 8.1 算法步骤\n\n*   花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max\n\n*   开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)\n\n*   数组 B 中 index 的元素记录的值是 A 中某元素出现的次数\n\n*   最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数\n\n#### 8.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRia8NKBRZBBvsXXDtepTas9TFicryFdFqlVTg5mibDUgqAmYw2TvhoKu9ow/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n计数排序动画演示\n\n#### 8.3 参考代码\n\n```\n 1//Java 代码实现 2public class CountingSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int maxValue = getMaxValue(arr);1011        return countingSort(arr, maxValue);12    }1314    private int[] countingSort(int[] arr, int maxValue) {15        int bucketLen = maxValue + 1;16        int[] bucket = new int[bucketLen];1718        for (int value : arr) {19            bucket[value]++;20        }2122        int sortedIndex = 0;23        for (int j = 0; j < bucketLen; j++) {24            while (bucket[j] > 0) {25                arr[sortedIndex++] = j;26                bucket[j]--;27            }28        }29        return arr;30    }3132    private int getMaxValue(int[] arr) {33        int maxValue = arr[0];34        for (int value : arr) {35            if (maxValue < value) {36                maxValue = value;37            }38        }39        return maxValue;40    }4142}\n```\n\n### 9\\. 桶排序\n\n#### 9.1 算法步骤\n\n*   设置固定数量的空桶。\n\n*   把数据放到对应的桶中。\n\n*   对每个不为空的桶中数据进行排序。\n\n*   拼接不为空的桶中数据，得到结果\n\n#### 9.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRia0umOurgFRv8ESYzcK6bXknufLgJGLaiaTrDTXUk09R6ia2DhbCPAJx0A/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                         桶排序动画演示\n\n#### 9.3 参考代码\n\n```\n 1//Java 代码实现 2public class BucketSort implements IArraySort { 3 4    private static final InsertSort insertSort = new InsertSort(); 5 6    @Override 7    public int[] sort(int[] sourceArray) throws Exception { 8        // 对 arr 进行拷贝，不改变参数内容 9        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);1011        return bucketSort(arr, 5);12    }1314    private int[] bucketSort(int[] arr, int bucketSize) throws Exception {15        if (arr.length == 0) {16            return arr;17        }1819        int minValue = arr[0];20        int maxValue = arr[0];21        for (int value : arr) {22            if (value < minValue) {23                minValue = value;24            } else if (value > maxValue) {25                maxValue = value;26            }27        }2829        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;30        int[][] buckets = new int[bucketCount][0];3132        // 利用映射函数将数据分配到各个桶中33        for (int i = 0; i < arr.length; i++) {34            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);35            buckets[index] = arrAppend(buckets[index], arr[i]);36        }3738        int arrIndex = 0;39        for (int[] bucket : buckets) {40            if (bucket.length <= 0) {41                continue;42            }43            // 对每个桶进行排序，这里使用了插入排序44            bucket = insertSort.sort(bucket);45            for (int value : bucket) {46                arr[arrIndex++] = value;47            }48        }4950        return arr;51    }5253    /**54     * 自动扩容，并保存数据55     *56     * @param arr57     * @param value58     */59    private int[] arrAppend(int[] arr, int value) {60        arr = Arrays.copyOf(arr, arr.length + 1);61        arr[arr.length - 1] = value;62        return arr;63    }6465}\n```\n\n### 10\\. 基数排序\n\n#### 10.1 算法步骤\n\n*   将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零\n\n*   从最低位开始，依次进行一次排序\n\n*   从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列\n\n#### 10.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRial8LfeK5f941BmtmZcVlP0my2qgBXq6wEZ0PTDrcPqN3ntt7ibPrUxrg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                        基数排序动画演示\n\n#### 10.3 参考代码\n\n```\n 1//Java 代码实现 2public class RadixSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int maxDigit = getMaxDigit(arr);10        return radixSort(arr, maxDigit);11    }1213    /**14     * 获取最高位数15     */16    private int getMaxDigit(int[] arr) {17        int maxValue = getMaxValue(arr);18        return getNumLenght(maxValue);19    }2021    private int getMaxValue(int[] arr) {22        int maxValue = arr[0];23        for (int value : arr) {24            if (maxValue < value) {25                maxValue = value;26            }27        }28        return maxValue;29    }3031    protected int getNumLenght(long num) {32        if (num == 0) {33            return 1;34        }35        int lenght = 0;36        for (long temp = num; temp != 0; temp /= 10) {37            lenght++;38        }39        return lenght;40    }4142    private int[] radixSort(int[] arr, int maxDigit) {43        int mod = 10;44        int dev = 1;4546        for (int i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {47            // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)48            int[][] counter = new int[mod * 2][0];4950            for (int j = 0; j < arr.length; j++) {51                int bucket = ((arr[j] % mod) / dev) + mod;52                counter[bucket] = arrayAppend(counter[bucket], arr[j]);53            }5455            int pos = 0;56            for (int[] bucket : counter) {57                for (int value : bucket) {58                    arr[pos++] = value;59                }60            }61        }6263        return arr;64    }65    private int[] arrayAppend(int[] arr, int value) {66        arr = Arrays.copyOf(arr, arr.length + 1);67        arr[arr.length - 1] = value;68        return arr;69    }70}\n```",[[1566826908703,["GJX@GJXAIOU",[[-1,33,"原创： 程序员小吴 [五分钟学算法](javascript:void(0);) _2018-12-07_\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaxpdAd0jDFxeIyicj9vpeZqmAFffrqWIlh3icEicN8TqohCfXfMLmMQNBg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)"]],[33,258],[33,33]]],[1566826911462,["GJX@GJXAIOU",[[-1,35,"前段时间笔者整理发布了"]],[35,46],[35,35]]],[1566826915025,["GJX@GJXAIOU",[[-1,35,""],[1,35,"原文"],[-1,1427," Java 代码实现 2public class BubbleSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        for (int i = 1; i < arr.length; i++) {10            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。11            boolean flag = true;1213            for (int j = 0; j < arr.length - i; j++) {14                if (arr[j] > arr[j + 1]) {15                    int tmp = arr[j];16                    arr[j] = arr[j + 1];17                    arr[j + 1] = tmp;1819                    flag = false;20                }21            }2223            if (flag) {24                break;25            }26        }27        return arr;28    }29}\n```\n\n### 2\\. 选择排序\n\n#### 2.1 算法步骤\n\n*   首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n\n*   再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n*   重复第二步，直到所有元素均排序完毕。\n\n#### 2.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaB2dW1vA5SganRPChytYTFiaJL2PkXlL7XmhYmqIAzBHj0VvgJZs0vmA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n选择排序动画演示\n\n#### 2.3 参考代码\n\n```\n 1//Java 代码实现 2public class SelectionSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 7 8        // 总共要经过 N-1 轮比较 9        for (int i = 0; i < arr.length - 1; i++) {10            int min = i;1112            // 每轮需要比较的次数 N-i13            for (int j = i + 1; j < arr.length; j++) {14                if (arr[j] < arr[min]) {15                    // 记录目前能找到的最小值元素的下标16                    min = j;17                }18            }1920            // 将找到的最小值和i位置所在的值进行交换21            if (i != min) {22                int tmp = arr[i];23                arr[i] = arr[min];24                arr[min] = tmp;25            }2627        }28        return arr;29    }30}\n```\n\n### 3\\. 插入排序\n\n#### 3.1 算法步骤\n\n*   将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n\n*   从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\n#### 3.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaiatKZU4exjwcluduiclJOdZB0oZQicCrpIEaSJJg8iaia58viauSK3nhofqA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n插入排序动画演示\n\n#### 3.3 参考代码\n\n```\n 1//Java 代码实现 2public class InsertSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的10        for (int i = 1; i < arr.length; i++) {1112            // 记录要插入的数据13            int tmp = arr[i];1415            // 从已经排序的序列最右边的开始比较，找到比其小的数16            int j = i;17            while (j > 0 && tmp < arr[j - 1]) {18                arr[j] = arr[j - 1];19                j--;20            }2122            // 存在比其小的数，插入23            if (j != i) {24                arr[j] = tmp;25            }2627        }28        return arr;29    }30}\n```\n\n### 4\\. 希尔排序\n\n#### 4.1 算法步骤\n\n*   选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n\n*   按增量序列个数 k，对序列进行 k 趟排序；\n\n*   每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n#### 4.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiadtZekLQySMDdNsZTx6jyaO6spIkjPFjwqfdhd2XfRUnic1PjV1yRxrw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n希尔排序动画演示\n\n#### 4.3 参考代码\n\n```\n 1//Java 代码实现 2public class ShellSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int gap = 1;10        while (gap < arr.length) {11            gap = gap * 3 + 1;12        }1314        while (gap > 0) {15            for (int i = gap; i < arr.length; i++) {16                int tmp = arr[i];17                int j = i - gap;18                while (j >= 0 && arr[j] > tmp) {19                    arr[j + gap] = arr[j];20                    j -= gap;21                }22                arr[j + gap] = tmp;23            }24            gap = (int) Math.floor(gap / 3);25        }2627        return arr;28    }29}\n```\n\n### 5\\. 归并排序\n\n#### 5.1 算法步骤\n\n*   申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n\n*   设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n\n*   比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n\n*   重复步骤 3 直到某一指针达到序列尾；\n\n*   将另一序列剩下的所有元素直接复制到合并序列尾。\n\n#### 5.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaUbPILFO9cjn2Uy1roWIcGDOC3owGFLvuVicasstic1UjSGXmTZj5oHDw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n归并排序动画演示\n\n#### 5.3 参考代码\n\n```\n 1//Java 代码实现     public class MergeSort implements IArraySort { 2 3    @Override 4    public int[] sort(int[] sourceArray) throws Exception { 5        // 对 arr 进行拷贝，不改变参数内容 6        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 7 8        if (arr.length < 2) { 9            return arr;10        }11        int middle = (int) Math.floor(arr.length / 2);1213        int[] left = Arrays.copyOfRange(arr, 0, middle);14        int[] right = Arrays.copyOfRange(arr, middle, arr.length);1516        return merge(sort(left), sort(right));17    }1819    protected int[] merge(int[] left, int[] right) {20        int[] result = new int[left.length + right.length];21        int i = 0;22        while (left.length > 0 && right.length > 0) {23            if (left[0] <= right[0]) {24                result[i++] = left[0];25                left = Arrays.copyOfRange(left, 1, left.length);26            } else {27                result[i++] = right[0];28                right = Arrays.copyOfRange(right, 1, right.length);29            }30        }3132        while (left.length > 0) {33            result[i++] = left[0];34            left = Arrays.copyOfRange(left, 1, left.length);35        }3637        while (right.length > 0) {38            result[i++] = right[0];39            right = Arrays.copyOfRange(right, 1, right.length);40        }4142        return result;43    }4445}\n```\n\n### 6\\. 快速排序\n\n#### 6.1 算法步骤\n\n*   从数列中挑出一个元素，称为 “基准”（pivot）;\n\n*   重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n\n*   递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n#### 6.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaAY3VU8iaziaYcxAasTdrIu69BOVPYtfvqdvicmlJDS94cG2tjwZhVkdHA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n快速排序动画演示\n\n#### 6.3 参考代码\n\n```\n 1//Java 代码实现 2public class QuickSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        return quickSort(arr, 0, arr.length - 1);10    }1112    private int[] quickSort(int[] arr, int left, int right) {13        if (left < right) {14            int partitionIndex = partition(arr, left, right);15            quickSort(arr, left, partitionIndex - 1);16            quickSort(arr, partitionIndex + 1, right);17        }18        return arr;19    }2021    private int partition(int[] arr, int left, int right) {22        // 设定基准值（pivot）23        int pivot = left;24        int index = pivot + 1;25        for (int i = index; i <= right; i++) {26            if (arr[i] < arr[pivot]) {27                swap(arr, i, index);28                index++;29            }30        }31        swap(arr, pivot, index - 1);32        return index - 1;33    }3435    private void swap(int[] arr, int i, int j) {36        int temp = arr[i];37        arr[i] = arr[j];38        arr[j] = temp;39    }4041}\n```\n\n### 7\\. 堆排序\n\n#### 7.1 算法步骤\n\n*   创建一个堆 H[0……n-1]；\n\n*   把堆首（最大值）和堆尾互换；\n\n*   把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；\n\n*   重复步骤 2，直到堆的尺寸为 1。\n\n#### 7.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRian1jgiaGZE9k1xZTp9B1icHia0jIXiba3ibgnIBibdfSN4I5US4WtrQJQMiakw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                     堆排序动画演示\n\n#### 7.3 参考代码\n\n```\n 1//Java 代码实现 2public class HeapSort implements IArraySort { 3 4    @Override 5    public int[] "],[1,9641," Java 代码实现 2public class BubbleSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        for (int i = 1; i < arr.length; i++) {10            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。11            boolean flag = true;1213            for (int j = 0; j < arr.length - i; j++) {14                if (arr[j] > arr[j + 1]) {15                    int tmp = arr[j];16                    arr[j] = arr[j + 1];17                    arr[j + 1] = tmp;1819                    flag = false;20                }21            }2223            if (flag) {24                break;25            }26        }27        return arr;28    }29}\n```\n\n### 2\\. 选择排序\n\n#### 2.1 算法步骤\n\n*   首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n\n*   再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n*   重复第二步，直到所有元素均排序完毕。\n\n#### 2.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaB2dW1vA5SganRPChytYTFiaJL2PkXlL7XmhYmqIAzBHj0VvgJZs0vmA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n选择排序动画演示\n\n#### 2.3 参考代码\n\n```\n 1//Java 代码实现 2public class SelectionSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 7 8        // 总共要经过 N-1 轮比较 9        for (int i = 0; i < arr.length - 1; i++) {10            int min = i;1112            // 每轮需要比较的次数 N-i13            for (int j = i + 1; j < arr.length; j++) {14                if (arr[j] < arr[min]) {15                    // 记录目前能找到的最小值元素的下标16                    min = j;17                }18            }1920            // 将找到的最小值和i位置所在的值进行交换21            if (i != min) {22                int tmp = arr[i];23                arr[i] = arr[min];24                arr[min] = tmp;25            }2627        }28        return arr;29    }30}\n```\n\n### 3\\. 插入排序\n\n#### 3.1 算法步骤\n\n*   将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n\n*   从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\n#### 3.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaiatKZU4exjwcluduiclJOdZB0oZQicCrpIEaSJJg8iaia58viauSK3nhofqA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n插入排序动画演示\n\n#### 3.3 参考代码\n\n```\n 1//Java 代码实现 2public class InsertSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的10        for (int i = 1; i < arr.length; i++) {1112            // 记录要插入的数据13            int tmp = arr[i];1415            // 从已经排序的序列最右边的开始比较，找到比其小的数16            int j = i;17            while (j > 0 && tmp < arr[j - 1]) {18                arr[j] = arr[j - 1];19                j--;20            }2122            // 存在比其小的数，插入23            if (j != i) {24                arr[j] = tmp;25            }2627        }28        return arr;29    }30}\n```\n\n### 4\\. 希尔排序\n\n#### 4.1 算法步骤\n\n*   选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n\n*   按增量序列个数 k，对序列进行 k 趟排序；\n\n*   每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n#### 4.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiadtZekLQySMDdNsZTx6jyaO6spIkjPFjwqfdhd2XfRUnic1PjV1yRxrw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n希尔排序动画演示\n\n#### 4.3 参考代码\n\n```\n 1//Java 代码实现 2public class ShellSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int gap = 1;10        while (gap < arr.length) {11            gap = gap * 3 + 1;12        }1314        while (gap > 0) {15            for (int i = gap; i < arr.length; i++) {16                int tmp = arr[i];17                int j = i - gap;18                while (j >= 0 && arr[j] > tmp) {19                    arr[j + gap] = arr[j];20                    j -= gap;21                }22                arr[j + gap] = tmp;23            }24            gap = (int) Math.floor(gap / 3);25        }2627        return arr;28    }29}\n```\n\n### 5\\. 归并排序\n\n#### 5.1 算法步骤\n\n*   申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n\n*   设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n\n*   比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n\n*   重复步骤 3 直到某一指针达到序列尾；\n\n*   将另一序列剩下的所有元素直接复制到合并序列尾。\n\n#### 5.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaUbPILFO9cjn2Uy1roWIcGDOC3owGFLvuVicasstic1UjSGXmTZj5oHDw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n归并排序动画演示\n\n#### 5.3 参考代码\n\n```\n 1//Java 代码实现     public class MergeSort implements IArraySort { 2 3    @Override 4    public int[] sort(int[] sourceArray) throws Exception { 5        // 对 arr 进行拷贝，不改变参数内容 6        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 7 8        if (arr.length < 2) { 9            return arr;10        }11        int middle = (int) Math.floor(arr.length / 2);1213        int[] left = Arrays.copyOfRange(arr, 0, middle);14        int[] right = Arrays.copyOfRange(arr, middle, arr.length);1516        return merge(sort(left), sort(right));17    }1819    protected int[] merge(int[] left, int[] right) {20        int[] result = new int[left.length + right.length];21        int i = 0;22        while (left.length > 0 && right.length > 0) {23            if (left[0] <= right[0]) {24                result[i++] = left[0];25                left = Arrays.copyOfRange(left, 1, left.length);26            } else {27                result[i++] = right[0];28                right = Arrays.copyOfRange(right, 1, right.length);29            }30        }3132        while (left.length > 0) {33            result[i++] = left[0];34            left = Arrays.copyOfRange(left, 1, left.length);35        }3637        while (right.length > 0) {38            result[i++] = right[0];39            right = Arrays.copyOfRange(right, 1, right.length);40        }4142        return result;43    }4445}\n```\n\n### 6\\. 快速排序\n\n#### 6.1 算法步骤\n\n*   从数列中挑出一个元素，称为 “基准”（pivot）;\n\n*   重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n\n*   递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n#### 6.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaAY3VU8iaziaYcxAasTdrIu69BOVPYtfvqdvicmlJDS94cG2tjwZhVkdHA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n快速排序动画演示\n\n#### 6.3 参考代码\n\n```\n 1//Java 代码实现 2public class QuickSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        return quickSort(arr, 0, arr.length - 1);10    }1112    private int[] quickSort(int[] arr, int left, int right) {13        if (left < right) {14            int partitionIndex = partition(arr, left, right);15            quickSort(arr, left, partitionIndex - 1);16            quickSort(arr, partitionIndex + 1, right);17        }18        return arr;19    }2021    private int partition(int[] arr, int left, int right) {22        // 设定基准值（pivot）23        int pivot = left;24        int index = pivot + 1;25        for (int i = index; i <= right; i++) {26            if (arr[i] < arr[pivot]) {27                swap(arr, i, index);28                index++;29            }30        }31        swap(arr, pivot, index - 1);32        return index - 1;33    }3435    private void swap(int[] arr, int i, int j) {36        int temp = arr[i];37        arr[i] = arr[j];38        arr[j] = temp;39    }4041}\n```\n\n### 7\\. 堆排序\n\n#### 7.1 算法步骤\n\n*   创建一个堆 H[0……n-1]；\n\n*   把堆首（最大值）和堆尾互换；\n\n*   把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；\n\n*   重复步骤 2，直到堆的尺寸为 1。\n\n#### 7.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRian1jgiaGZE9k1xZTp9B1icHia0jIXiba3ibgnIBibdfSN4I5US4WtrQJQMiakw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                     堆排序动画演示\n\n#### 7.3 参考代码\n\n```\n 1//Java 代码实现 2public class HeapSort implements IArraySort { 3 4    @Override 5    public int[] "],[-1,9651," sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int len = arr.length;1011        buildMaxHeap(arr, len);1213        for (int i = len - 1; i > 0; i--) {14            swap(arr, 0, i);15            len--;16            heapify(arr, 0, len);17        }18        return arr;19    }2021    private void buildMaxHeap(int[] arr, int len) {22        for (int i = (int) Math.floor(len / 2); i >= 0; i--) {23            heapify(arr, i, len);24        }25    }2627    private void heapify(int[] arr, int i, int len) {28        int left = 2 * i + 1;29        int right = 2 * i + 2;30        int largest = i;3132        if (left < len && arr[left] > arr[largest]) {33            largest = left;34        }3536        if (right < len && arr[right] > arr[largest]) {37            largest = right;38        }3940        if (largest != i) {41            swap(arr, i, largest);42            heapify(arr, largest, len);43        }44    }4546    private void swap(int[] arr, int i, int j) {47        int temp = arr[i];48        arr[i] = arr[j];49        arr[j] = temp;50    }5152}\n```\n\n### 8\\. 计数排序\n\n#### 8.1 算法步骤\n\n*   花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max\n\n*   开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)\n\n*   数组 B 中 index 的元素记录的值是 A 中某元素出现的次数\n\n*   最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数\n\n#### 8.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRia8NKBRZBBvsXXDtepTas9TFicryFdFqlVTg5mibDUgqAmYw2TvhoKu9ow/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n计数排序动画演示\n\n#### 8.3 参考代码\n\n```\n 1//Java 代码实现 2public class CountingSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int maxValue = getMaxValue(arr);1011        return countingSort(arr, maxValue);12    }1314    private int[] countingSort(int[] arr, int maxValue) {15        int bucketLen = maxValue + 1;16        int[] bucket = new int[bucketLen];1718        for (int value : arr) {19            bucket[value]++;20        }2122        int sortedIndex = 0;23        for (int j = 0; j < bucketLen; j++) {24            while (bucket[j] > 0) {25                arr[sortedIndex++] = j;26                bucket[j]--;27            }28        }29        return arr;30    }3132    private int getMaxValue(int[] arr) {33        int maxValue = arr[0];34        for (int value : arr) {35            if (maxValue < value) {36                maxValue = value;37            }38        }39        return maxValue;40    }4142}\n```\n\n### 9\\. 桶排序\n\n#### 9.1 算法步骤\n\n*   设置固定数量的空桶。\n\n*   把数据放到对应的桶中。\n\n*   对每个不为空的桶中数据进行排序。\n\n*   拼接不为空的桶中数据，得到结果\n\n#### 9.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRia0umOurgFRv8ESYzcK6bXknufLgJGLaiaTrDTXUk09R6ia2DhbCPAJx0A/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                         桶排序动画演示\n\n#### 9.3 参考代码\n\n```\n 1//Java 代码实现 2public class BucketSort implements IArraySort { 3 4    private static final InsertSort insertSort = new InsertSort(); 5 6    @Override 7    public int[] sort(int[] sourceArray) throws Exception { 8        // 对 arr 进行拷贝，不改变参数内容 9        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);1011        return bucketSort(arr, 5);12    }1314    private int[] bucketSort(int[] arr, int bucketSize) throws Exception {15        if (arr.length == 0) {16            return arr;17        }1819        int minValue = arr[0];20        int maxValue = arr[0];21        for (int value : arr) {22            if (value < minValue) {23                minValue = value;24            } else if (value > maxValue) {25                maxValue = value;26            }27        }2829        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;30        int[][] buckets = new int[bucketCount][0];3132        // 利用映射函数将数据分配到各个桶中33        for (int i = 0; i < arr.length; i++) {34            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);35            buckets[index] = arrAppend(buckets[index], arr[i]);36        }3738        int arrIndex = 0;39        for (int[] bucket : buckets) {40            if (bucket.length <= 0) {41                continue;42            }43            // 对每个桶进行排序，这里使用了插入排序44            bucket = insertSort.sort(bucket);45            for (int value : bucket) {46                arr[arrIndex++] = value;47            }48        }4950        return arr;51    }5253    /**54     * 自动扩容，并保存数据55     *56     * @param arr57     * @param value58     */59    private int[] arrAppend(int[] arr, int value) {60        arr = Arrays.copyOf(arr, arr.length + 1);61        arr[arr.length - 1] = value;62        return arr;63    }6465}\n```\n\n### 10\\. 基数排序\n\n#### 10.1 算法步骤\n\n*   将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零\n\n*   从最低位开始，依次进行一次排序\n\n*   从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列\n\n#### 10.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRial8LfeK5f941BmtmZcVlP0my2qgBXq6wEZ0PTDrcPqN3ntt7ibPrUxrg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                        基数排序动画演示\n\n#### 10.3 参考代码\n\n```\n 1//Java 代码实现 2public class RadixSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int maxDigit = getMaxDigit(arr);10        return radixSort(arr, maxDigit);11    }1213    /**14     * 获取最高位数15     */16    private int getMaxDigit(int[] arr) {17        int maxValue = getMaxValue(arr);18        return getNumLenght(maxValue);19    }2021    private int getMaxValue(int[] arr) {22        int maxValue = arr[0];23        for (int value : arr) {24            if (maxValue < value) {25                maxValue = value;26            }27        }28        return maxValue;29    }3031    protected int getNumLenght(long num) {32        if (num == 0) {33            return 1;34        }35        int lenght = 0;36        for (long temp = num; temp != 0; temp /= 10) {37            lenght++;38        }39        return lenght;40    }4142    private int[] radixSort(int[] arr, int maxDigit) {43        int mod = 10;44        int dev = 1;4546        for (int i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {47            // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)48            int[][] counter = new int[mod * 2][0];4950            for (int j = 0; j < arr.length; j++) {51                int bucket = ((arr[j] % mod) / dev) + mod;52                counter[bucket] = arrayAppend(counter[bucket], arr[j]);53            }5455            int pos = 0;56            for (int[] bucket : counter) {57                for (int value : bucket) {58                    arr[pos++] = value;59                }60            }61        }6263        return arr;64    }65    private int[] arrayAppend(int[] arr, int value) {66        arr = Arrays.copyOf(arr, arr.length + 1);67        arr[arr.length - 1] = value;68        return arr;69    "],[1,16772," sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int len = arr.length;1011        buildMaxHeap(arr, len);1213        for (int i = len - 1; i > 0; i--) {14            swap(arr, 0, i);15            len--;16            heapify(arr, 0, len);17        }18        return arr;19    }2021    private void buildMaxHeap(int[] arr, int len) {22        for (int i = (int) Math.floor(len / 2); i >= 0; i--) {23            heapify(arr, i, len);24        }25    }2627    private void heapify(int[] arr, int i, int len) {28        int left = 2 * i + 1;29        int right = 2 * i + 2;30        int largest = i;3132        if (left < len && arr[left] > arr[largest]) {33            largest = left;34        }3536        if (right < len && arr[right] > arr[largest]) {37            largest = right;38        }3940        if (largest != i) {41            swap(arr, i, largest);42            heapify(arr, largest, len);43        }44    }4546    private void swap(int[] arr, int i, int j) {47        int temp = arr[i];48        arr[i] = arr[j];49        arr[j] = temp;50    }5152}\n```\n\n### 8\\. 计数排序\n\n#### 8.1 算法步骤\n\n*   花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max\n\n*   开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)\n\n*   数组 B 中 index 的元素记录的值是 A 中某元素出现的次数\n\n*   最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数\n\n#### 8.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRia8NKBRZBBvsXXDtepTas9TFicryFdFqlVTg5mibDUgqAmYw2TvhoKu9ow/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n计数排序动画演示\n\n#### 8.3 参考代码\n\n```\n 1//Java 代码实现 2public class CountingSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int maxValue = getMaxValue(arr);1011        return countingSort(arr, maxValue);12    }1314    private int[] countingSort(int[] arr, int maxValue) {15        int bucketLen = maxValue + 1;16        int[] bucket = new int[bucketLen];1718        for (int value : arr) {19            bucket[value]++;20        }2122        int sortedIndex = 0;23        for (int j = 0; j < bucketLen; j++) {24            while (bucket[j] > 0) {25                arr[sortedIndex++] = j;26                bucket[j]--;27            }28        }29        return arr;30    }3132    private int getMaxValue(int[] arr) {33        int maxValue = arr[0];34        for (int value : arr) {35            if (maxValue < value) {36                maxValue = value;37            }38        }39        return maxValue;40    }4142}\n```\n\n### 9\\. 桶排序\n\n#### 9.1 算法步骤\n\n*   设置固定数量的空桶。\n\n*   把数据放到对应的桶中。\n\n*   对每个不为空的桶中数据进行排序。\n\n*   拼接不为空的桶中数据，得到结果\n\n#### 9.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRia0umOurgFRv8ESYzcK6bXknufLgJGLaiaTrDTXUk09R6ia2DhbCPAJx0A/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                         桶排序动画演示\n\n#### 9.3 参考代码\n\n```\n 1//Java 代码实现 2public class BucketSort implements IArraySort { 3 4    private static final InsertSort insertSort = new InsertSort(); 5 6    @Override 7    public int[] sort(int[] sourceArray) throws Exception { 8        // 对 arr 进行拷贝，不改变参数内容 9        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);1011        return bucketSort(arr, 5);12    }1314    private int[] bucketSort(int[] arr, int bucketSize) throws Exception {15        if (arr.length == 0) {16            return arr;17        }1819        int minValue = arr[0];20        int maxValue = arr[0];21        for (int value : arr) {22            if (value < minValue) {23                minValue = value;24            } else if (value > maxValue) {25                maxValue = value;26            }27        }2829        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;30        int[][] buckets = new int[bucketCount][0];3132        // 利用映射函数将数据分配到各个桶中33        for (int i = 0; i < arr.length; i++) {34            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);35            buckets[index] = arrAppend(buckets[index], arr[i]);36        }3738        int arrIndex = 0;39        for (int[] bucket : buckets) {40            if (bucket.length <= 0) {41                continue;42            }43            // 对每个桶进行排序，这里使用了插入排序44            bucket = insertSort.sort(bucket);45            for (int value : bucket) {46                arr[arrIndex++] = value;47            }48        }4950        return arr;51    }5253    /**54     * 自动扩容，并保存数据55     *56     * @param arr57     * @param value58     */59    private int[] arrAppend(int[] arr, int value) {60        arr = Arrays.copyOf(arr, arr.length + 1);61        arr[arr.length - 1] = value;62        return arr;63    }6465}\n```\n\n### 10\\. 基数排序\n\n#### 10.1 算法步骤\n\n*   将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零\n\n*   从最低位开始，依次进行一次排序\n\n*   从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列\n\n#### 10.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRial8LfeK5f941BmtmZcVlP0my2qgBXq6wEZ0PTDrcPqN3ntt7ibPrUxrg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                        基数排序动画演示\n\n#### 10.3 参考代码\n\n```\n 1//Java 代码实现 2public class RadixSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int maxDigit = getMaxDigit(arr);10        return radixSort(arr, maxDigit);11    }1213    /**14     * 获取最高位数15     */16    private int getMaxDigit(int[] arr) {17        int maxValue = getMaxValue(arr);18        return getNumLenght(maxValue);19    }2021    private int getMaxValue(int[] arr) {22        int maxValue = arr[0];23        for (int value : arr) {24            if (maxValue < value) {25                maxValue = value;26            }27        }28        return maxValue;29    }3031    protected int getNumLenght(long num) {32        if (num == 0) {33            return 1;34        }35        int lenght = 0;36        for (long temp = num; temp != 0; temp /= 10) {37            lenght++;38        }39        return lenght;40    }4142    private int[] radixSort(int[] arr, int maxDigit) {43        int mod = 10;44        int dev = 1;4546        for (int i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {47            // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)48            int[][] counter = new int[mod * 2][0];4950            for (int j = 0; j < arr.length; j++) {51                int bucket = ((arr[j] % mod) / dev) + mod;52                counter[bucket] = arrayAppend(counter[bucket], arr[j]);53            }5455            int pos = 0;56            for (int[] bucket : counter) {57                for (int value : bucket) {58                    arr[pos++] = value;59                }60            }61        }6263        return arr;64    }65    private int[] arrayAppend(int[] arr, int value) {66        arr = Arrays.copyOf(arr, arr.length + 1);67        arr[arr.length - 1] = value;68        return arr;69    "]],[35,35],[37,37]]],[1566826915183,["GJX@GJXAIOU",[[1,37,"："]],[37,37],[38,38]]],[1566826919493,["GJX@GJXAIOU",[[-1,274,"，很多读者在后台留言肯定了这种动画的表达方式，觉得这比一些课本上的死板讲解方式好太多了:），也有些很多读者表示如果在本文中添加配套的代码效果会更好，笔者觉得这个提议不错，于是更新了一下文章^_^。"]],[274,372],[274,274]]],[1566826952014,["GJX@GJXAIOU",[[-1,979,"\n"]],[979,979],[978,978]]],[1566826952870,["GJX@GJXAIOU",[[-1,1032,"\n"]],[1032,1032],[1031,1031]]],[1566826953612,["GJX@GJXAIOU",[[-1,1059,"\n"]],[1059,1059],[1058,1058]]],[1566827009230,["GJX@GJXAIOU",[[-1,35,"原文：[《十大经典排序算法动画，看我就够了！》](http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484095&idx=1&sn=174a8b95900448c73507955250b759cc&chksm=fa0e6d3ecd79e428aac5c52d77c335678b583926e3d3c973513c1a8444951f3e03f820375d61&scene=21#wechat_redirect)\n"]],[34,274],[34,34]]],[1566827009660,["GJX@GJXAIOU",[[-1,35,"\n"]],[34,34],[33,33]]],[1566827018291,["GJX@GJXAIOU",[[1,33,"[原文](https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg)"]],[33,33],[88,88]]],[1566827056127,["GJX@GJXAIOU",[[-1,274,"![](https://mmbiz.qpic.cn/mmbiz_png/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaKhGcwh6KibXbSiadtHqwgjmmzBYCa2DNuj5Vhw3lHc96z1wge3ZbDAeg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 \"image\")"]],[274,460],[274,274]]],[1566827061034,["GJX@GJXAIOU",[[1,274,"![各排序算法的时间复杂度和空间复杂度]($resource/%E5%90%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png)"]],[274,274],[464,464]]],[1566827064423,["GJX@GJXAIOU",[[-1,535,"\n"]],[535,535],[534,534]]],[1566827065198,["GJX@GJXAIOU",[[-1,575,"\n"]],[575,575],[574,574]]],[1566827065942,["GJX@GJXAIOU",[[-1,615,"\n"]],[615,615],[614,614]]],[1566827070566,["GJX@GJXAIOU",[[-1,696,"\n"]],[696,696],[695,695]]],[1566827136728,["GJX@GJXAIOU",[[1,1139," "],[1,1152,"\n"],[1,1201,"\n"],[1,1203,"\n"],[1,1218,"\n"],[1,1279,"\n"],[1,1310,"\n"],[1,1379,"\n"],[1,1381,"\n"],[1,1429,"\n"],[1,1493,"\n"],[1,1527,"\n"],[1,1529,"\n"],[1,1585,"\n"],[1,1629,"\n"],[1,1668,"\n"],[1,1710,"\n"],[1,1749,"\n"],[1,1751,"\n"],[1,1786,"\n"],[1,1805,"\n"],[1,1820,"\n"],[1,1822,"\n"],[1,1847,"\n"],[1,1871,"\n"],[1,1886,"\n"],[1,1897,"\n"],[1,1918,"\n"],[1,1925,"\n"]],[1139,1928],[1957,1957]]],[1566827206237,["GJX@GJXAIOU",[[-1,1139," 1"],[-1,1155,"2"],[1,1156," "],[-1,1204," 3"],[-1,1207," 4"],[-1,1224,"5 "],[-1,1285," 6"],[-1,1318,"7 "],[-1,1387," 8"],[-1,1390," 9"],[-1,1439,"10"],[-1,1504,"11"],[-1,1539,"12"],[-1,1542,"13"],[-1,1599,"14"],[-1,1644,"15"],[-1,1684,"16"],[-1,1727,"17"],[-1,1767,"18"],[-1,1770,"19"],[-1,1806,"20"],[-1,1826,"21"],[-1,1842,"22"],[-1,1845,"23"],[-1,1871,"24"],[-1,1896,"25"],[-1,1912,"26"],[-1,1924,"27"],[-1,1946,"28"],[-1,1954,"29}"],[1,1957," }\n"]],[1138,1957],[1903,1903]]]],null,"GJX@GJXAIOU"],["f0a28e8d-f9d9-4005-ba8e-a38f3944c911",1566874587501,"## 十大经典排序算法动画与解析，看我就够了！（配代码完全版）\n\n[原文](https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg)\n\n**排序算法是《数据结构与算法》中最基本的算法之一。**\n\n排序算法可以分为**内部排序**和**外部排序**。\n\n内部排序是数据记录在内存中进行排序。\n\n而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。\n\n常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。\n\n用一张图概括：\n\n![各排序算法的时间复杂度和空间复杂度]($resource/%E5%90%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png)\n\n时间复杂度与空间复杂度\n\n#### 关于时间复杂度：\n\n1.  平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。\n2.  线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；\n3.  O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序\n4.  线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。\n\n#### 关于稳定性：\n\n1.  稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。\n2.  不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。\n\n### 1\\. 冒泡排序\n\n#### 1.1 算法步骤\n\n*   比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n*   对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n*   针对所有的元素重复以上的步骤，除了最后一个。\n*   持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n#### 1.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaC1S2jpXRzXcZVn0aP6BYnkO2FJicNstxicHmf9wMIic5FV0I75ptv5jYA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n冒泡排序动画演示\n\n#### 1.3 参考代码\n\n```\n // Java 代码实现\n  public class BubbleSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) throws Exception {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        for (int i = 1; i < arr.length; i++) {\n            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。\n            boolean flag = true;\n\n            for (int j = 0; j < arr.length - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int tmp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = tmp;\n\n                    flag = false;\n                }\n            }\n\n            if (flag) {\n                break;\n            }\n        }\n        return arr;\n    }\n }\n\n```\n\n### 2\\. 选择排序\n\n#### 2.1 算法步骤\n\n*   首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n\n*   再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n*   重复第二步，直到所有元素均排序完毕。\n\n#### 2.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaB2dW1vA5SganRPChytYTFiaJL2PkXlL7XmhYmqIAzBHj0VvgJZs0vmA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n选择排序动画演示\n\n#### 2.3 参考代码\n\n```\n 1//Java 代码实现 2public class SelectionSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 7 8        // 总共要经过 N-1 轮比较 9        for (int i = 0; i < arr.length - 1; i++) {10            int min = i;1112            // 每轮需要比较的次数 N-i13            for (int j = i + 1; j < arr.length; j++) {14                if (arr[j] < arr[min]) {15                    // 记录目前能找到的最小值元素的下标16                    min = j;17                }18            }1920            // 将找到的最小值和i位置所在的值进行交换21            if (i != min) {22                int tmp = arr[i];23                arr[i] = arr[min];24                arr[min] = tmp;25            }2627        }28        return arr;29    }30}\n```\n\n### 3\\. 插入排序\n\n#### 3.1 算法步骤\n\n*   将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n\n*   从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\n#### 3.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaiatKZU4exjwcluduiclJOdZB0oZQicCrpIEaSJJg8iaia58viauSK3nhofqA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n插入排序动画演示\n\n#### 3.3 参考代码\n\n```\n 1//Java 代码实现 2public class InsertSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的10        for (int i = 1; i < arr.length; i++) {1112            // 记录要插入的数据13            int tmp = arr[i];1415            // 从已经排序的序列最右边的开始比较，找到比其小的数16            int j = i;17            while (j > 0 && tmp < arr[j - 1]) {18                arr[j] = arr[j - 1];19                j--;20            }2122            // 存在比其小的数，插入23            if (j != i) {24                arr[j] = tmp;25            }2627        }28        return arr;29    }30}\n```\n\n### 4\\. 希尔排序\n\n#### 4.1 算法步骤\n\n*   选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n\n*   按增量序列个数 k，对序列进行 k 趟排序；\n\n*   每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n#### 4.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiadtZekLQySMDdNsZTx6jyaO6spIkjPFjwqfdhd2XfRUnic1PjV1yRxrw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n希尔排序动画演示\n\n#### 4.3 参考代码\n\n```\n 1//Java 代码实现 2public class ShellSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int gap = 1;10        while (gap < arr.length) {11            gap = gap * 3 + 1;12        }1314        while (gap > 0) {15            for (int i = gap; i < arr.length; i++) {16                int tmp = arr[i];17                int j = i - gap;18                while (j >= 0 && arr[j] > tmp) {19                    arr[j + gap] = arr[j];20                    j -= gap;21                }22                arr[j + gap] = tmp;23            }24            gap = (int) Math.floor(gap / 3);25        }2627        return arr;28    }29}\n```\n\n### 5\\. 归并排序\n\n#### 5.1 算法步骤\n\n*   申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n\n*   设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n\n*   比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n\n*   重复步骤 3 直到某一指针达到序列尾；\n\n*   将另一序列剩下的所有元素直接复制到合并序列尾。\n\n#### 5.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaUbPILFO9cjn2Uy1roWIcGDOC3owGFLvuVicasstic1UjSGXmTZj5oHDw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n归并排序动画演示\n\n#### 5.3 参考代码\n\n```\n 1//Java 代码实现     public class MergeSort implements IArraySort { 2 3    @Override 4    public int[] sort(int[] sourceArray) throws Exception { 5        // 对 arr 进行拷贝，不改变参数内容 6        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 7 8        if (arr.length < 2) { 9            return arr;10        }11        int middle = (int) Math.floor(arr.length / 2);1213        int[] left = Arrays.copyOfRange(arr, 0, middle);14        int[] right = Arrays.copyOfRange(arr, middle, arr.length);1516        return merge(sort(left), sort(right));17    }1819    protected int[] merge(int[] left, int[] right) {20        int[] result = new int[left.length + right.length];21        int i = 0;22        while (left.length > 0 && right.length > 0) {23            if (left[0] <= right[0]) {24                result[i++] = left[0];25                left = Arrays.copyOfRange(left, 1, left.length);26            } else {27                result[i++] = right[0];28                right = Arrays.copyOfRange(right, 1, right.length);29            }30        }3132        while (left.length > 0) {33            result[i++] = left[0];34            left = Arrays.copyOfRange(left, 1, left.length);35        }3637        while (right.length > 0) {38            result[i++] = right[0];39            right = Arrays.copyOfRange(right, 1, right.length);40        }4142        return result;43    }4445}\n```\n\n### 6\\. 快速排序\n\n#### 6.1 算法步骤\n\n*   从数列中挑出一个元素，称为 “基准”（pivot）;\n\n*   重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n\n*   递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n#### 6.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaAY3VU8iaziaYcxAasTdrIu69BOVPYtfvqdvicmlJDS94cG2tjwZhVkdHA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n快速排序动画演示\n\n#### 6.3 参考代码\n\n```\n 1//Java 代码实现 2public class QuickSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        return quickSort(arr, 0, arr.length - 1);10    }1112    private int[] quickSort(int[] arr, int left, int right) {13        if (left < right) {14            int partitionIndex = partition(arr, left, right);15            quickSort(arr, left, partitionIndex - 1);16            quickSort(arr, partitionIndex + 1, right);17        }18        return arr;19    }2021    private int partition(int[] arr, int left, int right) {22        // 设定基准值（pivot）23        int pivot = left;24        int index = pivot + 1;25        for (int i = index; i <= right; i++) {26            if (arr[i] < arr[pivot]) {27                swap(arr, i, index);28                index++;29            }30        }31        swap(arr, pivot, index - 1);32        return index - 1;33    }3435    private void swap(int[] arr, int i, int j) {36        int temp = arr[i];37        arr[i] = arr[j];38        arr[j] = temp;39    }4041}\n```\n\n### 7\\. 堆排序\n\n#### 7.1 算法步骤\n\n*   创建一个堆 H[0……n-1]；\n\n*   把堆首（最大值）和堆尾互换；\n\n*   把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；\n\n*   重复步骤 2，直到堆的尺寸为 1。\n\n#### 7.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRian1jgiaGZE9k1xZTp9B1icHia0jIXiba3ibgnIBibdfSN4I5US4WtrQJQMiakw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                     堆排序动画演示\n\n#### 7.3 参考代码\n\n```\n 1//Java 代码实现 2public class HeapSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int len = arr.length;1011        buildMaxHeap(arr, len);1213        for (int i = len - 1; i > 0; i--) {14            swap(arr, 0, i);15            len--;16            heapify(arr, 0, len);17        }18        return arr;19    }2021    private void buildMaxHeap(int[] arr, int len) {22        for (int i = (int) Math.floor(len / 2); i >= 0; i--) {23            heapify(arr, i, len);24        }25    }2627    private void heapify(int[] arr, int i, int len) {28        int left = 2 * i + 1;29        int right = 2 * i + 2;30        int largest = i;3132        if (left < len && arr[left] > arr[largest]) {33            largest = left;34        }3536        if (right < len && arr[right] > arr[largest]) {37            largest = right;38        }3940        if (largest != i) {41            swap(arr, i, largest);42            heapify(arr, largest, len);43        }44    }4546    private void swap(int[] arr, int i, int j) {47        int temp = arr[i];48        arr[i] = arr[j];49        arr[j] = temp;50    }5152}\n```\n\n### 8\\. 计数排序\n\n#### 8.1 算法步骤\n\n*   花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max\n\n*   开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)\n\n*   数组 B 中 index 的元素记录的值是 A 中某元素出现的次数\n\n*   最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数\n\n#### 8.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRia8NKBRZBBvsXXDtepTas9TFicryFdFqlVTg5mibDUgqAmYw2TvhoKu9ow/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1 \"image\")\n\n计数排序动画演示\n\n#### 8.3 参考代码\n\n```\n 1//Java 代码实现 2public class CountingSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int maxValue = getMaxValue(arr);1011        return countingSort(arr, maxValue);12    }1314    private int[] countingSort(int[] arr, int maxValue) {15        int bucketLen = maxValue + 1;16        int[] bucket = new int[bucketLen];1718        for (int value : arr) {19            bucket[value]++;20        }2122        int sortedIndex = 0;23        for (int j = 0; j < bucketLen; j++) {24            while (bucket[j] > 0) {25                arr[sortedIndex++] = j;26                bucket[j]--;27            }28        }29        return arr;30    }3132    private int getMaxValue(int[] arr) {33        int maxValue = arr[0];34        for (int value : arr) {35            if (maxValue < value) {36                maxValue = value;37            }38        }39        return maxValue;40    }4142}\n```\n\n### 9\\. 桶排序\n\n#### 9.1 算法步骤\n\n*   设置固定数量的空桶。\n\n*   把数据放到对应的桶中。\n\n*   对每个不为空的桶中数据进行排序。\n\n*   拼接不为空的桶中数据，得到结果\n\n#### 9.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRia0umOurgFRv8ESYzcK6bXknufLgJGLaiaTrDTXUk09R6ia2DhbCPAJx0A/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                         桶排序动画演示\n\n#### 9.3 参考代码\n\n```\n 1//Java 代码实现 2public class BucketSort implements IArraySort { 3 4    private static final InsertSort insertSort = new InsertSort(); 5 6    @Override 7    public int[] sort(int[] sourceArray) throws Exception { 8        // 对 arr 进行拷贝，不改变参数内容 9        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);1011        return bucketSort(arr, 5);12    }1314    private int[] bucketSort(int[] arr, int bucketSize) throws Exception {15        if (arr.length == 0) {16            return arr;17        }1819        int minValue = arr[0];20        int maxValue = arr[0];21        for (int value : arr) {22            if (value < minValue) {23                minValue = value;24            } else if (value > maxValue) {25                maxValue = value;26            }27        }2829        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;30        int[][] buckets = new int[bucketCount][0];3132        // 利用映射函数将数据分配到各个桶中33        for (int i = 0; i < arr.length; i++) {34            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);35            buckets[index] = arrAppend(buckets[index], arr[i]);36        }3738        int arrIndex = 0;39        for (int[] bucket : buckets) {40            if (bucket.length <= 0) {41                continue;42            }43            // 对每个桶进行排序，这里使用了插入排序44            bucket = insertSort.sort(bucket);45            for (int value : bucket) {46                arr[arrIndex++] = value;47            }48        }4950        return arr;51    }5253    /**54     * 自动扩容，并保存数据55     *56     * @param arr57     * @param value58     */59    private int[] arrAppend(int[] arr, int value) {60        arr = Arrays.copyOf(arr, arr.length + 1);61        arr[arr.length - 1] = value;62        return arr;63    }6465}\n```\n\n### 10\\. 基数排序\n\n#### 10.1 算法步骤\n\n*   将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零\n\n*   从最低位开始，依次进行一次排序\n\n*   从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列\n\n#### 10.2 动画演示\n\n![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRial8LfeK5f941BmtmZcVlP0my2qgBXq6wEZ0PTDrcPqN3ntt7ibPrUxrg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n                                                                        基数排序动画演示\n\n#### 10.3 参考代码\n\n```\n 1//Java 代码实现 2public class RadixSort implements IArraySort { 3 4    @Override 5    public int[] sort(int[] sourceArray) throws Exception { 6        // 对 arr 进行拷贝，不改变参数内容 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); 8 9        int maxDigit = getMaxDigit(arr);10        return radixSort(arr, maxDigit);11    }1213    /**14     * 获取最高位数15     */16    private int getMaxDigit(int[] arr) {17        int maxValue = getMaxValue(arr);18        return getNumLenght(maxValue);19    }2021    private int getMaxValue(int[] arr) {22        int maxValue = arr[0];23        for (int value : arr) {24            if (maxValue < value) {25                maxValue = value;26            }27        }28        return maxValue;29    }3031    protected int getNumLenght(long num) {32        if (num == 0) {33            return 1;34        }35        int lenght = 0;36        for (long temp = num; temp != 0; temp /= 10) {37            lenght++;38        }39        return lenght;40    }4142    private int[] radixSort(int[] arr, int maxDigit) {43        int mod = 10;44        int dev = 1;4546        for (int i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {47            // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)48            int[][] counter = new int[mod * 2][0];4950            for (int j = 0; j < arr.length; j++) {51                int bucket = ((arr[j] % mod) / dev) + mod;52                counter[bucket] = arrayAppend(counter[bucket], arr[j]);53            }5455            int pos = 0;56            for (int[] bucket : counter) {57                for (int value : bucket) {58                    arr[pos++] = value;59                }60            }61        }6263        return arr;64    }65    private int[] arrayAppend(int[] arr, int value) {66        arr = Arrays.copyOf(arr, arr.length + 1);67        arr[arr.length - 1] = value;68        return arr;69    }70}\n```",[[1566874557442,["GJX@GJXAIOU",[[-1,1138," // Java 代码实现\n  "],[-1,1178,"implements IArraySort "],[-1,1201,"\n\n    @Override"],[-1,1234,"s"],[1,1235,"S"],[1,1242," "],[-1,1257," throws Exception "],[-1,1289," arr "],[1,1294,"原数组"],[-1,1321,"a"],[1,1322,"copyA"],[1,1324,"ay"],[-1,1404,"a"],[1,1405,"copyA"],[1,1407,"ay"],[-1,1439,"定一个"],[1,1442,"置"],[1,1446,"值"],[1,1447," "],[-1,1484,"。"],[-1,1552,"a"],[1,1553,"copyA"],[1,1555,"ay"],[-1,1595,"a"],[1,1596,"copyA"],[1,1598,"ay "],[-1,1604,"a"],[1,1605,"copyA"],[1,1607,"ay "],[-1,1648,"a"],[1,1649,"copyA"],[1,1651,"ay "],[-1,1676,"a"],[1,1677,"copyA"],[1,1679,"ay "],[-1,1685,"a"],[1,1686,"copyA"],[1,1688,"ay "],[-1,1717,"a"],[1,1718,"copyA"],[1,1720,"ay "],[-1,1734,"\n"],[-1,1802,"\n"],[-1,1889,"a"],[1,1890,"copyA"],[1,1892,"ay"],[-1,1899,"\n }\n"]],[1138,1903],[1890,1890]]],[1566874559837,["GJX@GJXAIOU",[[1,1891,"    \n"]],[1890,1890],[1895,1895]]],[1566874561439,["GJX@GJXAIOU",[[1,1895,"}"]],[1895,1895],[1896,1896]]],[1566874564364,["GJX@GJXAIOU",[[-1,1892,"   "]],[1895,1895],[1892,1892]]]],null,"GJX@GJXAIOU"]]}