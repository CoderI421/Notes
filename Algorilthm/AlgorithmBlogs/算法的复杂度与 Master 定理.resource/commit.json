{"compress":true,"commitItems":[["e8b9c868-f332-4649-aae6-72768606bfe3",1570192365573,"# [算法的复杂度与 Master 定理](https://blog.gocalf.com/algorithm-complexity-and-master-theorem)\n\n平时设计或者阅读一个算法的时候，必然会提到算法的复杂度（包括时间复杂度和空间复杂度）。比如我们说一个二分查找算法的平均时间复杂度为 O(log n)，快速排序可能是 O(n log n)。那这里的 O 是什么意思？这样的表达是否准确呢？\n\n今天来复习一下与算法复杂度相关的知识：函数渐进阶，记号 O、Ω、θ和 o；Master 定理。\n\n先插一句，在算法复杂度分析中，log 通常表示以 2 为底的对数。\n\n算法复杂度（算法复杂性）是用来衡量算法运行所需要的计算机资源（时间、空间）的量。通常我们利用渐进性态来描述算法的复杂度。\n\n用 n 表示问题的规模，T(n) 表示某个给定算法的复杂度。所谓渐进性态就是令 n→∞ 时，T(n) 中增长最快的那部分。严格的定义是：如果存在 ，当 n→∞ 时，有\n\n就说  是 T(n) 当 n→∞ 时的渐进性态。\n\n比如 T(n) = 2 * n ^ 2 + n log n + 3，那么显然它的渐进性态是 2 * n ^ 2，因为当 n→∞ 时，后两项的增长速度要慢的多，可以忽略掉。引入渐进性态是为了简化算法复杂度的表达式，只考虑其中的主要因素。当比较两个算法复杂度的时候，如果他们的渐进复杂度的阶不相同，那只需要比较彼此的阶（忽略常数系数）就可以了。\n\n总之，分析算法复杂度的时候，并不用严格演算出一个具体的公式，而是只需要分析当问题规模充分大的时候，复杂度在渐进意义下的阶。记号 O、Ω、θ和 o 可以帮助我们了解函数渐进阶的大小。\n\n假设有两个函数 f(n) 和 g(n)，都是定义在正整数集上的正函数。上述四个记号的含义分别是：\n\n*   f(n) = O(g(n))：；f 的阶**不高于** g 的阶。\n*   f(n) = Ω(g(n))：；f 的阶**不低于** g 的阶。\n*   f(n) = θ(g(n))：；f 的阶**等于** g 的阶。\n*   f(n) = o(g(n))：；f 的阶**低于** g 的阶。\n\n可见，记号 O 给出了函数 f(n) 在渐进意义下的上界（但不一定是最小的），相反，记号Ω给出的是下界（不一定是最大的）。如果上界与下界相同，表示 f(n) 和 g(n) 在渐进意义下是同阶的（θ），亦即复杂度一样。\n\n列举一些常见的函数之间的渐进阶的关系：\n\n有些人可能会把这几个记号跟算法的最坏、最好、平均情况复杂度混淆，它们有区别，也有一定的联系。\n\n即使问题的规模相同，随着输入数据本身属性的不同，算法的处理时间也可能会不同。于是就有了最坏情况、最好情况和平均情况下算法复杂度的区别。它们从不同的角度反映了算法的效率，各有用处，也各有局限。\n\n有时候也可以利用最坏情况、最好情况下算法复杂度来粗略地估计算法的性能。比如某个算法在最坏情况下时间复杂度为θ(n ^ 2)，最好情况下为θ(n)，那这个算法的复杂度一定是 O(n ^ 2)、Ω(n) 的。也就是说 n ^ 2 是该算法复杂度的上界，n 是其下界。\n\n接下来看看 Master 定理。\n\n有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的：\n\n设常数 a >= 1，b > 1，f(n) 为函数，T(n) 为非负整数，T(n) = a T(n / b) + f(n)，则有：\n\n1.  若 ，那么 。\n2.  若 ，那么 。\n3.  若 ，并且对于某个常数 c < 1 和充分大的 n 有 ，那么 。\n\n比如常见的二分查找算法，时间复杂度的递推方程为 T(n) = T(n / 2) + θ(1)，显然有 ，满足 Master 定理第二条，可以得到其时间复杂度为 T(n) = θ(log n)。\n\n再看一个例子，T(n) = 9 T(n / 3) + n，可知 ，令ε取 1，显然满足 Master 定理第一条，可以得到 T(n) = θ(n ^ 2)。\n\n来一个稍微复杂一点儿例子，T(n) = 3 T(n / 4) + n log n。，取ε = 0.2，显然当 c = 3 / 4 时，对于充分大的 n 可以满足 a * f(n / b) = 3 * (n / 4) * log(n / 4) <= (3 / 4) * n * log n = c * f(n)，符合 Master 定理第三条，因此求得 T(n) = θ(n log n)。\n\n运用 Master 定理的时候，有一点一定要**特别注意**，就是第一条和第三条中的ε必须**大于零**。如果无法找到大于零的ε，就不能使用这两条规则。\n\n举个例子，T(n) = 2 T(n / 2) + n log n。可知 ，而 f(n) = n log n，显然不满足 Master 定理第二条。但对于第一条和第三条，也无法找到大于零的ε使得  或者 ，因此不能用 Master 定理求解，只能寻求别的方式求解。比如可以利用递归树求出该算法的复杂度为 。简单的说一下计算过程：\n\n递归树的建立过程，就像是模拟算法的递推过程。树根对应的是输入的规模为 n 的问题，在递归处理子问题之外，还需要 n log n 的处理时间。然后根据递推公式给根节点添加子节点，每个子节点对应一个子问题。这里需要两个子节点，每个节点处理规模为 n / 2 的问题，分别需要 (n / 2) * log(n / 2) 的时间。因此在第二层一共需要 n * (log n - 1) 的时间。第三层节点就是将第二层的两个节点继续分裂开，得到四个各需要 (n / 4) * log(n / 4) 时间的节点，总的时间消耗为 n * (log n - 2)。依此类推，第 k（设树根为 k = 0）层有 2 ^ k 的节点，总的时间为 n * (log n - k)。而且可以知道，这棵树总共有 log n 层（最后一层每个节点只处理规模为 1 的子问题，无须再分治）。最后将每一层消耗的时间累加起来，得到：\n\nLike this post? Share on: [Twitter](https://twitter.com/intent/tweet?text=%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%20Master%20%E5%AE%9A%E7%90%86&url=https%3A//blog.gocalf.com/algorithm-complexity-and-master-theorem&via=calfzhou&hashtags=algorithm%20complexity,master%20theorem \"Share on Twitter\") ❄ [Facebook](https://www.facebook.com/sharer/sharer.php?u=https%3A//blog.gocalf.com/algorithm-complexity-and-master-theorem \"Share on Facebook\") ❄ [Email](mailto:?subject=%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%20Master%20%E5%AE%9A%E7%90%86&body=https%3A//blog.gocalf.com/algorithm-complexity-and-master-theorem \"Share via Email\")",[[1570192362895,["GJX@GJXAIOU",[[-1,22,"https://blog.gocalf.com/algorithm-complexity-and-master-theorem"]],[22,85],[22,22]]],[1570192374206,["GJX@GJXAIOU",[[1,24,"[原文链接](https://blog.gocalf.com/algorithm-complexity-and-master-theorem)"]],[24,24],[95,95]]],[1570192376805,["GJX@GJXAIOU",[[-1,20,"]()"]],[23,23],[20,20]]],[1570192378110,["GJX@GJXAIOU",[[-1,2,"["]],[3,3],[2,2]]],[1570192379110,["GJX@GJXAIOU",[[1,20,"\n"]],[19,19],[20,20]]],[1570192413003,["GJX@GJXAIOU",[[1,1568,"f(n)=O(n^{\\log_b a-\\varepsilon}),\\varepsilon > 0"]],[1568,1568],[1616,1616]]],[1570192413030,["GJX@GJXAIOU",[[1,1568," "]],[1616,1616],[1617,1617]]],[1570192418300,["GJX@GJXAIOU",[[-1,431," "],[1,432," "],[-1,446,"  "],[1,448,"  "],[-1,815," "],[1,816," "],[-1,832," "],[1,833," "],[-1,853," "],[1,854," "],[-1,870," "],[1,871," "],[-1,890," "],[1,891," "],[-1,907," "],[1,908," "],[-1,927," "],[1,928," "],[-1,1300," "],[1,1301," "],[-1,1617," ，那么 "],[1,1622,"$ ，那么 "],[-1,1629," ，那么 "],[1,1634," ，那么 "],[-1,1641," "],[1,1642," "],[-1,1667," ，那么 "],[1,1672," ，那么 "],[-1,1725," "],[1,1726," "],[-1,1804," "],[1,1805," "],[-1,1841," "],[1,1842," "],[-1,2035," "],[1,2036," "],[-1,2162," "],[1,2163," "],[-1,2223,"  或者 "],[1,2228,"  或者 "],[-1,2277," "],[1,2278," "],[-1,2717," "],[1,2718," "],[-1,3011," ❄ "],[1,3014," ❄ "],[-1,3156," ❄ "],[1,3159," ❄ "]],[1617,1617],[1618,1618]]],[1570192421746,["GJX@GJXAIOU",[[1,1569,"$"]],[1569,1569],[1570,1570]]],[1570192451605,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1570192453152,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1570192453287,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1570192453385,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1570192453412,["GJX@GJXAIOU",[[1,4,"\n---\n\n"]],[3,3],[4,4]]],[1570192461590,["GJX@GJXAIOU",[[1,4,"flag: red"]],[4,4],[13,13]]]],null,"GJX@GJXAIOU"]]}