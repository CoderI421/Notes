{"compress":true,"commitItems":[["ffd60d7c-cdb8-4bbd-bd97-0ab2bfef311a",1570192908779,"",[[1570192852006,["GJX@GJXAIOU",[[1,0,"# AlgorithmEasyDay02\n\n\n\n"]],[0,0],[23,23]]],[1570192860204,["GJX@GJXAIOU",[[1,22,"****"]],[22,22],[24,24]]],[1570192861239,["GJX@GJXAIOU",[[1,24,"litu"]],[24,24],[28,28]]],[1570192862480,["GJX@GJXAIOU",[[-1,24,"litu"]],[28,28],[24,24]]],[1570192865192,["GJX@GJXAIOU",[[1,24,"立体"]],[24,24],[26,26]]],[1570192865759,["GJX@GJXAIOU",[[-1,24,"立体"]],[26,26],[24,24]]],[1570192868058,["GJX@GJXAIOU",[[1,24,"例题："]],[24,24],[27,27]]],[1570192869634,["GJX@GJXAIOU",[[1,31,"\n"]],[29,29],[30,30]]],[1570192877590,["GJX@GJXAIOU",[[1,31,"给定一个数组arr，和一个数num，请把小于等于num的数放在数\n组的左边，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)"]],[31,31],[108,108]]],[1570192880046,["GJX@GJXAIOU",[[-1,63,"\n"]],[64,64],[63,63]]],[1570192891417,["GJX@GJXAIOU",[[1,107,"；"]],[107,107],[108,108]]],[1570192891977,["GJX@GJXAIOU",[[1,109,"\n"]],[108,108],[109,109]]],[1570192892094,["GJX@GJXAIOU",[[1,110,"\n"]],[109,109],[110,110]]],[1570192892223,["GJX@GJXAIOU",[[1,111,"\n"]],[110,110],[111,111]]],[1570192892342,["GJX@GJXAIOU",[[1,112,"\n"]],[111,111],[112,112]]],[1570192892910,["GJX@GJXAIOU",[[1,112,"问题二（荷兰国旗问题）\n给定一个数组arr，和一个数num，请把小于num的数放在数组的\n左边，等于num的数放在数组的中间，大于num的数放在数组的\n右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)"]],[112,112],[215,215]]],[1570192895287,["GJX@GJXAIOU",[[-1,156,"\n"]],[156,156],[156,156]]],[1570192896511,["GJX@GJXAIOU",[[-1,186,"\n"]],[186,186],[186,186]]],[1570193092143,["GJX@GJXAIOU",[[1,109,"![示例]($resource/%E7%A4%BA%E4%BE%8B.png)"]],[109,109],[149,149]]],[1570193647207,["GJX@GJXAIOU",[[1,149,"其中 x zuo"]],[149,149],[157,157]]],[1570193648042,["GJX@GJXAIOU",[[-1,154,"zuo"]],[157,157],[154,154]]],[1570193651158,["GJX@GJXAIOU",[[1,154,"坐标为 k"]],[154,154],[159,159]]],[1570193651831,["GJX@GJXAIOU",[[-1,158,"k"]],[159,159],[158,158]]],[1570193672026,["GJX@GJXAIOU",[[1,158,"L - 1，《"]],[158,158],[165,165]]],[1570193672713,["GJX@GJXAIOU",[[-1,164,"《"]],[165,165],[164,164]]],[1570193675046,["GJX@GJXAIOU",[[1,164,">-"]],[164,164],[166,166]]],[1570193675502,["GJX@GJXAIOU",[[-1,165,"-"]],[166,166],[165,165]]],[1570193675745,["GJX@GJXAIOU",[[1,165,"-"]],[165,165],[166,166]]],[1570193676353,["GJX@GJXAIOU",[[-1,165,"-"]],[166,166],[165,165]]],[1570193677784,["GJX@GJXAIOU",[[1,165,"=x "]],[165,165],[168,168]]],[1570193681901,["GJX@GJXAIOU",[[-1,164,">=x "]],[168,168],[164,164]]],[1570193682503,["GJX@GJXAIOU",[[1,164,"，"]],[164,164],[165,165]]],[1570193683142,["GJX@GJXAIOU",[[-1,164,"，"]],[165,165],[164,164]]],[1570193683697,["GJX@GJXAIOU",[[1,164,","]],[164,164],[165,165]]],[1570193684255,["GJX@GJXAIOU",[[-1,164,","]],[165,165],[164,164]]],[1570193684778,["GJX@GJXAIOU",[[1,164,"，"]],[164,164],[165,165]]],[1570193685216,["GJX@GJXAIOU",[[-1,164,"，"]],[165,165],[164,164]]],[1570193686870,["GJX@GJXAIOU",[[1,164,"<"]],[164,164],[165,165]]],[1570193690542,["GJX@GJXAIOU",[[1,166,"x weizh"]],[166,166],[173,173]]],[1570193691369,["GJX@GJXAIOU",[[-1,168,"weizh"]],[173,173],[168,168]]],[1570193694635,["GJX@GJXAIOU",[[1,168,"位置上防护罩"]],[168,168],[174,174]]],[1570193695926,["GJX@GJXAIOU",[[-1,171,"防护罩"]],[174,174],[171,171]]],[1570193697746,["GJX@GJXAIOU",[[1,171,"防止"]],[171,171],[173,173]]],[1570193699044,["GJX@GJXAIOU",[[-1,171,"防止"]],[173,173],[171,171]]],[1570193708263,["GJX@GJXAIOU",[[1,171,"放置的都是 ,- "]],[171,171],[180,180]]],[1570193710030,["GJX@GJXAIOU",[[-1,177,",- "]],[180,180],[177,177]]],[1570193710778,["GJX@GJXAIOU",[[1,177,"《"]],[177,177],[178,178]]],[1570193711321,["GJX@GJXAIOU",[[-1,177,"《"]],[178,178],[177,177]]],[1570193714121,["GJX@GJXAIOU",[[1,177,"<= mum"]],[177,177],[183,183]]],[1570193714791,["GJX@GJXAIOU",[[-1,180,"mum"]],[183,183],[180,180]]],[1570193715665,["GJX@GJXAIOU",[[1,180,"nujm"]],[180,180],[184,184]]],[1570193716369,["GJX@GJXAIOU",[[-1,182,"jm"]],[184,184],[182,182]]],[1570193722081,["GJX@GJXAIOU",[[1,182,"m 值的数"]],[182,182],[187,187]]],[1570193808820,[null,[[-1,165,"\n"],[1,166,"="],[1,187,"\n"]],[165,165],[188,188]]],[1570193808820,[null,[[1,165,"\n"],[-1,165,"="],[-1,187,"\n"]],[188,188],[165,165]]],[1570193804944,["GJX@GJXAIOU",[[1,187,"，然后依次向右遍历，如果该数小于等于 num，则不动，x zhi"]],[187,187],[219,219]]],[1570193806206,["GJX@GJXAIOU",[[-1,215," zhi"]],[219,219],[215,215]]],[1570193808624,["GJX@GJXAIOU",[[1,215,"向右"]],[215,215],[217,217]]],[1570193808647,["GJX@GJXAIOU",[[1,215," "]],[217,217],[218,218]]],[1570193868803,[null,[[-1,165,"\n"],[1,166,"="],[1,218,"\n"]],[165,165],[219,219]]],[1570193868803,[null,[[1,165,"\n"],[-1,165,"="],[-1,218,"\n"]],[219,219],[165,165]]],[1570193816870,["GJX@GJXAIOU",[[1,218,"移动一位，即 x + 1,"]],[218,218],[231,231]]],[1570193817471,["GJX@GJXAIOU",[[-1,230,","]],[231,231],[230,230]]],[1570193842127,["GJX@GJXAIOU",[[1,230,"，如果该数大于 num，则该数和 想+ "]],[230,230],[250,250]]],[1570193843102,["GJX@GJXAIOU",[[-1,247,"想+ "]],[250,250],[247,247]]],[1570193852190,["GJX@GJXAIOU",[[1,247,"x + 1 位置上的数互换，"]],[247,247],[261,261]]],[1570193866524,["GJX@GJXAIOU",[[-1,201,"小于"]],[203,203],[201,201]]],[1570193928806,[null,[[-1,165,"\n"],[1,166,"="],[1,259,"\n"]],[165,165],[260,260]]],[1570193928806,[null,[[1,165,"\n"],[-1,165,"="],[-1,259,"\n"]],[260,260],[165,165]]],[1570193871064,["GJX@GJXAIOU",[[1,201,"大于"]],[201,201],[203,203]]],[1570193872900,["GJX@GJXAIOU",[[-1,203,"等于"]],[205,205],[203,203]]],[1570193876398,["GJX@GJXAIOU",[[-1,233,"大于"]],[235,235],[233,233]]],[1570193881683,["GJX@GJXAIOU",[[1,233,"小于等于"]],[233,233],[237,237]]],[1570193908873,["GJX@GJXAIOU",[[1,261,"以此类推；"]],[261,261],[266,266]]],[1570193915998,["GJX@GJXAIOU",[[1,370,"\n"]],[369,369],[370,370]]],[1570194049556,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"]],[165,165],[267,267]]],[1570194049556,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"]],[267,267],[165,165]]],[1570194013614,["GJX@GJXAIOU",[[1,370,"![示例2]($resource/%E7%A4%BA%E4%BE%8B2.png)\n"]],[370,370],[412,412]]],[1570194023309,["GJX@GJXAIOU",[[1,413,"\n"]],[412,412],[413,413]]],[1570194025058,["GJX@GJXAIOU",[[-1,413,"\n"],[1,414,"x"]],[413,413],[414,414]]],[1570194029368,["GJX@GJXAIOU",[[1,414," zuo"]],[414,414],[418,418]]],[1570194030012,["GJX@GJXAIOU",[[-1,415,"zuo"]],[418,418],[415,415]]],[1570194038088,["GJX@GJXAIOU",[[1,415,"坐标为 L - 1,"]],[415,415],[425,425]]],[1570194039182,["GJX@GJXAIOU",[[-1,424,","]],[425,425],[424,424]]],[1570194048927,["GJX@GJXAIOU",[[1,424,"，y 坐标为 R + 1，"]],[424,424],[437,437]]],[1570194109556,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"],[-1,368,"\n"]],[165,165],[368,368]]],[1570194109556,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"],[1,369,"\n"]],[368,368],[165,165]]],[1570194062977,["GJX@GJXAIOU",[[1,437,"两边分别表示 <,"]],[437,437],[446,446]]],[1570194064494,["GJX@GJXAIOU",[[-1,443," <,"]],[446,446],[443,443]]],[1570194064713,["GJX@GJXAIOU",[[1,443,"x"]],[443,443],[444,444]]],[1570194064737,["GJX@GJXAIOU",[[1,443," "]],[444,444],[445,445]]],[1570194064925,["GJX@GJXAIOU",[[1,445,"ia"]],[445,445],[447,447]]],[1570194065681,["GJX@GJXAIOU",[[-1,443," xia"]],[447,447],[443,443]]],[1570194092062,["GJX@GJXAIOU",[[1,443,"小于 num 和大于 num 的值，当前位置坐标为 cur,"]],[443,443],[473,473]]],[1570194093038,["GJX@GJXAIOU",[[-1,472,","]],[473,473],[472,472]]],[1570194093503,["GJX@GJXAIOU",[[1,472,"，"]],[472,472],[473,473]]],[1570194169558,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"],[-1,368,"\n"]],[165,165],[368,368]]],[1570194169558,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"],[1,369,"\n"]],[368,368],[165,165]]],[1570194152276,["GJX@GJXAIOU",[[1,473,"然后依次向右遍历，如果该数小于 num，则该数和小于区域最右边小标"]],[473,473],[506,506]]],[1570194153598,["GJX@GJXAIOU",[[-1,504,"小标"]],[506,506],[504,504]]],[1570194159639,["GJX@GJXAIOU",[[1,504,"下标（）"]],[504,504],[508,508]]],[1570194162700,["GJX@GJXAIOU",[[1,507,"x"]],[507,507],[508,508]]],[1570194229562,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"],[-1,368,"\n"]],[165,165],[368,368]]],[1570194229562,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"],[1,369,"\n"]],[368,368],[165,165]]],[1570194197031,["GJX@GJXAIOU",[[1,509,"的下一个坐标元素交换，小于区域向右扩充（）"]],[509,509],[530,530]]],[1570194202822,["GJX@GJXAIOU",[[1,529,"即 x + 1"]],[529,529],[536,536]]],[1570194204322,["GJX@GJXAIOU",[[1,537,","]],[537,537],[538,538]]],[1570194205294,["GJX@GJXAIOU",[[-1,537,","]],[538,538],[537,537]]],[1570194209230,["GJX@GJXAIOU",[[1,537,"，如果 "]],[537,537],[541,541]]],[1570194210965,["GJX@GJXAIOU",[[-1,540," "]],[541,541],[540,540]]],[1570194213718,["GJX@GJXAIOU",[[1,540,"该数 ="]],[540,540],[544,544]]],[1570194214598,["GJX@GJXAIOU",[[-1,542," ="]],[544,544],[542,542]]],[1570194216111,["GJX@GJXAIOU",[[1,542,"等于n"]],[542,542],[545,545]]],[1570194216134,["GJX@GJXAIOU",[[1,544," "]],[545,545],[546,546]]],[1570194223281,["GJX@GJXAIOU",[[1,546,"um ,则 cur指向"]],[546,546],[557,557]]],[1570194223304,["GJX@GJXAIOU",[[1,555," "]],[557,557],[558,558]]],[1570194225931,["GJX@GJXAIOU",[[1,558,"下一个匀速"]],[558,558],[563,563]]],[1570194226591,["GJX@GJXAIOU",[[-1,561,"匀速"]],[563,563],[561,561]]],[1570194228199,["GJX@GJXAIOU",[[1,561,"元素"]],[561,561],[563,563]]],[1570194289561,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"],[-1,368,"\n"]],[165,165],[368,368]]],[1570194289561,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"],[1,369,"\n"]],[368,368],[165,165]]],[1570194241328,["GJX@GJXAIOU",[[1,563,"，如果 "]],[563,563],[567,567]]],[1570194242040,["GJX@GJXAIOU",[[-1,566," "]],[567,567],[566,566]]],[1570194244562,["GJX@GJXAIOU",[[1,566,"大于num"]],[566,566],[571,571]]],[1570194244584,["GJX@GJXAIOU",[[1,568," "]],[571,571],[572,572]]],[1570194283505,["GJX@GJXAIOU",[[1,572,"，则该数和大于区域最左边区域的前一个坐标元素交换，大于区域向左寇冲"]],[572,572],[605,605]]],[1570194284110,["GJX@GJXAIOU",[[-1,603,"寇冲"]],[605,605],[603,603]]],[1570194286267,["GJX@GJXAIOU",[[1,603,"扩种"]],[603,603],[605,605]]],[1570194287630,["GJX@GJXAIOU",[[-1,603,"扩种"]],[605,605],[603,603]]],[1570194349563,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"],[-1,368,"\n"]],[165,165],[368,368]]],[1570194349563,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"],[1,369,"\n"]],[368,368],[165,165]]],[1570194292136,["GJX@GJXAIOU",[[1,603,"扩充一个（）"]],[603,603],[609,609]]],[1570194296718,["GJX@GJXAIOU",[[1,608,"即 y - 1"]],[608,608],[615,615]]],[1570194298230,["GJX@GJXAIOU",[[1,616,","]],[616,616],[617,617]]],[1570194298664,["GJX@GJXAIOU",[[-1,616,","]],[617,617],[616,616]]],[1570194318517,["GJX@GJXAIOU",[[1,616,"，然后贾环"]],[616,616],[621,621]]],[1570194319486,["GJX@GJXAIOU",[[-1,619,"贾环"]],[621,621],[619,619]]],[1570194348769,["GJX@GJXAIOU",[[1,619,"这里交换回来的数还需要"]],[619,619],[630,630]]],[1570194409566,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"],[-1,368,"\n"]],[165,165],[368,368]]],[1570194409566,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"],[1,369,"\n"]],[368,368],[165,165]]],[1570194365448,["GJX@GJXAIOU",[[1,630,"按照上面的标准进行判断，知道 "]],[630,630],[645,645]]],[1570194366454,["GJX@GJXAIOU",[[-1,642,"知道 "]],[645,645],[642,642]]],[1570194376677,["GJX@GJXAIOU",[[1,642,"直到 cur 和 有边界"]],[642,642],[654,654]]],[1570194377717,["GJX@GJXAIOU",[[-1,651,"有边界"]],[654,654],[651,651]]],[1570194386528,["GJX@GJXAIOU",[[1,651,"又边界相遇停止；"]],[651,651],[659,659]]],[1570194649572,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"],[-1,368,"\n"]],[165,165],[368,368]]],[1570194649572,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"],[1,369,"\n"]],[368,368],[165,165]]],[1570194638599,["GJX@GJXAIOU",[[1,659,"\n\n"]],[659,659],[660,660]]],[1570194638714,["GJX@GJXAIOU",[[1,661,"\n"]],[660,660],[661,661]]],[1570194638863,["GJX@GJXAIOU",[[1,662,"\n"]],[661,661],[662,662]]],[1570194638992,["GJX@GJXAIOU",[[1,663,"\n"]],[662,662],[663,663]]],[1570194643655,["GJX@GJXAIOU",[[-1,663,"\n"],[1,664,"*"]],[663,663],[664,664]]],[1570194643799,["GJX@GJXAIOU",[[1,664,"***"]],[664,664],[665,665]]],[1570194644534,["GJX@GJXAIOU",[[-1,665,"**"]],[665,665],[663,663]]],[1570194645976,["GJX@GJXAIOU",[[-1,664,"*"]],[665,665],[664,664]]],[1570194646088,["GJX@GJXAIOU",[[-1,663,"*"],[1,664,"\n"]],[664,664],[663,663]]],[1570194649223,["GJX@GJXAIOU",[[1,663,"## "]],[663,663],[666,666]]],[1570194709573,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"],[-1,368,"\n"]],[165,165],[368,368]]],[1570194709573,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"],[1,369,"\n"]],[368,368],[165,165]]],[1570194656420,["GJX@GJXAIOU",[[1,666,"二、快速排序"]],[666,666],[672,672]]],[1570194656855,["GJX@GJXAIOU",[[1,673,"\n"]],[672,672],[673,673]]],[1570194829574,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"],[-1,368,"\n"]],[165,165],[368,368]]],[1570194829574,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"],[1,369,"\n"]],[368,368],[165,165]]],[1570194808121,["GJX@GJXAIOU",[[1,673,"### 经典快排"]],[673,673],[681,681]]],[1570194808601,["GJX@GJXAIOU",[[1,682,"\n"]],[681,681],[682,682]]],[1570194889578,[null,[[-1,165,"\n"],[1,166,"="],[1,266,"\n"],[-1,368,"\n"]],[165,165],[368,368]]],[1570194889578,[null,[[1,165,"\n"],[-1,165,"="],[-1,266,"\n"],[1,369,"\n"]],[368,368],[165,165]]],[1570194830138,["GJX@GJXAIOU",[[-1,682,"\n"],[1,683,"首先"]],[682,682],[684,684]]],[1570194833042,["GJX@GJXAIOU",[[1,684,"以数组"]],[684,684],[687,687]]]],null,"GJX@GJXAIOU"],["9b18b3c1-33be-4187-ada2-8164972f5b8d",1570195211843,"# AlgorithmEasyDay02\n\n**例题：**\n\n给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)；\n![示例]($resource/%E7%A4%BA%E4%BE%8B.png)\n其中 x 坐标为 L - 1，<=x 位置上放置的都是 <= num 值的数，然后依次向右遍历，如果该数大于 num，则不动，x 向右移动一位，即 x + 1，如果该数小于等于 num，则该数和 x + 1 位置上的数互换，以此类推；\n\n问题二（荷兰国旗问题）\n给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)\n![示例2]($resource/%E7%A4%BA%E4%BE%8B2.png)\n\nx 坐标为 L - 1，y 坐标为 R + 1，两边分别表示小于 num 和大于 num 的值，当前位置坐标为 cur，然后依次向右遍历，如果该数小于 num，则该数和小于区域最右边下标（x）的下一个坐标元素交换，小于区域向右扩充（即 x + 1），如果该数等于 num ,则 cur 指向下一个元素，如果大于 num，则该数和大于区域最左边区域的前一个坐标元素交换，大于区域向左扩充一个（即 y - 1），然后这里交换回来的数还需要按照上面的标准进行判断，直到 cur 和 又边界相遇停止；\n\n\n\n## 二、快速排序\n### 经典快排\n首先以数组",[[1570195183337,["GJX@GJXAIOU",[[1,687,"最后一个数值为急转"]],[687,687],[696,696]]],[1570195184006,["GJX@GJXAIOU",[[-1,694,"急转"]],[696,696],[694,694]]],[1570195187720,["GJX@GJXAIOU",[[1,694,"基准，将"]],[694,694],[698,698]]],[1570195235560,["GJX@GJXAIOU",[[1,698,"小于等于该数值的全部放在数组前半部分。"]],[698,698],[717,717]]],[1570195236727,["GJX@GJXAIOU",[[-1,716,"。"]],[717,717],[716,716]]],[1570195252433,["GJX@GJXAIOU",[[1,716,"，大于该数值的全部放在数组的后半部分，"]],[716,716],[735,735]]],[1570195253576,["GJX@GJXAIOU",[[-1,734,"，"]],[735,735],[734,734]]],[1570195267129,["GJX@GJXAIOU",[[1,734,"，然后前半部分和后半部分分别以"]],[734,734],[749,749]]],[1570195417745,["GJX@GJXAIOU",[[1,749,"该部分最后一个元素为急转"]],[749,749],[761,761]]],[1570195419614,["GJX@GJXAIOU",[[-1,759,"急转"]],[761,761],[759,759]]],[1570195431850,["GJX@GJXAIOU",[[1,759,"基准重复以上步骤"]],[759,759],[767,767]]],[1570195900568,["GJX@GJXAIOU",[[1,767,"；"]],[767,767],[768,768]]],[1570195916359,["GJX@GJXAIOU",[[1,768,"\n\n"]],[768,768],[769,769]]],[1570195916496,["GJX@GJXAIOU",[[1,770,"\n"]],[769,769],[770,770]]],[1570195917793,["GJX@GJXAIOU",[[-1,770,"\n"],[1,771,"*"]],[770,770],[771,771]]],[1570195917934,["GJX@GJXAIOU",[[1,771,"***"]],[771,771],[772,772]]],[1570195920106,["GJX@GJXAIOU",[[1,772,"改进"]],[772,772],[774,774]]],[1570195921481,["GJX@GJXAIOU",[[1,776,"\n\n"]],[776,776],[777,777]]],[1570195922912,["GJX@GJXAIOU",[[-1,777,"\n"],[1,778,"首先"]],[777,777],[779,779]]],[1570195925178,["GJX@GJXAIOU",[[1,779,"海慧寺"]],[779,779],[782,782]]],[1570195926311,["GJX@GJXAIOU",[[-1,779,"海慧寺"]],[782,782],[779,779]]],[1570195929248,["GJX@GJXAIOU",[[1,779,"还是"]],[779,779],[781,781]]],[1570195940735,["GJX@GJXAIOU",[[1,781,"选取数组最后一个值为击穿"]],[781,781],[793,793]]],[1570195941840,["GJX@GJXAIOU",[[-1,791,"击穿"]],[793,793],[791,791]]],[1570195943529,["GJX@GJXAIOU",[[1,791,"急转，"]],[791,791],[794,794]]],[1570195944142,["GJX@GJXAIOU",[[-1,791,"急转，"]],[794,794],[791,791]]],[1570195957736,["GJX@GJXAIOU",[[1,791,"基准，但是判断"]],[791,791],[798,798]]],[1570195959663,["GJX@GJXAIOU",[[-1,794,"但是判断"]],[798,798],[794,794]]],[1570195979859,["GJX@GJXAIOU",[[1,794,"但是遍历判断的时候最后一个值不再进行判断，即"]],[794,794],[816,816]]],[1570195996337,["GJX@GJXAIOU",[[1,816,"判断"]],[816,816],[818,818]]],[1570196002560,["GJX@GJXAIOU",[[-1,816,"判断"]],[818,818],[816,816]]],[1570196010584,["GJX@GJXAIOU",[[1,816,"只有 L ~ R -`"]],[816,816],[827,827]]],[1570196011894,["GJX@GJXAIOU",[[-1,826,"`"]],[827,827],[826,826]]],[1570196012718,["GJX@GJXAIOU",[[1,826,"1"]],[826,826],[827,827]]],[1570196013751,["GJX@GJXAIOU",[[1,826," "]],[826,826],[827,827]]],[1570196016164,["GJX@GJXAIOU",[[1,828," 的注意"]],[828,828],[832,832]]],[1570196016776,["GJX@GJXAIOU",[[-1,830,"注意"]],[832,832],[830,830]]],[1570196049801,["GJX@GJXAIOU",[[1,830,"值与基准进行比较，同时区域划分为三个区域：小于基准、等于基准、大于"]],[830,830],[863,863]]],[1570196060876,["GJX@GJXAIOU",[[1,863,"基准；然后遍历"]],[863,863],[870,870]]],[1570196062030,["GJX@GJXAIOU",[[-1,868,"遍历"]],[870,870],[868,868]]],[1570196108329,["GJX@GJXAIOU",[[1,868,"将小于基准和大于基准部分进行再次取最后一个数，同上进行比较，"]],[868,868],[898,898]]],[1570196113734,["GJX@GJXAIOU",[[-1,897,"，"]],[898,898],[897,897]]],[1570196152499,["GJX@GJXAIOU",[[1,897,".....最后全部比较结束之后，将最后一个基准值和大于该基准"]],[897,897],[927,927]]],[1570196189175,["GJX@GJXAIOU",[[-1,921,"和"]],[922,922],[921,921]]],[1570196191530,["GJX@GJXAIOU",[[1,921,"放在"]],[921,921],[923,923]]],[1570196206794,["GJX@GJXAIOU",[[1,928,"的范围的前一个位置；"]],[928,928],[938,938]]],[1570196245546,["GJX@GJXAIOU",[[1,938,"\n\n"]],[938,938],[939,939]]],[1570196245663,["GJX@GJXAIOU",[[1,940,"\n"]],[939,939],[940,940]]],[1570196245795,["GJX@GJXAIOU",[[1,941,"\n"]],[940,940],[941,941]]],[1570196250470,["GJX@GJXAIOU",[[-1,941,"\n"],[1,942,"特斯安"]],[941,941],[944,944]]],[1570196251078,["GJX@GJXAIOU",[[-1,942,"斯安"]],[944,944],[942,942]]],[1570196251206,["GJX@GJXAIOU",[[-1,941,"特"],[1,942,"\n"]],[942,942],[941,941]]],[1570196253203,["GJX@GJXAIOU",[[-1,941,"\n"],[1,942,"特斯安"]],[941,941],[944,944]]],[1570196253793,["GJX@GJXAIOU",[[-1,942,"斯安"]],[944,944],[942,942]]],[1570196253911,["GJX@GJXAIOU",[[-1,941,"特"],[1,942,"\n"]],[942,942],[941,941]]],[1570196257483,["GJX@GJXAIOU",[[-1,941,"\n"],[1,942,"特点"]],[941,941],[943,943]]],[1570196257767,["GJX@GJXAIOU",[[1,943,"："]],[943,943],[944,944]]],[1570196258158,["GJX@GJXAIOU",[[1,944,"\n\n"]],[944,944],[945,945]]],[1570196259778,["GJX@GJXAIOU",[[-1,945,"\n"],[1,946,"-"]],[945,945],[946,946]]],[1570196285762,["GJX@GJXAIOU",[[1,946," 经典快排和数据的状态有关：\n- "]],[946,946],[963,963]]],[1570196286887,["GJX@GJXAIOU",[[1,961,"  "]],[963,963],[965,965]]],[1570196288451,["GJX@GJXAIOU",[[1,965,"当"]],[965,965],[966,966]]],[1570196300881,["GJX@GJXAIOU",[[1,966,"小于最后一个数组的"]],[966,966],[975,975]]],[1570196301927,["GJX@GJXAIOU",[[-1,972,"数组的"]],[975,975],[972,972]]],[1570196322817,["GJX@GJXAIOU",[[1,972,"数值的元素远大于大于的"]],[972,972],[983,983]]],[1570196324470,["GJX@GJXAIOU",[[-1,982,"的"]],[983,983],[982,982]]],[1570196332392,["GJX@GJXAIOU",[[1,982,"最后一个数组的元素个数时候，"]],[982,982],[996,996]]],[1570196389224,["GJX@GJXAIOU",[[1,996,"或者反之情况，时间复杂度都是：$$"]],[996,996],[1013,1013]]],[1570196391854,["GJX@GJXAIOU",[[1,1012,"O()"]],[1012,1012],[1015,1015]]],[1570196399107,["GJX@GJXAIOU",[[1,1014,"{N}^{2}"]],[1014,1014],[1021,1021]]],[1570196507631,["GJX@GJXAIOU",[[1,1023,"\n  - bi"]],[1023,1023],[1030,1030]]],[1570196508311,["GJX@GJXAIOU",[[-1,1028,"bi"]],[1030,1030],[1028,1028]]],[1570196514177,["GJX@GJXAIOU",[[1,1028,"如果数据两天"]],[1028,1028],[1034,1034]]],[1570196515094,["GJX@GJXAIOU",[[-1,1032,"两天"]],[1034,1034],[1032,1032]]],[1570196527505,["GJX@GJXAIOU",[[1,1032,"状态较好，即"]],[1032,1032],[1038,1038]]],[1570196539670,["GJX@GJXAIOU",[[1,1038,"大于和小于差不多"]],[1038,1038],[1046,1046]]],[1570196614143,["GJX@GJXAIOU",[[1,1046,"的情况下，时间复杂度为：$$"]],[1046,1046],[1060,1060]]],[1570196616450,["GJX@GJXAIOU",[[1,1059,"T()"]],[1059,1059],[1062,1062]]],[1570196617873,["GJX@GJXAIOU",[[1,1061,"N"]],[1061,1061],[1062,1062]]],[1570196626266,["GJX@GJXAIOU",[[1,1063," = 2T()"]],[1063,1063],[1070,1070]]],[1570196637582,["GJX@GJXAIOU",[[1,1069,"\\trac{zN"]],[1069,1069],[1077,1077]]],[1570196639777,["GJX@GJXAIOU",[[-1,1075,"zN"]],[1077,1077],[1075,1075]]],[1570196645624,["GJX@GJXAIOU",[[1,1075,"N}{2}"]],[1075,1075],[1080,1080]]],[1570196658231,["GJX@GJXAIOU",[[-1,1070,"t"]],[1071,1071],[1070,1070]]],[1570196658503,["GJX@GJXAIOU",[[1,1070,"f"]],[1070,1070],[1071,1071]]],[1570196669697,["GJX@GJXAIOU",[[1,1080," + ="]],[1080,1080],[1084,1084]]],[1570196672535,["GJX@GJXAIOU",[[-1,1080," + ="]],[1084,1084],[1080,1080]]],[1570196677345,["GJX@GJXAIOU",[[1,1081," + O()"]],[1081,1081],[1087,1087]]],[1570196678745,["GJX@GJXAIOU",[[1,1086,"N"]],[1086,1086],[1087,1087]]],[1570196695336,["GJX@GJXAIOU",[[1,1088," = O()"]],[1088,1088],[1094,1094]]],[1570196698027,["GJX@GJXAIOU",[[1,1093,"N # "]],[1093,1093],[1097,1097]]],[1570196699528,["GJX@GJXAIOU",[[-1,1094," # "]],[1097,1097],[1094,1094]]],[1570196701345,["GJX@GJXAIOU",[[1,1094,"* "]],[1094,1094],[1096,1096]]],[1570196703312,["GJX@GJXAIOU",[[1,1094," "]],[1094,1094],[1095,1095]]],[1570196710451,["GJX@GJXAIOU",[[1,1097,"log_{"]],[1097,1097],[1102,1102]]],[1570196720074,["GJX@GJXAIOU",[[1,1102,"2}^{N}"]],[1102,1102],[1108,1108]]],[1570196729513,["GJX@GJXAIOU",[[1,1110,"\n  - "]],[1110,1110],[1115,1115]]],[1570196729664,["GJX@GJXAIOU",[[-1,1111,"  - "],[1,1115,"\n\n"]],[1115,1115],[1112,1112]]],[1570196733367,["GJX@GJXAIOU",[[1,1112,"### gai"]],[1112,1112],[1119,1119]]],[1570196734153,["GJX@GJXAIOU",[[-1,1116,"gai"]],[1119,1119],[1116,1116]]],[1570196736129,["GJX@GJXAIOU",[[1,1116,"随机"]],[1116,1116],[1118,1118]]],[1570196814892,["GJX@GJXAIOU",[[1,776,"：使用荷兰国旗思想"]],[776,776],[785,785]]],[1570196830027,["GJX@GJXAIOU",[[1,1127,"快速排序"]],[1127,1127],[1131,1131]]],[1570196830745,["GJX@GJXAIOU",[[1,1132,"\n"]],[1131,1131],[1132,1132]]],[1570196895834,["GJX@GJXAIOU",[[-1,1132,"\n"],[1,1133,"同伙"]],[1132,1132],[1134,1134]]],[1570196896470,["GJX@GJXAIOU",[[-1,1133,"伙"]],[1134,1134],[1133,1133]]],[1570196896590,["GJX@GJXAIOU",[[-1,1132,"同"],[1,1133,"\n"]],[1133,1133],[1132,1132]]],[1570196900731,["GJX@GJXAIOU",[[-1,1132,"\n"],[1,1133,"通过"]],[1132,1132],[1134,1134]]],[1570196928978,["GJX@GJXAIOU",[[1,1134,"随机选一个数和最后一个数进行互换，是的"]],[1134,1134],[1153,1153]]],[1570196929702,["GJX@GJXAIOU",[[-1,1151,"是的"]],[1153,1153],[1151,1151]]],[1570196942825,["GJX@GJXAIOU",[[1,1151,"使得每次划分标准都在改变；"]],[1151,1151],[1164,1164]]],[1570196953858,["GJX@GJXAIOU",[[1,1164,"\n\n"]],[1164,1164],[1165,1165]]],[1570196955466,["GJX@GJXAIOU",[[-1,1165,"\n"],[1,1166,"根据"]],[1165,1165],[1167,1167]]],[1570196958769,["GJX@GJXAIOU",[[1,1167,"最记性"]],[1167,1167],[1170,1170]]],[1570196972584,["GJX@GJXAIOU",[[1,1120,"  - \n"]],[1119,1119],[1124,1124]]],[1570196973137,["GJX@GJXAIOU",[[-1,1120,"  - "]],[1124,1124],[1121,1121]]],[1570196976747,["GJX@GJXAIOU",[[1,1121,"进店"]],[1121,1121],[1123,1123]]],[1570196977918,["GJX@GJXAIOU",[[-1,1121,"进店"]],[1123,1123],[1121,1121]]],[1570196978513,["GJX@GJXAIOU",[[1,1122,"\n"]],[1121,1121],[1122,1122]]],[1570196999127,["GJX@GJXAIOU",[[1,1121,"经典快排的空间复杂度为：$$"]],[1121,1121],[1135,1135]]],[1570197001831,["GJX@GJXAIOU",[[1,1134,"O()"]],[1134,1134],[1137,1137]]],[1570197003191,["GJX@GJXAIOU",[[1,1136,"N"]],[1136,1136],[1137,1137]]],[1570197012734,["GJX@GJXAIOU",[[-1,1187,"最记性"]],[1190,1190],[1187,1187]]],[1570197035234,["GJX@GJXAIOU",[[1,1187,"随机性，随机快速排序的时间复杂度是：$$"]],[1187,1187],[1207,1207]]],[1570197039142,["GJX@GJXAIOU",[[1,1206,"O()"]],[1206,1206],[1209,1209]]],[1570197043690,["GJX@GJXAIOU",[[1,1208,"n"]],[1208,1208],[1209,1209]]],[1570197044449,["GJX@GJXAIOU",[[-1,1208,"n"]],[1209,1209],[1208,1208]]],[1570197047095,["GJX@GJXAIOU",[[1,1208,"N * lo"]],[1208,1208],[1214,1214]]],[1570197047567,["GJX@GJXAIOU",[[-1,1212,"lo"]],[1214,1214],[1212,1212]]],[1570197059976,["GJX@GJXAIOU",[[1,1212,"\\log_{2}^{N}"]],[1212,1212],[1224,1224]]],[1570197064062,["GJX@GJXAIOU",[[-1,1225,"$"]],[1226,1226],[1225,1225]]],[1570197066906,["GJX@GJXAIOU",[[1,1225,"$,"]],[1225,1225],[1227,1227]]],[1570197067335,["GJX@GJXAIOU",[[-1,1226,","]],[1227,1227],[1226,1226]]],[1570197067848,["GJX@GJXAIOU",[[1,1226,"，"]],[1226,1226],[1227,1227]]],[1570197081505,["GJX@GJXAIOU",[[1,1227,"同时需要额外"]],[1227,1227],[1233,1233]]],[1570197087070,["GJX@GJXAIOU",[[-1,1231,"额外"]],[1233,1233],[1231,1231]]],[1570197093950,["GJX@GJXAIOU",[[1,1231,"空间复杂度为：$$"]],[1231,1231],[1240,1240]]],[1570197097815,["GJX@GJXAIOU",[[1,1239,"O()"]],[1239,1239],[1242,1242]]],[1570197100352,["GJX@GJXAIOU",[[1,1241,"log"]],[1241,1241],[1244,1244]]],[1570197102982,["GJX@GJXAIOU",[[-1,1241,"log"]],[1244,1244],[1241,1241]]],[1570197115552,["GJX@GJXAIOU",[[1,1241,"\\log_{2}^{N}"]],[1241,1241],[1253,1253]]],[1570197128374,["GJX@GJXAIOU",[[1,1255,"，这里的额外控制"]],[1255,1255],[1263,1263]]],[1570197129055,["GJX@GJXAIOU",[[-1,1261,"控制"]],[1263,1263],[1261,1261]]],[1570197131456,["GJX@GJXAIOU",[[1,1261,"空间"]],[1261,1261],[1263,1263]]],[1570197152939,["GJX@GJXAIOU",[[1,1263,"主要用于记录每次划分区域的断点；"]],[1263,1263],[1279,1279]]],[1570197158896,["GJX@GJXAIOU",[[1,1279,"\n\n"]],[1279,1279],[1280,1280]]],[1570197159031,["GJX@GJXAIOU",[[1,1281,"\n"]],[1280,1280],[1281,1281]]],[1570197159159,["GJX@GJXAIOU",[[1,1282,"\n"]],[1281,1281],[1282,1282]]],[1570197159273,["GJX@GJXAIOU",[[1,1283,"\n"]],[1282,1282],[1283,1283]]],[1570197159392,["GJX@GJXAIOU",[[1,1284,"\n"]],[1283,1283],[1284,1284]]],[1570197159520,["GJX@GJXAIOU",[[1,1285,"\n"]],[1284,1284],[1285,1285]]],[1570197164054,["GJX@GJXAIOU",[[1,1285,"## 堆排序"]],[1285,1285],[1291,1291]]],[1570197164424,["GJX@GJXAIOU",[[1,1292,"\n"]],[1291,1291],[1292,1292]]],[1570197164553,["GJX@GJXAIOU",[[1,1293,"\n"]],[1292,1292],[1293,1293]]],[1570197181545,["GJX@GJXAIOU",[[1,1293,"### 堆："]],[1293,1293],[1299,1299]]],[1570197182025,["GJX@GJXAIOU",[[1,1300,"\n"]],[1299,1299],[1300,1300]]],[1570197182419,["GJX@GJXAIOU",[[-1,1300,"\n"]],[1300,1300],[1299,1299]]],[1570197182793,["GJX@GJXAIOU",[[-1,1298,"："]],[1299,1299],[1298,1298]]],[1570197183192,["GJX@GJXAIOU",[[1,1299,"\n"]],[1298,1298],[1299,1299]]],[1570197184540,["GJX@GJXAIOU",[[-1,1299,"\n"],[1,1300,"对"]],[1299,1299],[1300,1300]]],[1570197185024,["GJX@GJXAIOU",[[-1,1299,"对"],[1,1300,"\n"]],[1300,1300],[1299,1299]]],[1570197186485,["GJX@GJXAIOU",[[-1,1299,"\n"],[1,1300,"堆"]],[1299,1299],[1300,1300]]],[1570197191643,["GJX@GJXAIOU",[[1,1300,"是一个完全二叉树"]],[1300,1300],[1308,1308]]],[1570197193656,["GJX@GJXAIOU",[[1,1308,"\n\n"]],[1308,1308],[1309,1309]]],[1570197194859,["GJX@GJXAIOU",[[1,1310,"\n"]],[1309,1309],[1310,1310]]],[1570197195833,["GJX@GJXAIOU",[[-1,1310,"\n"],[1,1311,"*"]],[1310,1310],[1311,1311]]],[1570197195985,["GJX@GJXAIOU",[[1,1311,"***"]],[1311,1311],[1312,1312]]],[1570197198875,["GJX@GJXAIOU",[[1,1312,"完全二叉树"]],[1312,1312],[1317,1317]]],[1570197200778,["GJX@GJXAIOU",[[1,1319,"："]],[1319,1319],[1320,1320]]],[1570197264185,["GJX@GJXAIOU",[[1,1308,"，可以采用数组进行实现；"]],[1308,1308],[1320,1320]]],[1570197292034,["GJX@GJXAIOU",[[1,1332,"二叉树中除了叶子结点"]],[1332,1332],[1342,1342]]],[1570197457033,["GJX@GJXAIOU",[[-1,1332,"二叉树中除了叶子结点"]],[1332,1342],[1332,1332]]],[1570197463075,["GJX@GJXAIOU",[[1,1332,"对一棵具有 N"]],[1332,1332],[1339,1339]]],[1570197464375,["GJX@GJXAIOU",[[-1,1338,"N"]],[1339,1339],[1338,1338]]],[1570197465617,["GJX@GJXAIOU",[[1,1338,"n ge"]],[1338,1338],[1342,1342]]],[1570197466272,["GJX@GJXAIOU",[[-1,1340,"ge"]],[1342,1342],[1340,1340]]],[1570197487257,["GJX@GJXAIOU",[[1,1340,"个节点的二叉树按照层序进行编号，如果编号 i （）"]],[1340,1340],[1365,1365]]],[1570197490424,["GJX@GJXAIOU",[[1,1364,"1《"]],[1364,1364],[1366,1366]]],[1570197491202,["GJX@GJXAIOU",[[-1,1365,"《"]],[1366,1366],[1365,1365]]],[1570197495482,["GJX@GJXAIOU",[[1,1365,"<=i<<"]],[1365,1365],[1370,1370]]],[1570197496023,["GJX@GJXAIOU",[[-1,1369,"<"]],[1370,1370],[1369,1369]]],[1570197498784,["GJX@GJXAIOU",[[1,1369,"=n"]],[1369,1369],[1371,1371]]],[1570197512222,["GJX@GJXAIOU",[[1,1372,"的结点与同样胜读"]],[1372,1372],[1380,1380]]],[1570197512751,["GJX@GJXAIOU",[[-1,1378,"胜读"]],[1380,1380],[1378,1378]]],[1570197532657,["GJX@GJXAIOU",[[1,1378,"深度的满二叉树中编号为 i 的结点位置完全想听"]],[1378,1378],[1401,1401]]],[1570197533374,["GJX@GJXAIOU",[[-1,1399,"想听"]],[1401,1401],[1399,1399]]],[1570197536817,["GJX@GJXAIOU",[[1,1399,"相同；"]],[1399,1399],[1402,1402]]],[1570197538248,["GJX@GJXAIOU",[[1,1402,"\n\n"]],[1402,1402],[1403,1403]]],[1570197539498,["GJX@GJXAIOU",[[-1,1403,"\n"],[1,1404,"*"]],[1403,1403],[1404,1404]]],[1570197539642,["GJX@GJXAIOU",[[1,1404,"***"]],[1404,1404],[1405,1405]]],[1570197544505,["GJX@GJXAIOU",[[1,1405,"满二叉树"]],[1405,1405],[1409,1409]]],[1570197551339,["GJX@GJXAIOU",[[1,1411,"：所有的"]],[1411,1411],[1415,1415]]],[1570197592705,["GJX@GJXAIOU",[[1,1415,"分支结点都存在左子树和右子树，且所有的叶子都在同一层；"]],[1415,1415],[1442,1442]]],[1570197613648,["GJX@GJXAIOU",[[1,1322,"\n"]],[1320,1320],[1321,1321]]],[1570197618650,["GJX@GJXAIOU",[[1,1321,"对于满二叉树"]],[1321,1321],[1327,1327]]],[1570197620895,["GJX@GJXAIOU",[[-1,1321,"对于满二叉树"]],[1327,1327],[1321,1321]]],[1570197624834,["GJX@GJXAIOU",[[1,1321,"对于完全儿茶素"]],[1321,1321],[1328,1328]]],[1570197625734,["GJX@GJXAIOU",[[-1,1325,"儿茶素"]],[1328,1328],[1325,1325]]],[1570197635584,["GJX@GJXAIOU",[[1,1325,"二叉树，节点 i"]],[1325,1325],[1333,1333]]],[1570197636399,["GJX@GJXAIOU",[[-1,1329,"节点 i"]],[1333,1333],[1329,1329]]],[1570197639240,["GJX@GJXAIOU",[[1,1329,"节点 i"]],[1329,1329],[1333,1333]]],[1570197640951,["GJX@GJXAIOU",[[-1,1329,"节点 i"]],[1333,1333],[1329,1329]]],[1570197641858,["GJX@GJXAIOU",[[1,1329,"Jieian"]],[1329,1329],[1335,1335]]],[1570197643014,["GJX@GJXAIOU",[[-1,1329,"Jieian"]],[1335,1335],[1329,1329]]],[1570197653691,["GJX@GJXAIOU",[[1,1329,"结点 i 的左孩子主要"]],[1329,1329],[1340,1340]]],[1570197656449,["GJX@GJXAIOU",[[-1,1338,"主要"]],[1340,1340],[1338,1338]]],[1570197657377,["GJX@GJXAIOU",[[1,1338,"需要"]],[1338,1338],[1340,1340]]],[1570197658107,["GJX@GJXAIOU",[[-1,1338,"需要"]],[1340,1340],[1338,1338]]],[1570197664301,["GJX@GJXAIOU",[[1,1338,"序号为：2 I "]],[1338,1338],[1346,1346]]],[1570197665816,["GJX@GJXAIOU",[[-1,1343," I "]],[1346,1346],[1343,1343]]],[1570197670728,["GJX@GJXAIOU",[[1,1343,"i + 1；ji"]],[1343,1343],[1351,1351]]],[1570197671352,["GJX@GJXAIOU",[[-1,1349,"ji"]],[1351,1351],[1349,1349]]],[1570197675076,["GJX@GJXAIOU",[[1,1349,"右孩子需要"]],[1349,1349],[1354,1354]]],[1570197675960,["GJX@GJXAIOU",[[-1,1352,"需要"]],[1354,1354],[1352,1352]]],[1570197687376,["GJX@GJXAIOU",[[1,1352,"序号为：2i + 2;"]],[1352,1352],[1363,1363]]],[1570197688185,["GJX@GJXAIOU",[[-1,1362,";"]],[1363,1363],[1362,1362]]],[1570197688488,["GJX@GJXAIOU",[[1,1362,"；"]],[1362,1362],[1363,1363]]],[1570197751218,["GJX@GJXAIOU",[[1,1363,"父结点的序号为：￥￥"]],[1363,1363],[1373,1373]]],[1570197752265,["GJX@GJXAIOU",[[-1,1371,"￥￥"]],[1373,1373],[1371,1371]]],[1570197753752,["GJX@GJXAIOU",[[1,1371,"$$"]],[1371,1371],[1373,1373]]],[1570197760568,["GJX@GJXAIOU",[[1,1372,"\\fran"]],[1372,1372],[1377,1377]]],[1570197761417,["GJX@GJXAIOU",[[-1,1376,"n"]],[1377,1377],[1376,1376]]],[1570197770160,["GJX@GJXAIOU",[[1,1376,"c{i - 1}{2}"]],[1376,1376],[1387,1387]]],[1570197778322,["GJX@GJXAIOU",[[1,1388,"，"]],[1388,1388],[1389,1389]]],[1570197797142,["GJX@GJXAIOU",[[1,1391,"\n"]],[1389,1389],[1390,1390]]],[1570197800943,["GJX@GJXAIOU",[[1,1392,"\n"]],[1390,1390],[1391,1391]]],[1570197804439,["GJX@GJXAIOU",[[1,1391,"分类："]],[1391,1391],[1394,1394]]],[1570197805681,["GJX@GJXAIOU",[[1,1396,"\n"]],[1394,1394],[1395,1395]]],[1570197838545,["GJX@GJXAIOU",[[1,1395,"- 大根堆：每棵树（）"]],[1395,1395],[1406,1406]]],[1570197845833,["GJX@GJXAIOU",[[1,1405,"包括任意一棵子树"]],[1405,1405],[1413,1413]]],[1570197848947,["GJX@GJXAIOU",[[1,1414,"的"]],[1414,1414],[1415,1415]]],[1570197859537,["GJX@GJXAIOU",[[1,1415,"最大值的都是其头部（）"]],[1415,1415],[1426,1426]]],[1570197870123,["GJX@GJXAIOU",[[1,1425,"父结点"]],[1425,1425],[1428,1428]]],[1570197871640,["GJX@GJXAIOU",[[1,1429,"；"]],[1429,1429],[1430,1430]]],[1570197872159,["GJX@GJXAIOU",[[1,1431,"- \n"]],[1430,1430],[1433,1433]]],[1570197882624,["GJX@GJXAIOU",[[1,1433,"小根堆：每棵树（）"]],[1433,1433],[1442,1442]]],[1570197889898,["GJX@GJXAIOU",[[1,1441,"包括任意一棵子树"]],[1441,1441],[1449,1449]]],[1570197894881,["GJX@GJXAIOU",[[1,1450,"的最小值都是"]],[1450,1450],[1456,1456]]],[1570197899127,["GJX@GJXAIOU",[[-1,1454,"都是"]],[1456,1456],[1454,1454]]],[1570197900433,["GJX@GJXAIOU",[[-1,1418,"的"]],[1419,1419],[1418,1418]]],[1570197907107,["GJX@GJXAIOU",[[1,1453,"都是其头部（）"]],[1453,1453],[1460,1460]]],[1570197910177,["GJX@GJXAIOU",[[1,1459,"父结点"]],[1459,1459],[1462,1462]]],[1570197911537,["GJX@GJXAIOU",[[1,1463,"；"]],[1463,1463],[1464,1464]]],[1570198037023,["GJX@GJXAIOU",[[1,1586,"\n\n"]],[1586,1586],[1587,1587]]],[1570198037169,["GJX@GJXAIOU",[[1,1588,"\n"]],[1587,1587],[1588,1588]]],[1570198041585,["GJX@GJXAIOU",[[-1,1588,"\n"],[1,1589,"#"]],[1588,1588],[1589,1589]]],[1570198043632,["GJX@GJXAIOU",[[-1,1588,"#"],[1,1589,"\n"]],[1589,1589],[1588,1588]]],[1570198054657,["GJX@GJXAIOU",[[1,1588,"### 数组转换为大根堆"]],[1588,1588],[1600,1600]]],[1570198055107,["GJX@GJXAIOU",[[1,1601,"\n"]],[1600,1600],[1601,1601]]],[1570198082425,["GJX@GJXAIOU",[[-1,1601,"\n"],[1,1602,"以"]],[1601,1601],[1602,1602]]],[1570198091656,["GJX@GJXAIOU",[[1,1602,"数组 [2,1,3,6,"]],[1602,1602],[1614,1614]]],[1570198096640,["GJX@GJXAIOU",[[1,1614,"0,4]为例，"]],[1614,1614],[1621,1621]]],[1570198097912,["GJX@GJXAIOU",[[-1,1620,"，"]],[1621,1621],[1620,1620]]],[1570198099057,["GJX@GJXAIOU",[[1,1620,"："]],[1620,1620],[1621,1621]]],[1570198099304,["GJX@GJXAIOU",[[1,1621,"\n\n"]],[1621,1621],[1622,1622]]],[1570198103555,["GJX@GJXAIOU",[[-1,1622,"\n"],[1,1623,"首先"]],[1622,1622],[1624,1624]]],[1570198129048,["GJX@GJXAIOU",[[1,1624,"取出第一元素2"]],[1624,1624],[1631,1631]]],[1570198129073,["GJX@GJXAIOU",[[1,1630," "]],[1631,1631],[1632,1632]]],[1570198145945,["GJX@GJXAIOU",[[1,1632,"，然后取出第二个元素 1，该元素比2"]],[1632,1632],[1650,1650]]],[1570198145971,["GJX@GJXAIOU",[[1,1649," "]],[1650,1650],[1651,1651]]],[1570198147794,["GJX@GJXAIOU",[[1,1651," 小，"]],[1651,1651],[1654,1654]]],[1570198174473,["GJX@GJXAIOU",[[1,1654,"放在左孩子位置，数组元素为：[2,1],"]],[1654,1654],[1674,1674]]],[1570198175735,["GJX@GJXAIOU",[[-1,1673,","]],[1674,1674],[1673,1673]]],[1570198176273,["GJX@GJXAIOU",[[1,1673,"，"]],[1673,1673],[1674,1674]]],[1570198176841,["GJX@GJXAIOU",[[-1,1673,"，"]],[1674,1674],[1673,1673]]],[1570198178961,["GJX@GJXAIOU",[[1,1673,"；ranhou"]],[1673,1673],[1680,1680]]],[1570198180433,["GJX@GJXAIOU",[[-1,1674,"ranhou"]],[1680,1680],[1674,1674]]],[1570198192090,["GJX@GJXAIOU",[[1,1674,"然后取出第三个元素 3，该元素比3"]],[1674,1674],[1691,1691]]],[1570198192114,["GJX@GJXAIOU",[[1,1690," "]],[1691,1691],[1692,1692]]],[1570198192623,["GJX@GJXAIOU",[[-1,1691,"3"]],[1692,1692],[1691,1691]]],[1570198194361,["GJX@GJXAIOU",[[1,1691,"2大"]],[1691,1691],[1693,1693]]],[1570198194389,["GJX@GJXAIOU",[[1,1692," "]],[1693,1693],[1694,1694]]],[1570198198888,["GJX@GJXAIOU",[[-1,1686,"该元素比 2 大"]],[1694,1694],[1686,1686]]],[1570198205714,["GJX@GJXAIOU",[[1,1686,"计算该元素的父结点："]],[1686,1686],[1696,1696]]],[1570198212608,["GJX@GJXAIOU",[[1,1696,"$$"]],[1696,1696],[1698,1698]]],[1570198216026,["GJX@GJXAIOU",[[1,1697,"\\fran"]],[1697,1697],[1702,1702]]],[1570198216407,["GJX@GJXAIOU",[[-1,1701,"n"]],[1702,1702],[1701,1701]]],[1570198228521,["GJX@GJXAIOU",[[1,1701,"c{3 - 2"]],[1701,1701],[1708,1708]]],[1570198229433,["GJX@GJXAIOU",[[-1,1707,"2"]],[1708,1708],[1707,1707]]],[1570198237601,["GJX@GJXAIOU",[[1,1707,"1}{2} = 0"]],[1707,1707],[1716,1716]]],[1570198248185,["GJX@GJXAIOU",[[-1,1703,"3"]],[1704,1704],[1703,1703]]],[1570198248584,["GJX@GJXAIOU",[[1,1703,"2"]],[1703,1703],[1704,1704]]],[1570198259338,["GJX@GJXAIOU",[[1,1717,","]],[1717,1717],[1718,1718]]],[1570198261370,["GJX@GJXAIOU",[[-1,1717,","]],[1718,1718],[1717,1717]]],[1570198271081,["GJX@GJXAIOU",[[1,1717,"，则与 0 "]],[1717,1717],[1723,1723]]],[1570198295392,["GJX@GJXAIOU",[[1,1723,"位置元素 2 进行比较，发现 3 比较大，则在数组中将 3 和2"]],[1723,1723],[1755,1755]]],[1570198295418,["GJX@GJXAIOU",[[1,1754," "]],[1755,1755],[1756,1756]]],[1570198296738,["GJX@GJXAIOU",[[1,1756," 连个"]],[1756,1756],[1759,1759]]],[1570198297440,["GJX@GJXAIOU",[[-1,1757,"连个"]],[1759,1759],[1757,1757]]],[1570198298828,["GJX@GJXAIOU",[[1,1757,"连个"]],[1757,1757],[1759,1759]]],[1570198299703,["GJX@GJXAIOU",[[-1,1757,"连个"]],[1759,1759],[1757,1757]]],[1570198329129,["GJX@GJXAIOU",[[1,1757,"两个元素互换，则数组变为：[3,1,2];ran"]],[1757,1757],[1781,1781]]],[1570198330880,["GJX@GJXAIOU",[[-1,1777,";ran"]],[1781,1781],[1777,1777]]],[1570198331187,["GJX@GJXAIOU",[[1,1777,";"]],[1777,1777],[1778,1778]]],[1570198331655,["GJX@GJXAIOU",[[-1,1777,";"]],[1778,1778],[1777,1777]]],[1570198332114,["GJX@GJXAIOU",[[1,1777,"；‘"]],[1777,1777],[1779,1779]]],[1570198332735,["GJX@GJXAIOU",[[-1,1778,"‘"]],[1779,1779],[1778,1778]]],[1570198334256,["GJX@GJXAIOU",[[1,1778,"r"]],[1778,1778],[1779,1779]]],[1570198334654,["GJX@GJXAIOU",[[-1,1778,"r"]],[1779,1779],[1778,1778]]],[1570198344242,["GJX@GJXAIOU",[[1,1778,"然后取出第四个元素 6，就散"]],[1778,1778],[1792,1792]]],[1570198345800,["GJX@GJXAIOU",[[-1,1790,"就散"]],[1792,1792],[1790,1790]]],[1570198360732,["GJX@GJXAIOU",[[1,1790,"计算父结点下标为：$$"]],[1790,1790],[1801,1801]]],[1570198363171,["GJX@GJXAIOU",[[1,1800,"\\fran"]],[1800,1800],[1805,1805]]],[1570198363513,["GJX@GJXAIOU",[[-1,1804,"n"]],[1805,1805],[1804,1804]]],[1570198371890,["GJX@GJXAIOU",[[1,1804,"c{3-"]],[1804,1804],[1808,1808]]],[1570198373500,["GJX@GJXAIOU",[[1,1807," "]],[1807,1807],[1808,1808]]],[1570198375329,["GJX@GJXAIOU",[[1,1809,"  1"]],[1809,1809],[1812,1812]]],[1570198378627,["GJX@GJXAIOU",[[-1,1809,"  1"]],[1812,1812],[1809,1809]]],[1570198379802,["GJX@GJXAIOU",[[1,1809,"}"]],[1809,1809],[1810,1810]]],[1570198381844,["GJX@GJXAIOU",[[1,1809," 1"]],[1809,1809],[1811,1811]]],[1570198387372,["GJX@GJXAIOU",[[1,1812,"{2} = 1"]],[1812,1812],[1819,1819]]],[1570198389593,["GJX@GJXAIOU",[[1,1820,","]],[1820,1820],[1821,1821]]],[1570198390520,["GJX@GJXAIOU",[[-1,1820,","]],[1821,1821],[1820,1820]]],[1570198391075,["GJX@GJXAIOU",[[1,1820,"，"]],[1820,1820],[1821,1821]]],[1570198404626,["GJX@GJXAIOU",[[1,1821,"则与 1 位置的元素1"]],[1821,1821],[1832,1832]]],[1570198404653,["GJX@GJXAIOU",[[1,1831," "]],[1832,1832],[1833,1833]]],[1570198406018,["GJX@GJXAIOU",[[1,1833,"进行"]],[1833,1833],[1835,1835]]],[1570198406047,["GJX@GJXAIOU",[[1,1833," "]],[1835,1835],[1836,1836]]],[1570198409577,["GJX@GJXAIOU",[[1,1836,"比较，发现6"]],[1836,1836],[1842,1842]]],[1570198409605,["GJX@GJXAIOU",[[1,1841," "]],[1842,1842],[1843,1843]]],[1570198412885,["GJX@GJXAIOU",[[1,1843,"比较"]],[1843,1843],[1845,1845]]],[1570198412910,["GJX@GJXAIOU",[[1,1843," "]],[1845,1845],[1846,1846]]],[1570198423403,["GJX@GJXAIOU",[[1,1846,"大，则将元素 1 和元素9"]],[1846,1846],[1859,1859]]],[1570198423426,["GJX@GJXAIOU",[[1,1858," "]],[1859,1859],[1860,1860]]],[1570198423800,["GJX@GJXAIOU",[[-1,1859,"9"]],[1860,1860],[1859,1859]]],[1570198429579,["GJX@GJXAIOU",[[1,1859,"6互换"]],[1859,1859],[1862,1862]]],[1570198429606,["GJX@GJXAIOU",[[1,1860," "]],[1862,1862],[1863,1863]]],[1570198443064,["GJX@GJXAIOU",[[1,1863,"，得到[3,6,2,1],"]],[1863,1863],[1876,1876]]],[1570198443951,["GJX@GJXAIOU",[[-1,1875,","]],[1876,1876],[1875,1875]]],[1570198448076,["GJX@GJXAIOU",[[1,1875,"，然后在"]],[1875,1875],[1879,1879]]],[1570198448911,["GJX@GJXAIOU",[[-1,1878,"在"]],[1879,1879],[1878,1878]]],[1570198451425,["GJX@GJXAIOU",[[1,1878,"再比较"]],[1878,1878],[1881,1881]]],[1570198453500,["GJX@GJXAIOU",[[1,1881," 元素怒"]],[1881,1881],[1885,1885]]],[1570198454600,["GJX@GJXAIOU",[[-1,1881," 元素怒"]],[1885,1885],[1881,1881]]],[1570198472155,["GJX@GJXAIOU",[[1,1881,"元素 6 和其父结点：$$"]],[1881,1881],[1894,1894]]],[1570198487473,["GJX@GJXAIOU",[[1,1893,"\\frac{1}{2}"]],[1893,1893],[1904,1904]]],[1570198490826,["GJX@GJXAIOU",[[1,1900," - 1"]],[1900,1900],[1904,1904]]],[1570198494144,["GJX@GJXAIOU",[[1,1908," = 0"]],[1908,1908],[1912,1912]]],[1570198511721,["GJX@GJXAIOU",[[1,1913,"，比较"]],[1913,1913],[1916,1916]]],[1570198516629,["GJX@GJXAIOU",[[1,1916,"得出6"]],[1916,1916],[1919,1919]]],[1570198516655,["GJX@GJXAIOU",[[1,1918," "]],[1919,1919],[1920,1920]]],[1570198521569,["GJX@GJXAIOU",[[1,1920," 比 3大，"]],[1920,1920],[1926,1926]]],[1570198521596,["GJX@GJXAIOU",[[1,1924," "]],[1926,1926],[1927,1927]]],[1570198533705,["GJX@GJXAIOU",[[1,1927,"然后再换，最后得到数组为；"]],[1927,1927],[1940,1940]]],[1570198534513,["GJX@GJXAIOU",[[-1,1939,"；"]],[1940,1940],[1939,1939]]],[1570198554397,["GJX@GJXAIOU",[[1,1939,"：[6,3,2,1]，身下"]],[1939,1939],[1952,1952]]],[1570198554952,["GJX@GJXAIOU",[[-1,1950,"身下"]],[1952,1952],[1950,1950]]],[1570198561002,["GJX@GJXAIOU",[[1,1950,"剩下元素依次雷翠"]],[1950,1950],[1958,1958]]],[1570198561592,["GJX@GJXAIOU",[[-1,1956,"雷翠"]],[1958,1958],[1956,1956]]],[1570198565768,["GJX@GJXAIOU",[[1,1956,"类推......"]],[1956,1956],[1964,1964]]],[1570198566265,["GJX@GJXAIOU",[[1,1964,"\n\n"]],[1964,1964],[1965,1965]]],[1570198580545,["GJX@GJXAIOU",[[1,1966,"\n"]],[1965,1965],[1966,1966]]],[1570198583177,["GJX@GJXAIOU",[[-1,1966,"\n"],[1,1967,"m"]],[1966,1966],[1967,1967]]],[1570198583424,["GJX@GJXAIOU",[[1,1967,"ei"]],[1967,1967],[1969,1969]]],[1570198583928,["GJX@GJXAIOU",[[-1,1967,"ei"]],[1969,1969],[1967,1967]]],[1570198584064,["GJX@GJXAIOU",[[-1,1966,"m"],[1,1967,"\n"]],[1967,1967],[1966,1966]]],[1570198587018,["GJX@GJXAIOU",[[-1,1966,"\n"],[1,1967,"每"]],[1966,1966],[1967,1967]]],[1570198606651,["GJX@GJXAIOU",[[1,1967,"加入一个节点其最多比较的次数和以及"]],[1967,1967],[1984,1984]]],[1570198607214,["GJX@GJXAIOU",[[-1,1982,"以及"]],[1984,1984],[1982,1982]]],[1570198620209,["GJX@GJXAIOU",[[1,1982,"已经形成的二叉树高度有关（）"]],[1982,1982],[1996,1996]]],[1570198631074,["GJX@GJXAIOU",[[1,1995,"因为每次只和其父结点"]],[1995,1995],[2005,2005]]],[1570198632083,["GJX@GJXAIOU",[[1,2005,"比较"]],[2005,2005],[2007,2007]]],[1570198655144,["GJX@GJXAIOU",[[1,2008,"，因此最多时间复杂度为：$$"]],[2008,2008],[2022,2022]]],[1570198659568,["GJX@GJXAIOU",[[1,2021,"O()"]],[2021,2021],[2024,2024]]],[1570198661602,["GJX@GJXAIOU",[[1,2023,"log"]],[2023,2023],[2026,2026]]],[1570198664680,["GJX@GJXAIOU",[[-1,2023,"log"]],[2026,2026],[2023,2023]]],[1570198678913,["GJX@GJXAIOU",[[1,2023,"log_{2}^{N}"]],[2023,2023],[2034,2034]]],[1570198686423,["GJX@GJXAIOU",[[1,2036,","]],[2036,2036],[2037,2037]]],[1570198687248,["GJX@GJXAIOU",[[-1,2036,","]],[2037,2037],[2036,2036]]],[1570198689564,["GJX@GJXAIOU",[[1,2036,"，所有"]],[2036,2036],[2039,2039]]],[1570198700748,["GJX@GJXAIOU",[[1,2039,"整个转换过程时间辅助"]],[2039,2039],[2049,2049]]],[1570198701560,["GJX@GJXAIOU",[[-1,2047,"辅助"]],[2049,2049],[2047,2047]]],[1570198710682,["GJX@GJXAIOU",[[1,2047,"复杂度为：$$"]],[2047,2047],[2054,2054]]],[1570198718224,["GJX@GJXAIOU",[[1,2053,"log_{2}"]],[2053,2053],[2060,2060]]],[1570198719092,["GJX@GJXAIOU",[[1,2061,"$"]],[2060,2060],[2061,2061]]],[1570198719535,["GJX@GJXAIOU",[[-1,2061,"$"]],[2061,2061],[2060,2060]]],[1570198739128,["GJX@GJXAIOU",[[1,2060,"^{1} + log_{2}^{1} ="]],[2060,2060],[2080,2080]]],[1570198739903,["GJX@GJXAIOU",[[-1,2079,"="]],[2080,2080],[2079,2079]]],[1570198746409,["GJX@GJXAIOU",[[1,2079," + log_{2}^{1} +....."]],[2079,2079],[2100,2100]]],[1570198753735,["GJX@GJXAIOU",[[1,2100,"+log_{2}^{1}"]],[2100,2100],[2112,2112]]],[1570198755305,["GJX@GJXAIOU",[[1,2100," "]],[2100,2100],[2101,2101]]],[1570198756921,["GJX@GJXAIOU",[[1,2102," "]],[2102,2102],[2103,2103]]],[1570198758866,["GJX@GJXAIOU",[[1,2095," "]],[2095,2095],[2096,2096]]],[1570198761536,["GJX@GJXAIOU",[[-1,2076,"1"]],[2077,2077],[2076,2076]]],[1570198762026,["GJX@GJXAIOU",[[1,2076,"2"]],[2076,2076],[2077,2077]]],[1570198768530,["GJX@GJXAIOU",[[-1,2079," log_{2}^{1} + "]],[2079,2093],[2078,2078]]],[1570198770905,["GJX@GJXAIOU",[[-1,2098,"1"]],[2099,2099],[2098,2098]]],[1570198771403,["GJX@GJXAIOU",[[1,2098,"N"]],[2098,2098],[2099,2099]]],[1570198775312,["GJX@GJXAIOU",[[1,2100," = O()"]],[2100,2100],[2106,2106]]],[1570198776576,["GJX@GJXAIOU",[[1,2105,"N"]],[2105,2105],[2106,2106]]],[1570198888696,["GJX@GJXAIOU",[[1,2108,"\n\n"]],[2108,2108],[2109,2109]]],[1570198888840,["GJX@GJXAIOU",[[1,2110,"\n"]],[2109,2109],[2110,2110]]],[1570198888940,["GJX@GJXAIOU",[[1,2111,"\n"]],[2110,2110],[2111,2111]]],[1570198889073,["GJX@GJXAIOU",[[1,2112,"\n"]],[2111,2111],[2112,2112]]],[1570198889240,["GJX@GJXAIOU",[[1,2113,"\n"]],[2112,2112],[2113,2113]]],[1570198890584,["GJX@GJXAIOU",[[-1,2113,"\n"]],[2113,2113],[2112,2112]]],[1570198890726,["GJX@GJXAIOU",[[-1,2112,"\n"]],[2112,2112],[2111,2111]]],[1570198892128,["GJX@GJXAIOU",[[-1,2111,"\n"],[1,2112,"*"]],[2111,2111],[2112,2112]]],[1570198892285,["GJX@GJXAIOU",[[1,2112,"***"]],[2112,2112],[2113,2113]]],[1570198893225,["GJX@GJXAIOU",[[1,2113,"tim"]],[2113,2113],[2116,2116]]],[1570198893745,["GJX@GJXAIOU",[[-1,2113,"tim"]],[2116,2116],[2113,2113]]],[1570198895267,["GJX@GJXAIOU",[[1,2113,"题目"]],[2113,2113],[2115,2115]]],[1570198897455,["GJX@GJXAIOU",[[1,2117,"\n\n"]],[2117,2117],[2118,2118]]],[1570198902157,["GJX@GJXAIOU",[[-1,2118,"\n"],[1,2119,"吐泡泡"]],[2118,2118],[2121,2121]]],[1570198910061,["GJX@GJXAIOU",[[1,2121,"：一个 XXX 会不听"]],[2121,2121],[2132,2132]]],[1570198910680,["GJX@GJXAIOU",[[-1,2131,"听"]],[2132,2132],[2131,2131]]],[1570198914139,["GJX@GJXAIOU",[[1,2131,"停的"]],[2131,2131],[2133,2133]]],[1570198985288,["GJX@GJXAIOU",[[1,2133,"吐出数字，求任意时刻的已经吐出的所有元素的中位值"]],[2133,2133],[2157,2157]]],[1570198985799,["GJX@GJXAIOU",[[-1,2156,"值"]],[2157,2157],[2156,2156]]],[1570198987537,["GJX@GJXAIOU",[[1,2156,"数；"]],[2156,2156],[2158,2158]]],[1570198991499,["GJX@GJXAIOU",[[1,2158,"\n\n"]],[2158,2158],[2159,2159]]],[1570199001481,["GJX@GJXAIOU",[[1,2160,"\n"]],[2159,2159],[2160,2160]]],[1570199002554,["GJX@GJXAIOU",[[-1,2160,"\n"],[1,2161,"这里"]],[2160,2160],[2162,2162]]],[1570199009882,["GJX@GJXAIOU",[[1,2162,"需要同时"]],[2162,2162],[2166,2166]]],[1570199011386,["GJX@GJXAIOU",[[-1,2161,"里需要同时"]],[2166,2166],[2161,2161]]],[1570199011487,["GJX@GJXAIOU",[[-1,2160,"这"],[1,2161,"\n"]],[2161,2161],[2160,2160]]],[1570199012387,["GJX@GJXAIOU",[[-1,2160,"\n"],[1,2161,"*"]],[2160,2160],[2161,2161]]],[1570199012511,["GJX@GJXAIOU",[[1,2161,"***"]],[2161,2161],[2162,2162]]],[1570199014865,["GJX@GJXAIOU",[[1,2162,"解答："]],[2162,2162],[2165,2165]]],[1570199016320,["GJX@GJXAIOU",[[1,2167,"\n\n"]],[2167,2167],[2168,2168]]],[1570199017373,["GJX@GJXAIOU",[[-1,2168,"\n"],[1,2169,"这里"]],[2168,2168],[2170,2170]]],[1570199048233,["GJX@GJXAIOU",[[1,2170,"需要同时使用大根堆和小根堆，大根堆中存放着较小的 $$"]],[2170,2170],[2197,2197]]],[1570199051586,["GJX@GJXAIOU",[[1,2196,"\\fran"]],[2196,2196],[2201,2201]]],[1570199051935,["GJX@GJXAIOU",[[-1,2200,"n"]],[2201,2201],[2200,2200]]],[1570199057514,["GJX@GJXAIOU",[[1,2200,"c{N}{2}"]],[2200,2200],[2207,2207]]],[1570199091952,["GJX@GJXAIOU",[[1,2208,"个元素，小根堆中存放较大的  $\\frac{N}{2}$个元素；"]],[2208,2208],[2240,2240]]]],null,"GJX@GJXAIOU"],["4e80685a-43b0-4612-89dc-97657e6dae1e",1570371030808,"# AlgorithmEasyDay02\n\n**例题：**\n\n给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)；\n![示例]($resource/%E7%A4%BA%E4%BE%8B.png)\n其中 x 坐标为 L - 1，<=x 位置上放置的都是 <= num 值的数，然后依次向右遍历，如果该数大于 num，则不动，x 向右移动一位，即 x + 1，如果该数小于等于 num，则该数和 x + 1 位置上的数互换，以此类推；\n\n问题二（荷兰国旗问题）\n给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)\n![示例2]($resource/%E7%A4%BA%E4%BE%8B2.png)\n\nx 坐标为 L - 1，y 坐标为 R + 1，两边分别表示小于 num 和大于 num 的值，当前位置坐标为 cur，然后依次向右遍历，如果该数小于 num，则该数和小于区域最右边下标（x）的下一个坐标元素交换，小于区域向右扩充（即 x + 1），如果该数等于 num ,则 cur 指向下一个元素，如果大于 num，则该数和大于区域最左边区域的前一个坐标元素交换，大于区域向左扩充一个（即 y - 1），然后这里交换回来的数还需要按照上面的标准进行判断，直到 cur 和 又边界相遇停止；\n\n\n\n## 二、快速排序\n### 经典快排\n首先以数组最后一个数值为基准，将小于等于该数值的全部放在数组前半部分，大于该数值的全部放在数组的后半部分，然后前半部分和后半部分分别以该部分最后一个元素为基准重复以上步骤；\n\n**改进**：使用荷兰国旗思想\n首先还是选取数组最后一个值为基准，但是遍历判断的时候最后一个值不再进行判断，即只有 L ~ R - 1 的值与基准进行比较，同时区域划分为三个区域：小于基准、等于基准、大于基准；然后将小于基准和大于基准部分进行再次取最后一个数，同上进行比较.....最后全部比较结束之后，将最后一个基准值放在大于该基准的范围的前一个位置；\n\n\n特点：\n- 经典快排和数据的状态有关：\n  - 当小于最后一个数值的元素远大于大于最后一个数组的元素个数时候，或者反之情况，时间复杂度都是：$O({N}^{2})$\n  - 如果数据状态较好，即大于和小于差不多的情况下，时间复杂度为：$T(N) = 2T(\\frac{N}{2}) + O(N) = O(N * log_{2}^{N})$\n\n经典快排的空间复杂度为：$O(N)$\n\n### 随机快速排序\n通过随机选一个数和最后一个数进行互换，使得每次划分标准都在改变；\n根据随机性，随机快速排序的时间复杂度是：$O(N * \\log_{2}^{N})$，同时需要空间复杂度为：$O(\\log_{2}^{N})$，这里的额外空间主要用于记录每次划分区域的断点；\n\n\n\n\n\n## 堆排序\n\n### 堆\n堆是一个完全二叉树，可以采用数组进行实现；\n对于完全二叉树，结点 i 的左孩子序号为：2i + 1；右孩子序号为：2i + 2；父结点的序号为：$\\frac{i - 1}{2}$，\n\n分类：\n- 大根堆：每棵树（包括任意一棵子树）的最大值都是其头部（父结点）；\n- 小根堆：每棵树（包括任意一棵子树）的最小值都是其头部（父结点）；\n\n**完全二叉树**：对一棵具有 n 个节点的二叉树按照层序进行编号，如果编号 i （1<=i<=n）的结点与同样深度的满二叉树中编号为 i 的结点位置完全相同；\n**满二叉树**：所有的分支结点都存在左子树和右子树，且所有的叶子都在同一层；\n\n### 数组转换为大根堆\n以数组 [2,1,3,6,0,4]为例：\n首先取出第一元素 2，然后取出第二个元素 1，该元素比 2 小，放在左孩子位置，数组元素为：[2,1]；然后取出第三个元素 3，计算该元素的父结点：$\\frac{2 - 1}{2} = 0$，则与 0 位置元素 2 进行比较，发现 3 比较大，则在数组中将 3 和 2 两个元素互换，则数组变为：[3,1,2]；然后取出第四个元素 6，计算父结点下标为：$\\frac{3 - 1}{2} = 1$，则与 1 位置的元素 1 进行比较，发现 6 比较大，则将元素 1 和元素 6 互换，得到[3,6,2,1]，然后再比较元素 6 和其父结点：$\\frac{1 - 1}{2} = 0$，比较得出 6 比 3 大，然后再换，最后得到数组为：[6,3,2,1]，剩下元素依次类推......\n\n每加入一个节点其最多比较的次数和已经形成的二叉树高度有关（因为每次只和其父结点比较），因此最多时间复杂度为：$O(log_{2}^{N})$，所有整个转换过程时间复杂度为：$log_{2}^{1} + log_{2}^{2} + ..... + log_{2}^{N} = O(N)$\n\n\n**题目**\n吐泡泡：一个 XXX 会不停的吐出数字，求任意时刻的已经吐出的所有元素的中位数；\n\n**解答：**\n这里需要同时使用大根堆和小根堆，大根堆中存放着较小的 $\\frac{N}{2}$个元素，小根堆中存放较大的  $\\frac{N}{2}$个元素；",[[1570371022864,["GJX@GJXAIOU",[[1,2240,"\n\n"]],[2240,2240],[2241,2241]]],[1570371022999,["GJX@GJXAIOU",[[1,2242,"\n"]],[2241,2241],[2242,2242]]],[1570371025312,["GJX@GJXAIOU",[[-1,2242,"\n"],[1,2243,"*"]],[2242,2242],[2243,2243]]],[1570371025472,["GJX@GJXAIOU",[[1,2243,"***"]],[2243,2243],[2244,2244]]],[1570371029902,["GJX@GJXAIOU",[[1,2244,"概念："]],[2244,2244],[2247,2247]]],[1570371031257,["GJX@GJXAIOU",[[1,2249,"\n\n"]],[2249,2249],[2250,2250]]],[1570371034656,["GJX@GJXAIOU",[[-1,2250,"\n"],[1,2251," "]],[2250,2250],[2251,2251]]],[1570371059081,["GJX@GJXAIOU",[[1,2251,"HeapInsert：将新的节点加入堆中同时按照堆的结构畸形"]],[2251,2251],[2281,2281]]],[1570371059696,["GJX@GJXAIOU",[[-1,2279,"畸形"]],[2281,2281],[2279,2279]]],[1570371063470,["GJX@GJXAIOU",[[1,2279,"进行调整"]],[2279,2279],[2283,2283]]],[1570371065775,["GJX@GJXAIOU",[[-1,2281,"调整"]],[2283,2283],[2281,2281]]],[1570371088471,["GJX@GJXAIOU",[[1,2281,"向上调整的过程；\n HeapSize：堆的大小；\n "]],[2281,2281],[2307,2307]]],[1570371095887,["GJX@GJXAIOU",[[1,2307,"Heapify:"]],[2307,2307],[2315,2315]]],[1570371097150,["GJX@GJXAIOU",[[-1,2314,":"]],[2315,2315],[2314,2314]]],[1570371102552,["GJX@GJXAIOU",[[1,2314,"：假设堆中（）"]],[2314,2314],[2321,2321]]],[1570371105754,["GJX@GJXAIOU",[[1,2320,"数组中"]],[2320,2320],[2323,2323]]],[1570371111801,["GJX@GJXAIOU",[[1,2324,"某个值繁盛"]],[2324,2324],[2329,2329]]],[1570371112455,["GJX@GJXAIOU",[[-1,2327,"繁盛"]],[2329,2329],[2327,2327]]],[1570371115384,["GJX@GJXAIOU",[[1,2327,"发生 "]],[2327,2327],[2330,2330]]],[1570371115998,["GJX@GJXAIOU",[[-1,2329," "]],[2330,2330],[2329,2329]]],[1570371132751,["GJX@GJXAIOU",[[1,2329,"了变化，让其整体再次调整为大更对"]],[2329,2329],[2345,2345]]],[1570371133584,["GJX@GJXAIOU",[[-1,2342,"大更对"]],[2345,2345],[2342,2342]]],[1570371138872,["GJX@GJXAIOU",[[1,2342,"大根堆（）"]],[2342,2342],[2347,2347]]],[1570371145604,["GJX@GJXAIOU",[[1,2346,"或小根堆"]],[2346,2346],[2350,2350]]],[1570371166841,["GJX@GJXAIOU",[[1,2351,"原来的样子的过程；-"]],[2351,2351],[2361,2361]]],[1570371167503,["GJX@GJXAIOU",[[-1,2360,"-"]],[2361,2361],[2360,2360]]],[1570371170639,["GJX@GJXAIOU",[[1,2360,"\n  首相"]],[2360,2360],[2365,2365]]],[1570371172031,["GJX@GJXAIOU",[[-1,2363,"首相"]],[2365,2365],[2363,2363]]],[1570371183363,["GJX@GJXAIOU",[[1,2363,"首先找到变化的值的梁海"]],[2363,2363],[2374,2374]]],[1570371184590,["GJX@GJXAIOU",[[-1,2372,"梁海"]],[2374,2374],[2372,2372]]],[1570371189114,["GJX@GJXAIOU",[[1,2372,"两份"]],[2372,2372],[2374,2374]]],[1570371190047,["GJX@GJXAIOU",[[-1,2372,"两份"]],[2374,2374],[2372,2372]]],[1570371207074,["GJX@GJXAIOU",[[1,2372,"两个孩子，然后找到其中较大的一个与之交换，最后"]],[2372,2372],[2395,2395]]],[1570371208419,["GJX@GJXAIOU",[[-1,2393,"最后"]],[2395,2395],[2393,2393]]],[1570371210186,["GJX@GJXAIOU",[[1,2393,"如果"]],[2393,2393],[2395,2395]]],[1570371253414,["GJX@GJXAIOU",[[1,2395,"有交换，在新的位置上再次找现在的两个孩子进行比较，然后交换，一直到没有交换为止；\n  "]],[2395,2395],[2438,2438]]],[1570371253633,["GJX@GJXAIOU",[[-1,2436,"  "],[1,2438,"\n\n"]],[2438,2438],[2437,2437]]],[1570371262456,["GJX@GJXAIOU",[[1,2242,"\n"]],[2241,2241],[2242,2242]]],[1570371262617,["GJX@GJXAIOU",[[1,2243,"\n"]],[2242,2242],[2243,2243]]],[1570371262743,["GJX@GJXAIOU",[[1,2244,"\n"]],[2243,2243],[2244,2244]]],[1570371262864,["GJX@GJXAIOU",[[1,2245,"\n"]],[2244,2244],[2245,2245]]],[1570371267129,["GJX@GJXAIOU",[[1,2242,"种类"]],[2242,2242],[2244,2244]]],[1570371267854,["GJX@GJXAIOU",[[-1,2242,"种类"]],[2244,2244],[2242,2242]]],[1570371273407,["GJX@GJXAIOU",[[-1,2441,"\n"]],[2441,2441],[2440,2440]]],[1570371275738,["GJX@GJXAIOU",[[-1,2440,"\n"],[1,2441,"堆"]],[2440,2440],[2441,2441]]],[1570371290626,["GJX@GJXAIOU",[[1,2441,"减小的过程：以打更队"]],[2441,2441],[2451,2451]]],[1570371291535,["GJX@GJXAIOU",[[-1,2448,"打更队"]],[2451,2451],[2448,2448]]],[1570371296672,["GJX@GJXAIOU",[[1,2448,"大根堆为例："]],[2448,2448],[2454,2454]]],[1570371299760,["GJX@GJXAIOU",[[1,2254,"-"]],[2254,2254],[2255,2255]]],[1570371301704,["GJX@GJXAIOU",[[1,2295,"-"]],[2295,2295],[2296,2296]]],[1570371301880,["GJX@GJXAIOU",[[1,2297," "]],[2296,2296],[2297,2297]]],[1570371304216,["GJX@GJXAIOU",[[1,2314,"- "]],[2314,2314],[2316,2316]]],[1570371305598,["GJX@GJXAIOU",[[-1,2313," "]],[2314,2314],[2313,2313]]],[1570371308738,["GJX@GJXAIOU",[[1,2444,"- "]],[2444,2444],[2446,2446]]],[1570371317667,["GJX@GJXAIOU",[[1,2460,"首先将对顶和"]],[2460,2460],[2466,2466]]],[1570371318862,["GJX@GJXAIOU",[[-1,2463,"对顶和"]],[2466,2466],[2463,2463]]],[1570371324872,["GJX@GJXAIOU",[[1,2463,"堆定和"]],[2463,2463],[2466,2466]]],[1570371330258,["GJX@GJXAIOU",[[1,2312,"0-"]],[2312,2312],[2314,2314]]],[1570371334017,["GJX@GJXAIOU",[[1,2314,"i;"]],[2314,2314],[2316,2316]]],[1570371338461,["GJX@GJXAIOU",[[1,2312,"对应 "]],[2312,2312],[2314,2314]]],[1570371340881,["GJX@GJXAIOU",[[1,2314,"数组中就是"]],[2314,2314],[2319,2319]]],[1570371344059,["GJX@GJXAIOU",[[1,2323,"位置"]],[2323,2323],[2325,2325]]],[1570371344085,["GJX@GJXAIOU",[[1,2323," "]],[2325,2325],[2326,2326]]],[1570371352056,["GJX@GJXAIOU",[[-1,2479,"定和"]],[2481,2481],[2479,2479]]],[1570371366730,["GJX@GJXAIOU",[[1,2479,"顶元素和堆的最后一个元素怒"]],[2479,2479],[2492,2492]]],[1570371368214,["GJX@GJXAIOU",[[-1,2489,"元素怒"]],[2492,2492],[2489,2489]]],[1570371381594,["GJX@GJXAIOU",[[1,2489,"元素位置互换，这样原来的"]],[2489,2489],[2501,2501]]],[1570371382543,["GJX@GJXAIOU",[[-1,2500,"的"]],[2501,2501],[2500,2500]]],[1570371384394,["GJX@GJXAIOU",[[1,2500,"堆定的"]],[2500,2500],[2503,2503]]],[1570371384919,["GJX@GJXAIOU",[[-1,2500,"堆定的"]],[2503,2503],[2500,2500]]],[1570371390280,["GJX@GJXAIOU",[[1,2500,"堆顶"]],[2500,2500],[2502,2502]]],[1570371405668,["GJX@GJXAIOU",[[1,2502,"的元素就放在了数组的最后，然后将对"]],[2502,2502],[2519,2519]]],[1570371406222,["GJX@GJXAIOU",[[-1,2518,"对"]],[2519,2519],[2518,2518]]],[1570371445843,["GJX@GJXAIOU",[[1,2518,"堆的 Heapsize - 1，这样最后一个元素就应为超过了现在的 HeapSize而"]],[2518,2518],[2561,2561]]],[1570371445868,["GJX@GJXAIOU",[[1,2560," "]],[2561,2561],[2562,2562]]],[1570371450167,["GJX@GJXAIOU",[[1,2562,"越界，"]],[2562,2562],[2565,2565]]],[1570371480436,["GJX@GJXAIOU",[[1,2565,"从而失效，"]],[2565,2565],[2570,2570]]],[1570371481214,["GJX@GJXAIOU",[[-1,2569,"，"]],[2570,2570],[2569,2569]]],[1570371484370,["GJX@GJXAIOU",[[1,2569,"；燃油"]],[2569,2569],[2572,2572]]],[1570371485047,["GJX@GJXAIOU",[[-1,2570,"燃油"]],[2572,2572],[2570,2570]]],[1570371491240,["GJX@GJXAIOU",[[1,2570,"然后将剩余的 -"]],[2570,2570],[2578,2578]]],[1570371491719,["GJX@GJXAIOU",[[-1,2577,"-"]],[2578,2578],[2577,2577]]],[1570371494532,["GJX@GJXAIOU",[[1,2577,"0 - i - 1"]],[2577,2577],[2586,2586]]],[1570371497271,["GJX@GJXAIOU",[[-1,2579,"-"]],[2580,2580],[2579,2579]]],[1570371498081,["GJX@GJXAIOU",[[1,2579,"~"]],[2579,2579],[2580,2580]]],[1570371500722,["GJX@GJXAIOU",[[1,2586,"位置"]],[2586,2586],[2588,2588]]],[1570371500749,["GJX@GJXAIOU",[[1,2586," "]],[2588,2588],[2589,2589]]],[1570371507313,["GJX@GJXAIOU",[[1,2589,"的按照 "]],[2589,2589],[2593,2593]]],[1570371522201,["GJX@GJXAIOU",[[1,2593,"Heapify 宠幸"]],[2593,2593],[2603,2603]]],[1570371522982,["GJX@GJXAIOU",[[-1,2601,"宠幸"]],[2603,2603],[2601,2601]]],[1570371528447,["GJX@GJXAIOU",[[1,2601,"重新进行调整（）"]],[2601,2601],[2609,2609]]],[1570371538729,["GJX@GJXAIOU",[[1,2608,"因为堆顶的元素值发生了变化"]],[2608,2608],[2621,2621]]],[1570371545752,["GJX@GJXAIOU",[[1,2622,"为原来的堆结构；"]],[2622,2622],[2630,2630]]],[1570371561946,["GJX@GJXAIOU",[[1,2242,"这里以：5 46 7"]],[2242,2242],[2252,2252]]],[1570371562766,["GJX@GJXAIOU",[[-1,2249,"6 7"]],[2252,2252],[2249,2249]]],[1570371566139,["GJX@GJXAIOU",[[1,2249," 6 7 为例"]],[2249,2249],[2256,2256]]],[1570371566478,["GJX@GJXAIOU",[[1,2260,"\n"]],[2256,2256],[2257,2257]]],[1570371567840,["GJX@GJXAIOU",[[1,2257,"收件"]],[2257,2257],[2259,2259]]],[1570371568583,["GJX@GJXAIOU",[[-1,2257,"收件"]],[2259,2259],[2257,2257]]],[1570371570097,["GJX@GJXAIOU",[[1,2257,"守将"]],[2257,2257],[2259,2259]]],[1570371570712,["GJX@GJXAIOU",[[-1,2258,"将"]],[2259,2259],[2258,2258]]],[1570371570926,["GJX@GJXAIOU",[[-1,2260,"\n"]],[2257,2257],[2256,2256]]],[1570371573352,["GJX@GJXAIOU",[[1,2260,"\n"]],[2256,2256],[2257,2257]]],[1570371587568,["GJX@GJXAIOU",[[1,2257,"首先将 5 放入大根堆，然后因为4"]],[2257,2257],[2274,2274]]],[1570371587597,["GJX@GJXAIOU",[[1,2273," "]],[2274,2274],[2275,2275]]],[1570371598447,["GJX@GJXAIOU",[[1,2275," 小于等于大根堆的堆顶，英雌"]],[2275,2275],[2289,2289]]],[1570371599030,["GJX@GJXAIOU",[[-1,2287,"英雌"]],[2289,2289],[2287,2287]]],[1570371606337,["GJX@GJXAIOU",[[1,2287,"因此放入大根堆，"]],[2287,2287],[2295,2295]]],[1570371626508,["GJX@GJXAIOU",[[1,2269,"计算大根堆和小根堆的 He安排size "]],[2269,2269],[2288,2288]]],[1570371626832,["GJX@GJXAIOU",[[1,2288,"，"]],[2288,2288],[2289,2289]]],[1570371628735,["GJX@GJXAIOU",[[-1,2280,"He安排size，"]],[2289,2289],[2280,2280]]],[1570371690817,[null,[[-1,2307,"守"]],[2307,2307],[2307,2307]]],[1570371690817,[null,[[1,2307,"守"]],[2307,2307],[2307,2307]]],[1570371640768,["GJX@GJXAIOU",[[1,2280,"Heapsize，插值为1"]],[2280,2280],[2293,2293]]],[1570371640796,["GJX@GJXAIOU",[[1,2292," "]],[2293,2293],[2294,2294]]],[1570371642129,["GJX@GJXAIOU",[[1,2294,"，"]],[2294,2294],[2295,2295]]],[1570371644068,["GJX@GJXAIOU",[[-1,2294,"，"]],[2295,2295],[2294,2294]]],[1570371645875,["GJX@GJXAIOU",[[1,2294,",不发欧诺个"]],[2294,2294],[2300,2300]]],[1570371647214,["GJX@GJXAIOU",[[-1,2295,"不发欧诺个"]],[2300,2300],[2295,2295]]],[1570371650092,["GJX@GJXAIOU",[[1,2295,"不动"]],[2295,2295],[2297,2297]]],[1570371650761,["GJX@GJXAIOU",[[-1,2296,"动"]],[2297,2297],[2296,2296]]],[1570371653929,["GJX@GJXAIOU",[[1,2296,"动，"]],[2296,2296],[2298,2298]]],[1570371664427,["GJX@GJXAIOU",[[1,2325,"再次就散"]],[2325,2325],[2329,2329]]],[1570371665144,["GJX@GJXAIOU",[[-1,2327,"就散"]],[2329,2329],[2327,2327]]],[1570371671233,["GJX@GJXAIOU",[[1,2327,"计算 He安排Size"]],[2327,2327],[2338,2338]]],[1570371673255,["GJX@GJXAIOU",[[-1,2330,"He安排Size"]],[2338,2338],[2330,2330]]],[1570371676457,["GJX@GJXAIOU",[[1,2330,"HeapSeiz"]],[2330,2330],[2338,2338]]],[1570371677041,["GJX@GJXAIOU",[[-1,2335,"eiz"]],[2338,2338],[2335,2335]]],[1570371690625,["GJX@GJXAIOU",[[1,2335,"ize，插值 > 1，然后将大根堆的"]],[2335,2335],[2353,2353]]],[1570371750820,[null,[[-1,2353,"守"]],[2353,2353],[2353,2353]]],[1570371750820,[null,[[1,2353,"守"]],[2353,2353],[2353,2353]]],[1570371745915,["GJX@GJXAIOU",[[1,2353,"堆顶放在小根堆，然后将大根堆剩余的调整为大根堆，然后插入"]],[2353,2353],[2381,2381]]],[1570371748158,["GJX@GJXAIOU",[[-1,2379,"插入"]],[2381,2381],[2379,2379]]],[1570371810819,[null,[[-1,2379,"守"]],[2379,2379],[2379,2379]]],[1570371810819,[null,[[1,2379,"守"]],[2379,2379],[2379,2379]]],[1570371752106,["GJX@GJXAIOU",[[1,2379,"元素怒"]],[2379,2379],[2382,2382]]],[1570371752480,["GJX@GJXAIOU",[[-1,2381,"怒"]],[2382,2382],[2381,2381]]],[1570371761984,["GJX@GJXAIOU",[[1,2381," 6 大于大根堆现在堆顶4"]],[2381,2381],[2394,2394]]],[1570371762012,["GJX@GJXAIOU",[[1,2393," "]],[2394,2394],[2395,2395]]],[1570371777015,["GJX@GJXAIOU",[[1,2395,"，因此放入小根堆，"]],[2395,2395],[2404,2404]]],[1570371780566,["GJX@GJXAIOU",[[-1,2403,"，"]],[2404,2404],[2403,2403]]],[1570371785881,["GJX@GJXAIOU",[[1,2403,"；现在大根堆为4"]],[2403,2403],[2411,2411]]],[1570371785907,["GJX@GJXAIOU",[[1,2410," "]],[2411,2411],[2412,2412]]],[1570371794112,["GJX@GJXAIOU",[[1,2412,"，小根堆为5"]],[2412,2412],[2418,2418]]],[1570371794140,["GJX@GJXAIOU",[[1,2417," "]],[2418,2418],[2419,2419]]],[1570371794424,["GJX@GJXAIOU",[[1,2419,"，"]],[2419,2419],[2420,2420]]],[1570371795050,["GJX@GJXAIOU",[[-1,2419,"，"]],[2420,2420],[2419,2419]]],[1570371800593,["GJX@GJXAIOU",[[1,2419,",6；插值Wie"]],[2419,2419],[2427,2427]]],[1570371800621,["GJX@GJXAIOU",[[1,2424," "]],[2427,2427],[2428,2428]]],[1570371803342,["GJX@GJXAIOU",[[-1,2424," Wie"]],[2428,2428],[2424,2424]]],[1570371804616,["GJX@GJXAIOU",[[1,2424,"为1"]],[2424,2424],[2426,2426]]],[1570371804644,["GJX@GJXAIOU",[[1,2425," "]],[2426,2426],[2427,2427]]],[1570371807232,["GJX@GJXAIOU",[[1,2427,"，然后放入"]],[2427,2427],[2432,2432]]],[1570371870823,[null,[[-1,2432,"守"]],[2432,2432],[2432,2432]]],[1570371870823,[null,[[1,2432,"守"]],[2432,2432],[2432,2432]]],[1570371813697,["GJX@GJXAIOU",[[1,2432,"元素7"]],[2432,2432],[2435,2435]]],[1570371813724,["GJX@GJXAIOU",[[1,2434," "]],[2435,2435],[2436,2436]]],[1570371817211,["GJX@GJXAIOU",[[1,2436,"，同样大于"]],[2436,2436],[2441,2441]]],[1570371930821,[null,[[-1,2441,"守"]],[2441,2441],[2441,2441]]],[1570371930821,[null,[[1,2441,"守"]],[2441,2441],[2441,2441]]],[1570371907569,["GJX@GJXAIOU",[[1,2441,"大根堆堆顶，放入小耿对"]],[2441,2441],[2452,2452]]],[1570371908285,["GJX@GJXAIOU",[[-1,2450,"耿对"]],[2452,2452],[2450,2450]]],[1570371925280,["GJX@GJXAIOU",[[1,2450,"根堆，然后插值> 1，将小耿对"]],[2450,2450],[2465,2465]]],[1570371926229,["GJX@GJXAIOU",[[-1,2462,"小耿对"]],[2465,2465],[2462,2462]]],[1570371928650,["GJX@GJXAIOU",[[1,2462,"小根堆的"]],[2462,2462],[2466,2466]]],[1570371990822,[null,[[-1,2466,"守"]],[2466,2466],[2466,2466]]],[1570371990822,[null,[[1,2466,"守"]],[2466,2466],[2466,2466]]],[1570371970544,["GJX@GJXAIOU",[[1,2466,"堆顶放入大根堆末尾，小根堆冲向"]],[2466,2466],[2481,2481]]],[1570371971872,["GJX@GJXAIOU",[[-1,2479,"冲向"]],[2481,2481],[2479,2479]]],[1570371982640,["GJX@GJXAIOU",[[1,2479,"重新排为："]],[2479,2479],[2484,2484]]],[1570372050824,[null,[[-1,2484,"守"]],[2484,2484],[2484,2484]]],[1570372050824,[null,[[1,2484,"守"]],[2484,2484],[2484,2484]]],[1570372019025,["GJX@GJXAIOU",[[1,2484,"6，"]],[2484,2484],[2486,2486]]],[1570372019196,["GJX@GJXAIOU",[[-1,2485,"，"]],[2486,2486],[2485,2485]]],[1570372019993,["GJX@GJXAIOU",[[1,2485,",7，"]],[2485,2485],[2488,2488]]],[1570372021011,["GJX@GJXAIOU",[[-1,2487,"，"]],[2488,2488],[2487,2487]]],[1570372021337,["GJX@GJXAIOU",[[1,2487,",；"]],[2487,2487],[2489,2489]]],[1570372021837,["GJX@GJXAIOU",[[-1,2487,",；"]],[2489,2489],[2487,2487]]],[1570372024762,["GJX@GJXAIOU",[[1,2487,"；打更队"]],[2487,2487],[2491,2491]]],[1570372025805,["GJX@GJXAIOU",[[-1,2488,"打更队"]],[2491,2491],[2488,2488]]],[1570372037075,["GJX@GJXAIOU",[[1,2488,"大根堆重新排位"]],[2488,2488],[2495,2495]]],[1570372037582,["GJX@GJXAIOU",[[-1,2494,"位"]],[2495,2495],[2494,2494]]],[1570372048159,["GJX@GJXAIOU",[[1,2494,"为：5，"]],[2494,2494],[2498,2498]]],[1570372048789,["GJX@GJXAIOU",[[-1,2497,"，"]],[2498,2498],[2497,2497]]],[1570372049289,["GJX@GJXAIOU",[[1,2497,",4，"]],[2497,2497],[2500,2500]]],[1570372049766,["GJX@GJXAIOU",[[-1,2499,"，"]],[2500,2500],[2499,2499]]],[1570372050105,["GJX@GJXAIOU",[[1,2499,",；"]],[2499,2499],[2501,2501]]],[1570372050606,["GJX@GJXAIOU",[[-1,2499,",；"]],[2501,2501],[2499,2499]]],[1570372110827,[null,[[-1,2499,"守"]],[2499,2499],[2499,2499]]],[1570372110827,[null,[[1,2499,"守"]],[2499,2499],[2499,2499]]],[1570372055967,["GJX@GJXAIOU",[[1,2499,"；中位数就是"]],[2499,2499],[2505,2505]]],[1570372290830,[null,[[-1,2505,"守"]],[2505,2505],[2505,2505]]],[1570372290830,[null,[[1,2505,"守"]],[2505,2505],[2505,2505]]],[1570372273816,["GJX@GJXAIOU",[[1,2505,"连个"]],[2505,2505],[2507,2507]]],[1570372274390,["GJX@GJXAIOU",[[-1,2505,"连个"]],[2507,2507],[2505,2505]]],[1570372279730,["GJX@GJXAIOU",[[1,2505,"两个堆顶的平均值；"]],[2505,2505],[2514,2514]]],[1570372282158,["GJX@GJXAIOU",[[1,2518,"\n"]],[2514,2514],[2515,2515]]],[1570372282287,["GJX@GJXAIOU",[[1,2519,"\n"]],[2515,2515],[2516,2516]]],[1570372282431,["GJX@GJXAIOU",[[1,2520,"\n"]],[2516,2516],[2517,2517]]],[1570372288295,["GJX@GJXAIOU",[[1,2517,"### 堆排序"]],[2517,2517],[2524,2524]]],[1570372288566,["GJX@GJXAIOU",[[1,2528,"\n"]],[2524,2524],[2525,2525]]],[1570372350833,[null,[[-1,2514,"守"],[1,2515,"\n"],[-1,2524,"\n"]],[2514,2514],[2524,2524]]],[1570372350833,[null,[[1,2514,"守"],[-1,2514,"\n"],[1,2524,"\n"]],[2524,2524],[2514,2514]]],[1570372297017,["GJX@GJXAIOU",[[1,2525,"首先将数组变成打更队"]],[2525,2525],[2535,2535]]],[1570372297557,["GJX@GJXAIOU",[[-1,2532,"打更队"]],[2535,2535],[2532,2532]]],[1570372302240,["GJX@GJXAIOU",[[1,2532,"大根堆；"]],[2532,2532],[2536,2536]]],[1570372303151,["GJX@GJXAIOU",[[1,2540,"\n"]],[2536,2536],[2537,2537]]],[1570372314259,["GJX@GJXAIOU",[[1,2537,"然后将堆中最后另一个和"]],[2537,2537],[2548,2548]]],[1570372315087,["GJX@GJXAIOU",[[-1,2544,"另一个和"]],[2548,2548],[2544,2544]]],[1570372345112,["GJX@GJXAIOU",[[1,2544,"一个和堆顶进行交换，堆大小减一，则最后一个不动了，然后将"]],[2544,2544],[2572,2572]]],[1570372402184,[null,[[-1,2514,"守"],[1,2515,"\n"],[-1,2572,"\n"]],[2514,2514],[2572,2572]]],[1570372402184,[null,[[1,2514,"守"],[-1,2514,"\n"],[1,2572,"\n"]],[2572,2572],[2514,2514]]],[1570372356159,["GJX@GJXAIOU",[[1,2572,"剩下的前面的"]],[2572,2572],[2578,2578]]],[1570372356830,["GJX@GJXAIOU",[[-1,2577,"的"]],[2578,2578],[2577,2577]]],[1570372368004,["GJX@GJXAIOU",[[1,2577,"进行 Heapify 调整，"]],[2577,2577],[2591,2591]]],[1570372374062,["GJX@GJXAIOU",[[-1,2590,"，"]],[2591,2591],[2590,2590]]],[1570372374473,["GJX@GJXAIOU",[[1,2590,"；"]],[2590,2590],[2591,2591]]],[1570372375159,["GJX@GJXAIOU",[[1,2595,"\n"]],[2591,2591],[2592,2592]]],[1570372385154,["GJX@GJXAIOU",[[1,2592,"然后再将对的"]],[2592,2592],[2598,2598]]],[1570372387302,["GJX@GJXAIOU",[[-1,2596,"对的"]],[2598,2598],[2596,2596]]],[1570372401185,["GJX@GJXAIOU",[[1,2596,"堆的最后一个和堆顶进行交换，同上.....;"]],[2596,2596],[2618,2618]]]],null,"GJX@GJXAIOU"],["a57870b6-2863-4ec8-8258-4fa9935da57f",1570431595894,"# AlgorithmEasyDay02\n\n**例题：**\n\n给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)；\n![示例]($resource/%E7%A4%BA%E4%BE%8B.png)\n其中 x 坐标为 L - 1，<=x 位置上放置的都是 <= num 值的数，然后依次向右遍历，如果该数大于 num，则不动，x 向右移动一位，即 x + 1，如果该数小于等于 num，则该数和 x + 1 位置上的数互换，以此类推；\n\n问题二（荷兰国旗问题）\n给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)\n![示例2]($resource/%E7%A4%BA%E4%BE%8B2.png)\n\nx 坐标为 L - 1，y 坐标为 R + 1，两边分别表示小于 num 和大于 num 的值，当前位置坐标为 cur，然后依次向右遍历，如果该数小于 num，则该数和小于区域最右边下标（x）的下一个坐标元素交换，小于区域向右扩充（即 x + 1），如果该数等于 num ,则 cur 指向下一个元素，如果大于 num，则该数和大于区域最左边区域的前一个坐标元素交换，大于区域向左扩充一个（即 y - 1），然后这里交换回来的数还需要按照上面的标准进行判断，直到 cur 和 又边界相遇停止；\n\n\n\n## 二、快速排序\n### 经典快排\n首先以数组最后一个数值为基准，将小于等于该数值的全部放在数组前半部分，大于该数值的全部放在数组的后半部分，然后前半部分和后半部分分别以该部分最后一个元素为基准重复以上步骤；\n\n**改进**：使用荷兰国旗思想\n首先还是选取数组最后一个值为基准，但是遍历判断的时候最后一个值不再进行判断，即只有 L ~ R - 1 的值与基准进行比较，同时区域划分为三个区域：小于基准、等于基准、大于基准；然后将小于基准和大于基准部分进行再次取最后一个数，同上进行比较.....最后全部比较结束之后，将最后一个基准值放在大于该基准的范围的前一个位置；\n\n\n特点：\n- 经典快排和数据的状态有关：\n  - 当小于最后一个数值的元素远大于大于最后一个数组的元素个数时候，或者反之情况，时间复杂度都是：$O({N}^{2})$\n  - 如果数据状态较好，即大于和小于差不多的情况下，时间复杂度为：$T(N) = 2T(\\frac{N}{2}) + O(N) = O(N * log_{2}^{N})$\n\n经典快排的空间复杂度为：$O(N)$\n\n### 随机快速排序\n通过随机选一个数和最后一个数进行互换，使得每次划分标准都在改变；\n根据随机性，随机快速排序的时间复杂度是：$O(N * \\log_{2}^{N})$，同时需要空间复杂度为：$O(\\log_{2}^{N})$，这里的额外空间主要用于记录每次划分区域的断点；\n\n\n\n\n\n## 堆排序\n\n### 堆\n堆是一个完全二叉树，可以采用数组进行实现；\n对于完全二叉树，结点 i 的左孩子序号为：2i + 1；右孩子序号为：2i + 2；父结点的序号为：$\\frac{i - 1}{2}$，\n\n分类：\n- 大根堆：每棵树（包括任意一棵子树）的最大值都是其头部（父结点）；\n- 小根堆：每棵树（包括任意一棵子树）的最小值都是其头部（父结点）；\n\n**完全二叉树**：对一棵具有 n 个节点的二叉树按照层序进行编号，如果编号 i （1<=i<=n）的结点与同样深度的满二叉树中编号为 i 的结点位置完全相同；\n**满二叉树**：所有的分支结点都存在左子树和右子树，且所有的叶子都在同一层；\n\n### 数组转换为大根堆\n以数组 [2,1,3,6,0,4]为例：\n首先取出第一元素 2，然后取出第二个元素 1，该元素比 2 小，放在左孩子位置，数组元素为：[2,1]；然后取出第三个元素 3，计算该元素的父结点：$\\frac{2 - 1}{2} = 0$，则与 0 位置元素 2 进行比较，发现 3 比较大，则在数组中将 3 和 2 两个元素互换，则数组变为：[3,1,2]；然后取出第四个元素 6，计算父结点下标为：$\\frac{3 - 1}{2} = 1$，则与 1 位置的元素 1 进行比较，发现 6 比较大，则将元素 1 和元素 6 互换，得到[3,6,2,1]，然后再比较元素 6 和其父结点：$\\frac{1 - 1}{2} = 0$，比较得出 6 比 3 大，然后再换，最后得到数组为：[6,3,2,1]，剩下元素依次类推......\n\n每加入一个节点其最多比较的次数和已经形成的二叉树高度有关（因为每次只和其父结点比较），因此最多时间复杂度为：$O(log_{2}^{N})$，所有整个转换过程时间复杂度为：$log_{2}^{1} + log_{2}^{2} + ..... + log_{2}^{N} = O(N)$\n\n\n**题目**\n吐泡泡：一个 XXX 会不停的吐出数字，求任意时刻的已经吐出的所有元素的中位数；\n\n**解答：**\n这里需要同时使用大根堆和小根堆，大根堆中存放着较小的 $\\frac{N}{2}$个元素，小根堆中存放较大的  $\\frac{N}{2}$个元素；\n\n这里以：5 4 6 7 为例\n首先将 5 放入大根堆，计算大根堆和小根堆的 Heapsize，插值为 1,不动， 然后因为 4 小于等于大根堆的堆顶，因此放入大根堆，再次计算 HeapSize，插值 > 1，然后将大根堆的堆顶放在小根堆，然后将大根堆剩余的调整为大根堆，然后元素 6 大于大根堆现在堆顶 4，因此放入小根堆；现在大根堆为 4，小根堆为 5,6；插值为 1，然后放入元素 7，同样大于大根堆堆顶，放入小根堆，然后插值> 1，将小根堆的堆顶放入大根堆末尾，小根堆重新排为：6,7；大根堆重新排为：5,4；中位数就是两个堆顶的平均值；\n\n\n### 堆排序\n首先将数组变成大根堆；\n然后将堆中最后一个和堆顶进行交换，堆大小减一，则最后一个不动了，然后将剩下的前面进行 Heapify 调整；\n然后再将堆的最后一个和堆顶进行交换，同上.....;\n\n\n\n**概念：**\n- HeapInsert：将新的节点加入堆中同时按照堆的结构进行向上调整的过程；\n-  HeapSize：堆的大小；对应数组中就是 0-i 位置;\n- Heapify：假设堆中（数组中）某个值发生了变化，让其整体再次调整为大根堆（或小根堆）原来的样子的过程；\n  首先找到变化的值的两个孩子，然后找到其中较大的一个与之交换，如果有交换，在新的位置上再次找现在的两个孩子进行比较，然后交换，一直到没有交换为止；\n- 堆减小的过程：以大根堆为例：首先将堆顶元素和堆的最后一个元素位置互换，这样原来堆顶的元素就放在了数组的最后，然后将堆的 Heapsize - 1，这样最后一个元素就应为超过了现在的 HeapSize 而越界，从而失效；然后将剩余的 0 ~ i - 1 位置的按照 Heapify 重新进行调整（因为堆顶的元素值发生了变化）为原来的堆结构；",[[1570431555228,["GJX@GJXAIOU",[[1,209,"x"]],[209,209],[210,210]]],[1570431555259,["GJX@GJXAIOU",[[1,209," "],[1,210," "]],[210,210],[211,211]]],[1570431557962,["GJX@GJXAIOU",[[1,215,"zhijei"]],[215,215],[221,221]]],[1570431559629,["GJX@GJXAIOU",[[-1,215,"zhijei"]],[221,221],[215,215]]],[1570431560931,["GJX@GJXAIOU",[[1,215,"直接 "]],[215,215],[217,217]]],[1570431569342,["GJX@GJXAIOU",[[1,217,"判断下一个数，"]],[217,217],[224,224]]],[1570431576774,["GJX@GJXAIOU",[[-1,224," x 向右移动一位，即 x + 1，"]],[224,242],[224,224]]],[1570431582600,["GJX@GJXAIOU",[[1,256," x 向右移动一位，即 x + 1，然后仅需"]],[256,256],[278,278]]],[1570431583302,["GJX@GJXAIOU",[[-1,276,"仅需"]],[278,278],[276,276]]],[1570431588558,["GJX@GJXAIOU",[[1,276,"继续判断下一个数；"]],[276,276],[285,285]]],[1570434001235,["GJX@GJXAIOU",[[1,292,"\n"]],[291,291],[292,292]]],[1570434002871,["GJX@GJXAIOU",[[1,293,"\n"]],[291,291],[292,292]]],[1570434003803,["GJX@GJXAIOU",[[1,292,"```"]],[292,292],[295,295]]],[1570434003831,["GJX@GJXAIOU",[[1,295,"language\n```\n"]],[295,295],[295,303]]],[1570434005335,["GJX@GJXAIOU",[[-1,295,"language"],[1,303,"j"]],[295,303],[296,296]]],[1570434005910,["GJX@GJXAIOU",[[1,296,"ava"]],[296,296],[299,299]]],[1570434006146,["GJX@GJXAIOU",[[1,300,"\n"]],[299,299],[300,300]]],[1570434009887,["GJX@GJXAIOU",[[1,300,"public class Demo {\n    public static void sort(int[] sourceArray, int left, int right, int tagMum){\n        int less = left - 1;\n        while(left < right){\n            if(sourceArray[left] <= tagMum){\n                swap(sourceArray, left++, ++less);\n            }\n            if(sourceArray [left] > tagMum){\n                left++;\n            }\n        }\n        return ;\n    }\n\n    public static void swap(int[] sourceArray, int left, int right) {\n        if(left == right){\n            return;\n        }\n        sourceArray[left] = sourceArray[left] ^ sourceArray[right];\n        sourceArray[right] = sourceArray[left] ^ sourceArray[right];\n        sourceArray[left] = sourceArray[left] ^ sourceArray[right];\n    }\n    \n    public static void main(String[] args) {\n        int[] sourceArray ={1,2,8,4,9,3,1,4,3,2,7};\n        int left = 0;\n        int right = sourceArray.length - 1;\n        int tagMum = 6;\n        sort(sourceArray, left, right, tagMum);\n        for (int i : sourceArray) {\n            System.out.println(i);\n        }\n    }\n}"]],[300,300],[1352,1352]]],[1570434141841,["GJX@GJXAIOU",[[1,1712,"**"],[1,1732,"**"]],[1712,1732],[1712,1736]]],[1570434159602,["GJX@GJXAIOU",[[1,30,"wenti"]],[30,30],[35,35]]],[1570434160745,["GJX@GJXAIOU",[[-1,30,"wenti"]],[35,35],[30,30]]],[1570434163650,["GJX@GJXAIOU",[[1,30,"问题一："]],[30,30],[34,34]]],[1570434442788,["GJX@GJXAIOU",[[1,34,"分割数组"]],[34,34],[38,38]]],[1570434711726,["GJX@GJXAIOU",[[1,309,"ackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-07-15:03\n */\np"],[-1,321,"Demo"],[1,325,"SplitArray"],[1,1032,"\n"],[1,1036,"// 测试方法"],[1,1224,"\n        System.out.println(\"原数组为：\");\n        for (int i : sourceArray) {\n            System.out.print(i + \" \");\n        }\n\n"],[1,1272,"\n        System.out.println(\"\\n分割之后数组为：\");\n"],[-1,1336,"ln"],[1,1340," + \" \""],[-1,1360,""],[1,1360,"\n"]],[308,1360],[1636,1636]]],[1570435497120,["GJX@GJXAIOU",[[1,2042,"\n"]],[2039,2039],[2040,2040]]],[1570435498250,["GJX@GJXAIOU",[[1,2040,"···"]],[2040,2040],[2043,2043]]],[1570435498743,["GJX@GJXAIOU",[[-1,2042,"·"]],[2043,2043],[2042,2042]]],[1570435498888,["GJX@GJXAIOU",[[-1,2041,"·"]],[2042,2042],[2041,2041]]],[1570435500369,["GJX@GJXAIOU",[[1,2041,"~··"]],[2041,2041],[2044,2044]]],[1570435501993,["GJX@GJXAIOU",[[-1,2040,"·~··"]],[2044,2044],[2040,2040]]],[1570435502972,["GJX@GJXAIOU",[[1,2040,"···"]],[2040,2040],[2043,2043]]],[1570435503800,["GJX@GJXAIOU",[[-1,2040,"···"]],[2043,2043],[2040,2040]]],[1570435505772,["GJX@GJXAIOU",[[1,2040,"```"]],[2040,2040],[2043,2043]]],[1570435505803,["GJX@GJXAIOU",[[1,2043,"language\n```\n"]],[2043,2043],[2043,2051]]],[1570435506609,["GJX@GJXAIOU",[[-1,2043,"language"],[1,2051,"j"]],[2043,2051],[2044,2044]]],[1570435507051,["GJX@GJXAIOU",[[1,2044,"ava"]],[2044,2044],[2047,2047]]],[1570435507176,["GJX@GJXAIOU",[[1,2048,"\n"]],[2047,2047],[2048,2048]]],[1570435509714,["GJX@GJXAIOU",[[1,2048,"package sort.nowcoder.easy.day01;\n\npublic class NetherlandsFlag {\n\t/**\n\t * @param sourceArray：要分割的数组\n\t * @param left：小于 tagNum 区域最右边数\n\t * @param right：大于 tagNum 区域最左边数\n\t * @param tagNum：用于分割的参考数字\n\t * @return\n\t */\n\tpublic static int[] partition(int[] sourceArray, int left, int right, int tagNum) {\n\t\t// less 表示小于 tagNum 区域最右边数，more 是大于 tagNum 区域最左边数\n\t\tint less = left - 1;\n\t\tint more = right + 1;\n\t\twhile (left < more) {\n\t\t\tif (sourceArray[left] < tagNum) {\n\t\t\t\tswap(sourceArray, ++less, left++);\n\t\t\t} else if (sourceArray[left] > tagNum) {\n\t\t\t\tswap(sourceArray, --more, left);\n\t\t\t} else {\n\t\t\t\tleft++;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { less + 1, more - 1 };\n\t}\n\t\n\tpublic static void swap(int[] sourceArray, int left, int right) {\n\t\tint tmp = sourceArray[left];\n\t\tsourceArray[left] = sourceArray[right];\n\t\tsourceArray[right] = tmp;\n\t}"]],[2048,2048],[2877,2877]]],[1570435512475,["GJX@GJXAIOU",[[1,2878,"\t\n"]],[2877,2877],[2879,2879]]],[1570435512890,["GJX@GJXAIOU",[[1,2879,"}"]],[2879,2879],[2880,2880]]],[1570435514287,["GJX@GJXAIOU",[[-1,2878,"\t"]],[2879,2879],[2878,2878]]],[1570438303008,["GJX@GJXAIOU",[[1,3505,"··"]],[3505,3505],[3507,3507]]],[1570438303983,["GJX@GJXAIOU",[[-1,3505,"··"]],[3507,3507],[3505,3505]]],[1570438306068,["GJX@GJXAIOU",[[1,3505,"```"]],[3505,3505],[3508,3508]]],[1570438306097,["GJX@GJXAIOU",[[1,3508,"language\n```\n"]],[3508,3508],[3508,3516]]],[1570438307337,["GJX@GJXAIOU",[[-1,3508,"language"],[1,3516,"j"]],[3508,3516],[3509,3509]]],[1570438307787,["GJX@GJXAIOU",[[1,3509,"ava"]],[3509,3509],[3512,3512]]],[1570438308943,["GJX@GJXAIOU",[[1,3513,"\n"]],[3512,3512],[3513,3513]]],[1570438311752,["GJX@GJXAIOU",[[1,3513,"package sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-04-20:08\n */\n\nimport java.util.Arrays;\n\npublic class QuickSort {\n    /**\n     *  首先调用该方法，可以设置排序的区间，默认为 0 ~ length-1；\n     * @param sourceArray：需要排序的数组\n     */\n    public static void quickSort(int[] sourceArray) {\n        if (sourceArray == null || sourceArray.length < 2) {\n            return;\n        }\n        quickSort(sourceArray, 0, sourceArray.length - 1);\n    }\n\n    /**\n     * @param sourceArray：需要排序的数组\n     * @param left：排序数组左边界，一般为：0\n     * @param right：排序数组右边界，一般为：length - 1;\n     *  less：小于参照元素区域的最右边边界：less = p[0] - 1;\n     *  more：大于参照元素区域的最左边边界：more = p[1] + 1;\n     *  p[0]：等于参照元素区域的最左边边界；\n     *  p[1]：等于参数元素区域的最右边边界；\n     *  小于参照元素区域：[Left ~ less];\n     *  等于参照元素区域：[p[0] ~ p[1]]；\n     *  大于参照元素区域：[more ~ right]；\n     */\n    public static void quickSort(int[] sourceArray, int left, int right) {\n        if (left < right) {\n            swap(sourceArray, left + (int) (Math.random() * (right - left + 1)), right);\n            // p 数组中： p[0] 表示等于区域的左边界，p[1] 表示等于区域的右边界，\n            // 左边区域：L ~ p[0] - 1;右边区域： p[1] + 1 ~ R;\n            int[] p = partition(sourceArray, left, right);\n            quickSort(sourceArray, left, p[0] - 1);\n            quickSort(sourceArray, p[1] + 1, right);\n        }\n    }\n\n    public static int[] partition(int[] sourceArray, int left, int right) {\n        int less = left - 1;\n        int more = right;\n        while (left < more) {\n            if (sourceArray[left] < sourceArray[right]) {\n                swap(sourceArray, ++less, left++);\n            } else if (sourceArray[left] > sourceArray[right]) {\n                swap(sourceArray, --more, left);\n            } else {\n                left++;\n            }\n        }\n        swap(sourceArray, more, right);\n        return new int[] { less + 1, more };\n    }\n\n    public static void swap(int[] sourceArray, int left, int right) {\n        int tmp = sourceArray[left];\n        sourceArray[left] = sourceArray[right];\n        sourceArray[right] = tmp;\n    }"]],[3513,3513],[5552,5552]]],[1570455673365,["GJX@GJXAIOU",[[1,6896,"```"]],[6896,6896],[6899,6899]]],[1570455673397,["GJX@GJXAIOU",[[1,6899,"language\n```\n"]],[6899,6899],[6899,6907]]],[1570455674494,["GJX@GJXAIOU",[[-1,6899,"language"],[1,6907,"j"]],[6899,6907],[6900,6900]]],[1570455674972,["GJX@GJXAIOU",[[1,6900,"ava"]],[6900,6900],[6903,6903]]],[1570455675165,["GJX@GJXAIOU",[[1,6904,"\n"]],[6903,6903],[6904,6904]]],[1570455739681,["GJX@GJXAIOU",[[1,6904,"package sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-04-20:08\n */\nimport java.util.Arrays;\n\npublic class HeapSort {\n\n    public static void heapSort(int[] arr) {\n        if (arr == null || arr.length < 2) {\n            return;\n        }\n        // 首先将数组转化为大根堆；0 到  i 之间形成大根堆\n        for (int i = 0; i < arr.length; i++) {\n            heapInsert(arr, i);\n        }\n\n        // 不断将堆顶的元素和最后一个元素交换然后进行 heapify 过程\n        int size = arr.length;\n        swap(arr, 0, --size);\n        while (size > 0) {\n            heapify(arr, 0, size);\n            swap(arr, 0, --size);\n        }\n    }\n\n    public static void heapInsert(int[] arr, int index) {\n        // 如果插入的新节点值大于其父结点大小\n        while (arr[index] > arr[(index - 1) / 2]) {\n            swap(arr, index, (index - 1) / 2);\n            index = (index - 1) / 2;\n        }\n    }\n\n    /**\n     * size - 1 到 length - 1 位置上已经拍好\n     * @param arr：要排序的数组\n     * @param index：哪个节点位置上元素发生了变化，传入的初始值一直为0\n     * @param size：还没有排好序的数组长度\n     */\n    public static void heapify(int[] arr, int index, int size) {\n        // size 表示当前堆上节点数\n        int left = index * 2 + 1;\n        // 越界表示已经是叶子结点了\n        while (left < size) {\n            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;\n            largest = arr[largest] > arr[index] ? largest : index;\n            if (largest == index) {\n                break;\n            }\n            swap(arr, largest, index);\n            index = largest;\n            left = index * 2 + 1;\n        }\n    }\n\n    public static void swap(int[] arr, int left, int right) {\n        int tmp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = tmp;\n    }"]],[6904,6904],[8588,8588]]],[1570455742988,["GJX@GJXAIOU",[[1,8589,"    \n"]],[8588,8588],[8593,8593]]],[1570455745939,["GJX@GJXAIOU",[[1,8589,"}"]],[8589,8589],[8590,8590]]]],null,"GJX@GJXAIOU"],["3333c54a-635a-4556-ab4e-a3bd8c7bc376",1570541748609,"# AlgorithmEasyDay02\n\n**例题：**\n问题一：分割数组\n给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)；\n![示例]($resource/%E7%A4%BA%E4%BE%8B.png)\n其中 x 坐标为 L - 1，<=x 位置上放置的都是 <= num 值的数，然后依次向右遍历，如果该数大于 num，则 x 不动，直接判断下一个数，如果该数小于等于 num，则该数和 x + 1 位置上的数互换， x 向右移动一位，即 x + 1，然后继续判断下一个数；以此类推；\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-07-15:03\n */\npublic class SplitArray {\n    public static void sort(int[] sourceArray, int left, int right, int tagMum){\n        int less = left - 1;\n        while(left < right){\n            if(sourceArray[left] <= tagMum){\n                swap(sourceArray, left++, ++less);\n            }\n            if(sourceArray [left] > tagMum){\n                left++;\n            }\n        }\n        return ;\n    }\n\n    public static void swap(int[] sourceArray, int left, int right) {\n        if(left == right){\n            return;\n        }\n        sourceArray[left] = sourceArray[left] ^ sourceArray[right];\n        sourceArray[right] = sourceArray[left] ^ sourceArray[right];\n        sourceArray[left] = sourceArray[left] ^ sourceArray[right];\n    }\n\n    // 测试方法\n    public static void main(String[] args) {\n        int[] sourceArray ={1,2,8,4,9,3,1,4,3,2,7};\n        int left = 0;\n        int right = sourceArray.length - 1;\n        int tagMum = 6;\n\n        System.out.println(\"原数组为：\");\n        for (int i : sourceArray) {\n            System.out.print(i + \" \");\n        }\n\n        sort(sourceArray, left, right, tagMum);\n\n        System.out.println(\"\\n分割之后数组为：\");\n        for (int i : sourceArray) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n\n```\n\n\n问题二（荷兰国旗问题）\n给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)\n![示例2]($resource/%E7%A4%BA%E4%BE%8B2.png)\n\nx 坐标为 L - 1，y 坐标为 R + 1，两边分别表示小于 num 和大于 num 的值，当前位置坐标为 cur，然后依次向右遍历，如果该数小于 num，则该数和小于区域最右边下标（x）的下一个坐标元素交换，小于区域向右扩充（即 x + 1），如果该数等于 num ,则 cur 指向下一个元素，如果大于 num，则该数和大于区域最左边区域的前一个坐标元素交换，大于区域向左扩充一个（即 y - 1），然后这里**交换回来的数还需要按照上面的标准进行判断**，直到 cur 和 又边界相遇停止；\n\n```java\npackage sort.nowcoder.easy.day01;\n\npublic class NetherlandsFlag {\n\t/**\n\t * @param sourceArray：要分割的数组\n\t * @param left：小于 tagNum 区域最右边数\n\t * @param right：大于 tagNum 区域最左边数\n\t * @param tagNum：用于分割的参考数字\n\t * @return\n\t */\n\tpublic static int[] partition(int[] sourceArray, int left, int right, int tagNum) {\n\t\t// less 表示小于 tagNum 区域最右边数，more 是大于 tagNum 区域最左边数\n\t\tint less = left - 1;\n\t\tint more = right + 1;\n\t\twhile (left < more) {\n\t\t\tif (sourceArray[left] < tagNum) {\n\t\t\t\tswap(sourceArray, ++less, left++);\n\t\t\t} else if (sourceArray[left] > tagNum) {\n\t\t\t\tswap(sourceArray, --more, left);\n\t\t\t} else {\n\t\t\t\tleft++;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { less + 1, more - 1 };\n\t}\n\t\n\tpublic static void swap(int[] sourceArray, int left, int right) {\n\t\tint tmp = sourceArray[left];\n\t\tsourceArray[left] = sourceArray[right];\n\t\tsourceArray[right] = tmp;\n\t}\n}\n```\n\n\n\n## 二、快速排序\n### 经典快排\n首先以数组最后一个数值为基准，将小于等于该数值的全部放在数组前半部分，大于该数值的全部放在数组的后半部分，然后前半部分和后半部分分别以该部分最后一个元素为基准重复以上步骤；\n\n**改进**：使用荷兰国旗思想\n首先还是选取数组最后一个值为基准，但是遍历判断的时候最后一个值不再进行判断，即只有 L ~ R - 1 的值与基准进行比较，同时区域划分为三个区域：小于基准、等于基准、大于基准；然后将小于基准和大于基准部分进行再次取最后一个数，同上进行比较.....最后全部比较结束之后，将最后一个基准值放在大于该基准的范围的前一个位置；\n\n\n特点：\n- 经典快排和数据的状态有关：\n  - 当小于最后一个数值的元素远大于大于最后一个数组的元素个数时候，或者反之情况，时间复杂度都是：$O({N}^{2})$\n  - 如果数据状态较好，即大于和小于差不多的情况下，时间复杂度为：$T(N) = 2T(\\frac{N}{2}) + O(N) = O(N * log_{2}^{N})$\n\n经典快排的空间复杂度为：$O(N)$\n\n### 随机快速排序\n通过随机选一个数和最后一个数进行互换，使得每次划分标准都在改变；\n根据随机性，随机快速排序的时间复杂度是：$O(N * \\log_{2}^{N})$，同时需要空间复杂度为：$O(\\log_{2}^{N})$，这里的额外空间主要用于记录每次划分区域的断点；\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-04-20:08\n */\n\nimport java.util.Arrays;\n\npublic class QuickSort {\n    /**\n     *  首先调用该方法，可以设置排序的区间，默认为 0 ~ length-1；\n     * @param sourceArray：需要排序的数组\n     */\n    public static void quickSort(int[] sourceArray) {\n        if (sourceArray == null || sourceArray.length < 2) {\n            return;\n        }\n        quickSort(sourceArray, 0, sourceArray.length - 1);\n    }\n\n    /**\n     * @param sourceArray：需要排序的数组\n     * @param left：排序数组左边界，一般为：0\n     * @param right：排序数组右边界，一般为：length - 1;\n     *  less：小于参照元素区域的最右边边界：less = p[0] - 1;\n     *  more：大于参照元素区域的最左边边界：more = p[1] + 1;\n     *  p[0]：等于参照元素区域的最左边边界；\n     *  p[1]：等于参数元素区域的最右边边界；\n     *  小于参照元素区域：[Left ~ less];\n     *  等于参照元素区域：[p[0] ~ p[1]]；\n     *  大于参照元素区域：[more ~ right]；\n     */\n    public static void quickSort(int[] sourceArray, int left, int right) {\n        if (left < right) {\n            swap(sourceArray, left + (int) (Math.random() * (right - left + 1)), right);\n            // p 数组中： p[0] 表示等于区域的左边界，p[1] 表示等于区域的右边界，\n            // 左边区域：L ~ p[0] - 1;右边区域： p[1] + 1 ~ R;\n            int[] p = partition(sourceArray, left, right);\n            quickSort(sourceArray, left, p[0] - 1);\n            quickSort(sourceArray, p[1] + 1, right);\n        }\n    }\n\n    public static int[] partition(int[] sourceArray, int left, int right) {\n        int less = left - 1;\n        int more = right;\n        while (left < more) {\n            if (sourceArray[left] < sourceArray[right]) {\n                swap(sourceArray, ++less, left++);\n            } else if (sourceArray[left] > sourceArray[right]) {\n                swap(sourceArray, --more, left);\n            } else {\n                left++;\n            }\n        }\n        swap(sourceArray, more, right);\n        return new int[] { less + 1, more };\n    }\n\n    public static void swap(int[] sourceArray, int left, int right) {\n        int tmp = sourceArray[left];\n        sourceArray[left] = sourceArray[right];\n        sourceArray[right] = tmp;\n    }\n```\n\n\n\n\n## 堆排序\n\n### 堆\n堆是一个完全二叉树，可以采用数组进行实现；\n对于完全二叉树，结点 i 的左孩子序号为：2i + 1；右孩子序号为：2i + 2；父结点的序号为：$\\frac{i - 1}{2}$，\n\n分类：\n- 大根堆：每棵树（包括任意一棵子树）的最大值都是其头部（父结点）；\n- 小根堆：每棵树（包括任意一棵子树）的最小值都是其头部（父结点）；\n\n**完全二叉树**：对一棵具有 n 个节点的二叉树按照层序进行编号，如果编号 i （1<=i<=n）的结点与同样深度的满二叉树中编号为 i 的结点位置完全相同；\n**满二叉树**：所有的分支结点都存在左子树和右子树，且所有的叶子都在同一层；\n\n### 数组转换为大根堆\n以数组 [2,1,3,6,0,4]为例：\n首先取出第一元素 2，然后取出第二个元素 1，该元素比 2 小，放在左孩子位置，数组元素为：[2,1]；然后取出第三个元素 3，计算该元素的父结点：$\\frac{2 - 1}{2} = 0$，则与 0 位置元素 2 进行比较，发现 3 比较大，则在数组中将 3 和 2 两个元素互换，则数组变为：[3,1,2]；然后取出第四个元素 6，计算父结点下标为：$\\frac{3 - 1}{2} = 1$，则与 1 位置的元素 1 进行比较，发现 6 比较大，则将元素 1 和元素 6 互换，得到[3,6,2,1]，然后再比较元素 6 和其父结点：$\\frac{1 - 1}{2} = 0$，比较得出 6 比 3 大，然后再换，最后得到数组为：[6,3,2,1]，剩下元素依次类推......\n\n每加入一个节点其最多比较的次数和已经形成的二叉树高度有关（因为每次只和其父结点比较），因此最多时间复杂度为：$O(log_{2}^{N})$，所有整个转换过程时间复杂度为：$log_{2}^{1} + log_{2}^{2} + ..... + log_{2}^{N} = O(N)$\n\n\n**题目**\n吐泡泡：一个 XXX 会不停的吐出数字，求任意时刻的已经吐出的所有元素的中位数；\n\n**解答：**\n这里需要同时使用大根堆和小根堆，大根堆中存放着较小的 $\\frac{N}{2}$个元素，小根堆中存放较大的  $\\frac{N}{2}$个元素；\n\n这里以：5 4 6 7 为例\n首先将 5 放入大根堆，计算大根堆和小根堆的 Heapsize，插值为 1,不动， 然后因为 4 小于等于大根堆的堆顶，因此放入大根堆，再次计算 HeapSize，插值 > 1，然后将大根堆的堆顶放在小根堆，然后将大根堆剩余的调整为大根堆，然后元素 6 大于大根堆现在堆顶 4，因此放入小根堆；现在大根堆为 4，小根堆为 5,6；插值为 1，然后放入元素 7，同样大于大根堆堆顶，放入小根堆，然后插值> 1，将小根堆的堆顶放入大根堆末尾，小根堆重新排为：6,7；大根堆重新排为：5,4；中位数就是两个堆顶的平均值；\n\n\n### 堆排序\n首先将数组变成大根堆；\n然后将堆中最后一个和堆顶进行交换，堆大小减一，则最后一个不动了，然后将剩下的前面进行 Heapify 调整；\n然后再将堆的最后一个和堆顶进行交换，同上.....;\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-04-20:08\n */\nimport java.util.Arrays;\n\npublic class HeapSort {\n\n    public static void heapSort(int[] arr) {\n        if (arr == null || arr.length < 2) {\n            return;\n        }\n        // 首先将数组转化为大根堆；0 到  i 之间形成大根堆\n        for (int i = 0; i < arr.length; i++) {\n            heapInsert(arr, i);\n        }\n\n        // 不断将堆顶的元素和最后一个元素交换然后进行 heapify 过程\n        int size = arr.length;\n        swap(arr, 0, --size);\n        while (size > 0) {\n            heapify(arr, 0, size);\n            swap(arr, 0, --size);\n        }\n    }\n\n    public static void heapInsert(int[] arr, int index) {\n        // 如果插入的新节点值大于其父结点大小\n        while (arr[index] > arr[(index - 1) / 2]) {\n            swap(arr, index, (index - 1) / 2);\n            index = (index - 1) / 2;\n        }\n    }\n\n    /**\n     * size - 1 到 length - 1 位置上已经拍好\n     * @param arr：要排序的数组\n     * @param index：哪个节点位置上元素发生了变化，传入的初始值一直为0\n     * @param size：还没有排好序的数组长度\n     */\n    public static void heapify(int[] arr, int index, int size) {\n        // size 表示当前堆上节点数\n        int left = index * 2 + 1;\n        // 越界表示已经是叶子结点了\n        while (left < size) {\n            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;\n            largest = arr[largest] > arr[index] ? largest : index;\n            if (largest == index) {\n                break;\n            }\n            swap(arr, largest, index);\n            index = largest;\n            left = index * 2 + 1;\n        }\n    }\n\n    public static void swap(int[] arr, int left, int right) {\n        int tmp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = tmp;\n    }\n}    \n```\n\n\n**概念：**\n- HeapInsert：将新的节点加入堆中同时按照堆的结构进行向上调整的过程；\n-  HeapSize：堆的大小；对应数组中就是 0-i 位置;\n- Heapify：假设堆中（数组中）某个值发生了变化，让其整体再次调整为大根堆（或小根堆）原来的样子的过程；\n  首先找到变化的值的两个孩子，然后找到其中较大的一个与之交换，如果有交换，在新的位置上再次找现在的两个孩子进行比较，然后交换，一直到没有交换为止；\n- 堆减小的过程：以大根堆为例：首先将堆顶元素和堆的最后一个元素位置互换，这样原来堆顶的元素就放在了数组的最后，然后将堆的 Heapsize - 1，这样最后一个元素就应为超过了现在的 HeapSize 而越界，从而失效；然后将剩余的 0 ~ i - 1 位置的按照 Heapify 重新进行调整（因为堆顶的元素值发生了变化）为原来的堆结构；",[[1570541689100,["GJX@GJXAIOU",[[1,8985,"\n- "]],[8985,8985],[8988,8988]]],[1570541689285,["GJX@GJXAIOU",[[-1,8986,"- "],[1,8988,"\n\n"]],[8988,8988],[8987,8987]]],[1570541689458,["GJX@GJXAIOU",[[1,8988,"\n"]],[8987,8987],[8988,8988]]],[1570541689645,["GJX@GJXAIOU",[[1,8989,"\n"]],[8988,8988],[8989,8989]]],[1570541703165,["GJX@GJXAIOU",[[1,8988,"## 排序算法那的"]],[8988,8988],[8997,8997]]],[1570541704661,["GJX@GJXAIOU",[[-1,8993,"算法那的"]],[8997,8997],[8993,8993]]],[1570541707807,["GJX@GJXAIOU",[[1,8993,"算法的稳定性"]],[8993,8993],[8999,8999]]],[1570541710532,["GJX@GJXAIOU",[[1,9001,"\n"]],[8999,8999],[9000,9000]]],[1570541732603,["GJX@GJXAIOU",[[1,9002,"\n"]],[9000,9000],[9001,9001]]],[1570541743887,["GJX@GJXAIOU",[[1,9001,"首先总结现有排序算法稳定性"]],[9001,9001],[9014,9014]]],[1570541744155,["GJX@GJXAIOU",[[1,9016,"\n"]],[9014,9014],[9015,9015]]],[1570541778901,["GJX@GJXAIOU",[[1,9015,"算法那"]],[9015,9015],[9018,9018]]],[1570541779362,["GJX@GJXAIOU",[[-1,9017,"那"]],[9018,9018],[9017,9017]]],[1570541782189,["GJX@GJXAIOU",[[1,9017,"名称 | "]],[9017,9017],[9022,9022]]],[1570542587862,["GJX@GJXAIOU",[[1,9022,"时间复杂度 | 算法种类 | 原因"]],[9022,9022],[9039,9039]]],[1570542588350,["GJX@GJXAIOU",[[1,9041,"\n"]],[9039,9039],[9040,9040]]],[1570542594244,["GJX@GJXAIOU",[[1,9040,"---|---|---|---"]],[9040,9040],[9055,9055]]],[1570542596027,["GJX@GJXAIOU",[[1,9056,"   |   |   |   \n"]],[9055,9055],[9056,9059]]],[1570542602295,["GJX@GJXAIOU",[[-1,9056,"   "],[1,9059,"冒泡"]],[9056,9056],[9058,9058]]],[1570542603228,["GJX@GJXAIOU",[[1,9058,"排序"]],[9058,9058],[9060,9060]]],[1570542607732,["GJX@GJXAIOU",[[-1,9061,"   "],[1,9064,"O"]],[9061,9064],[9062,9062]]],[1570542608752,["GJX@GJXAIOU",[[1,9062,"()"]],[9062,9062],[9064,9064]]],[1570542615662,["GJX@GJXAIOU",[[1,9061,"$"]],[9061,9061],[9062,9062]]],[1570542618778,["GJX@GJXAIOU",[[1,9065,"$"]],[9065,9065],[9066,9066]]],[1570542620922,["GJX@GJXAIOU",[[1,9064,"N"]],[9064,9064],[9065,9065]]],[1570542622019,["GJX@GJXAIOU",[[-1,9064,"N"]],[9065,9065],[9064,9064]]],[1570542624549,["GJX@GJXAIOU",[[1,9064,"{N "]],[9064,9064],[9067,9067]]],[1570542625627,["GJX@GJXAIOU",[[-1,9066," "]],[9067,9067],[9066,9066]]],[1570542629235,["GJX@GJXAIOU",[[1,9066,"}……{"]],[9066,9066],[9070,9070]]],[1570542632121,["GJX@GJXAIOU",[[-1,9067,"……"]],[9069,9069],[9067,9067]]],[1570542633443,["GJX@GJXAIOU",[[1,9067,"……"]],[9067,9067],[9069,9069]]],[1570542634324,["GJX@GJXAIOU",[[-1,9066,"}……"]],[9069,9069],[9066,9066]]],[1570542636595,["GJX@GJXAIOU",[[1,9066,"}^"]],[9066,9066],[9068,9068]]],[1570542639489,["GJX@GJXAIOU",[[1,9069,"2}"]],[9069,9069],[9071,9071]]],[1570542652069,["GJX@GJXAIOU",[[-1,9074,"   "],[1,9077,"基于"]],[9074,9074],[9076,9076]]],[1570542657742,["GJX@GJXAIOU",[[1,9076,"比较"]],[9076,9076],[9078,9078]]],[1570542659699,["GJX@GJXAIOU",[[-1,9079,"   "],[1,9082,"\n"]],[9079,9082],[9080,9080]]],[1570542677513,["GJX@GJXAIOU",[[1,9080,"插入排序|$O({N}^{2})$|基于比较|"]],[9080,9080],[9103,9103]]],[1570542679210,["GJX@GJXAIOU",[[1,9104,"   |   |   |   \n"]],[9103,9103],[9104,9107]]],[1570542683813,["GJX@GJXAIOU",[[-1,9104,"   "],[1,9107,"选择"]],[9104,9104],[9106,9106]]],[1570542684700,["GJX@GJXAIOU",[[1,9106,"排序"]],[9106,9106],[9108,9108]]],[1570542691067,["GJX@GJXAIOU",[[-1,9109,"   |   |   "],[1,9120,"$O({N}^{2})$|基于比较|"]],[9109,9120],[9127,9127]]],[1570542692116,["GJX@GJXAIOU",[[1,9128,"   |   |   |   \n"]],[9127,9127],[9128,9131]]],[1570542696012,["GJX@GJXAIOU",[[-1,9128,"   "],[1,9131,"归并"]],[9128,9128],[9130,9130]]],[1570542696840,["GJX@GJXAIOU",[[1,9130,"排序"]],[9130,9130],[9132,9132]]],[1570542724164,["GJX@GJXAIOU",[[1,9037,"是否可以"]],[9037,9037],[9041,9041]]],[1570542726834,["GJX@GJXAIOU",[[-1,9039,"可以"]],[9041,9041],[9039,9039]]],[1570542728991,["GJX@GJXAIOU",[[1,9039,"稳定 | "]],[9039,9039],[9044,9044]]],[1570542734029,["GJX@GJXAIOU",[[1,9062,"|---"]],[9062,9062],[9066,9066]]],[1570542743332,["GJX@GJXAIOU",[[1,9090,"可以稳定 |"]],[9090,9090],[9096,9096]]],[1570542748285,["GJX@GJXAIOU",[[1,9120," 可以稳定|"]],[9120,9120],[9126,9126]]],[1570542750739,["GJX@GJXAIOU",[[-1,9120," "]],[9121,9121],[9120,9120]]],[1570542752989,["GJX@GJXAIOU",[[1,9124," "]],[9124,9124],[9125,9125]]],[1570542758010,["GJX@GJXAIOU",[[1,9150," 不稳定 |"]],[9150,9150],[9156,9156]]],[1570542769378,["GJX@GJXAIOU",[[-1,9162," "],[1,9163,"$O({N}^{2})$"]],[9162,9163],[9174,9174]]],[1570542778313,["GJX@GJXAIOU",[[1,9165,"N * logn"]],[9165,9165],[9173,9173]]],[1570542779008,["GJX@GJXAIOU",[[-1,9172,"n"]],[9173,9173],[9172,9172]]],[1570542781338,["GJX@GJXAIOU",[[1,9172,"_x"]],[9172,9172],[9174,9174]]],[1570542782643,["GJX@GJXAIOU",[[-1,9173,"x"]],[9174,9174],[9173,9173]]],[1570542785537,["GJX@GJXAIOU",[[-1,9173,"{N}^{2}"]],[9180,9180],[9173,9173]]],[1570542792235,["GJX@GJXAIOU",[[1,9173,"{2}^{N}"]],[9173,9173],[9180,9180]]],[1570542798675,["GJX@GJXAIOU",[[-1,9183," "]],[9184,9184],[9183,9183]]],[1570542802590,["GJX@GJXAIOU",[[1,9184,"基于比较"]],[9184,9184],[9188,9188]]],[1570542804473,["GJX@GJXAIOU",[[-1,9190," "]],[9190,9190],[9189,9189]]],[1570542809306,["GJX@GJXAIOU",[[1,9191,"稳定"]],[9191,9191],[9193,9193]]],[1570542809920,["GJX@GJXAIOU",[[-1,9191,"稳定"]],[9193,9193],[9191,9191]]],[1570542811583,["GJX@GJXAIOU",[[1,9191,"可以稳定"]],[9191,9191],[9195,9195]]],[1570542812058,["GJX@GJXAIOU",[[1,9195,"\n"]],[9195,9195],[9196,9196]]],[1570542813233,["GJX@GJXAIOU",[[-1,9195,"\n"]],[9196,9196],[9195,9195]]],[1570542813994,["GJX@GJXAIOU",[[1,9198," "]],[9195,9195],[9196,9196]]],[1570542814355,["GJX@GJXAIOU",[[1,9196,"|"]],[9196,9196],[9197,9197]]],[1570542814989,["GJX@GJXAIOU",[[1,9197,"\n"]],[9197,9197],[9198,9198]]],[1570542818904,["GJX@GJXAIOU",[[1,9198,"库阿斯"]],[9198,9198],[9201,9201]]],[1570542819615,["GJX@GJXAIOU",[[-1,9198,"库阿斯"]],[9201,9201],[9198,9198]]],[1570542822541,["GJX@GJXAIOU",[[1,9198,"快速排序"]],[9198,9198],[9202,9202]]],[1570542823302,["GJX@GJXAIOU",[[1,9205," "]],[9202,9202],[9203,9203]]],[1570542823693,["GJX@GJXAIOU",[[1,9203,"|"]],[9203,9203],[9204,9204]]],[1570542823899,["GJX@GJXAIOU",[[1,9207," "]],[9204,9204],[9205,9205]]],[1570542831331,["GJX@GJXAIOU",[[1,9205,"$O(N * log_{2}^{N})$ |基于比较  |可以稳定 |"]],[9205,9205],[9240,9240]]],[1570542835722,["GJX@GJXAIOU",[[-1,9234,"可以"]],[9236,9236],[9234,9234]]],[1570542837431,["GJX@GJXAIOU",[[1,9234,"不"]],[9234,9234],[9235,9235]]],[1570542840519,["GJX@GJXAIOU",[[1,9237,"（）"]],[9237,9237],[9239,9239]]],[1570542844555,["GJX@GJXAIOU",[[1,9238,"也可以稳定"]],[9238,9238],[9243,9243]]],[1570542846713,["GJX@GJXAIOU",[[1,9246,"\n"]],[9246,9246],[9247,9247]]],[1570542850805,["GJX@GJXAIOU",[[1,9247,"堆排序"]],[9247,9247],[9250,9250]]],[1570542851267,["GJX@GJXAIOU",[[1,9253," "]],[9250,9250],[9251,9251]]],[1570542851693,["GJX@GJXAIOU",[[1,9251,"|"]],[9251,9251],[9252,9252]]],[1570542851894,["GJX@GJXAIOU",[[1,9255," "]],[9252,9252],[9253,9253]]],[1570542860752,["GJX@GJXAIOU",[[1,9253,"$O(N * log_{2}^{N})$ |基于比较  |不稳定（也可以稳定） | "]],[9252,9252],[9294,9294]]],[1570542869987,["GJX@GJXAIOU",[[-1,9285,"（也可以稳定）"]],[9285,9292],[9285,9285]]],[1570542878178,["GJX@GJXAIOU",[[1,9292,"   |   |   |   |   \n"]],[9291,9291],[9292,9295]]],[1570542884716,["GJX@GJXAIOU",[[-1,9292,"   "],[1,9295,"桶排序"]],[9292,9292],[9295,9295]]],[1570542894163,["GJX@GJXAIOU",[[-1,9296,"   "],[1,9299,"￥"]],[9296,9296],[9297,9297]]],[1570542894664,["GJX@GJXAIOU",[[-1,9296,"￥"]],[9297,9297],[9296,9296]]],[1570542896364,["GJX@GJXAIOU",[[1,9296,"$$"]],[9296,9296],[9298,9298]]],[1570542899456,["GJX@GJXAIOU",[[1,9297,"O()"]],[9297,9297],[9300,9300]]],[1570542900881,["GJX@GJXAIOU",[[1,9299,"N"]],[9299,9299],[9300,9300]]],[1570542909366,["GJX@GJXAIOU",[[1,9303,"非基于比较"]],[9303,9303],[9308,9308]]],[1570542911648,["GJX@GJXAIOU",[[-1,9309,"  "]],[9310,9310],[9308,9308]]],[1570542914420,["GJX@GJXAIOU",[[1,9310,"稳定"]],[9310,9310],[9312,9312]]],[1570542917098,["GJX@GJXAIOU",[[-1,9313,"  "]],[9315,9315],[9313,9313]]],[1570542920584,["GJX@GJXAIOU",[[-1,9090,"可以"]],[9092,9092],[9090,9090]]],[1570542922394,["GJX@GJXAIOU",[[-1,9118,"可以"]],[9120,9120],[9118,9118]]],[1570542924675,["GJX@GJXAIOU",[[-1,9187,"可以"]],[9189,9189],[9187,9187]]],[1570542929186,["GJX@GJXAIOU",[[1,9312,"   |   |   |   |   \n"]],[9311,9311],[9312,9315]]],[1570542941085,["GJX@GJXAIOU",[[-1,9312,"   "],[1,9315,"基数"]],[9312,9312],[9314,9314]]],[1570542942141,["GJX@GJXAIOU",[[1,9314,"排序"]],[9314,9314],[9316,9316]]],[1570542959601,["GJX@GJXAIOU",[[-1,9317,"   |   |  "],[1,9327,"$O(N)$|非基于比较 |稳定"],[-1,9333,"\n"]],[9317,9333],[9338,9338]]],[1570542961059,["GJX@GJXAIOU",[[1,9339,"   |   |   |   |   \n"]],[9338,9338],[9339,9342]]],[1570542969539,["GJX@GJXAIOU",[[-1,9339,"   "],[1,9342,"计数排序"]],[9339,9339],[9343,9343]]],[1570542976300,["GJX@GJXAIOU",[[-1,9344,"   |   |  "],[1,9354,"$O(N)$|非基于比较 |稳定"]],[9344,9359],[9365,9365]]],[1570543047183,["GJX@GJXAIOU",[[1,9094,"在摸排"]],[9094,9094],[9097,9097]]],[1570543047920,["GJX@GJXAIOU",[[-1,9095,"摸排"]],[9097,9097],[9095,9095]]],[1570543065738,["GJX@GJXAIOU",[[1,9095,"冒泡的时候，如果遇到前后相同的值两者"]],[9095,9095],[9113,9113]]],[1570543074571,["GJX@GJXAIOU",[[1,9113,"不交换即可，只有前后"]],[9113,9113],[9123,9123]]],[1570543075153,["GJX@GJXAIOU",[[-1,9122,"后"]],[9123,9123],[9122,9122]]],[1570543084316,["GJX@GJXAIOU",[[1,9122,"者比后者大才交换；"]],[9122,9122],[9131,9131]]],[1570543181371,["GJX@GJXAIOU",[[1,9159,"同样在比较的时候，相同的值不交换即可；"]],[9159,9159],[9178,9178]]],[1570543207615,["GJX@GJXAIOU",[[1,9208,"因为是选择"]],[9208,9208],[9213,9213]]],[1570543219299,["GJX@GJXAIOU",[[-1,9210,"是选择"]],[9213,9213],[9210,9210]]],[1570543246100,["GJX@GJXAIOU",[[1,9210,"如果后面有小于前面的，就和前面的互换，如果有几个相同数，则相当远"]],[9210,9210],[9242,9242]]],[1570543246553,["GJX@GJXAIOU",[[-1,9241,"远"]],[9242,9242],[9241,9241]]],[1570543247710,["GJX@GJXAIOU",[[1,9241,"于和"]],[9241,9241],[9243,9243]]],[1570543267504,["GJX@GJXAIOU",[[1,9243,"最前面的数进行互换，这样顺序就乱了；"]],[9243,9243],[9261,9261]]],[1570543287698,["GJX@GJXAIOU",[[1,9300,"以为归并之前的"]],[9300,9300],[9307,9307]]],[1570543288040,["GJX@GJXAIOU",[[-1,9306,"的"]],[9307,9307],[9306,9306]]],[1570543293837,["GJX@GJXAIOU",[[1,9306,"是左右两个数组，坐标"]],[9306,9306],[9316,9316]]],[1570543295712,["GJX@GJXAIOU",[[-1,9314,"坐标"]],[9316,9316],[9314,9314]]],[1570543297132,["GJX@GJXAIOU",[[1,9314,"坐标"]],[9314,9314],[9316,9316]]],[1570543297777,["GJX@GJXAIOU",[[-1,9314,"坐标"]],[9316,9316],[9314,9314]]],[1570543306412,["GJX@GJXAIOU",[[1,9314,"左边数组都是小的，"]],[9314,9314],[9323,9323]]],[1570543320194,["GJX@GJXAIOU",[[-1,9318,"都是小的，"]],[9323,9323],[9318,9318]]],[1570543345850,["GJX@GJXAIOU",[[1,9318,"在原数组中就是在左边，右边数组原来就是右边，这样只需要如果左右来个"]],[9318,9318],[9351,9351]]],[1570543346577,["GJX@GJXAIOU",[[-1,9349,"来个"]],[9351,9351],[9349,9349]]],[1570543354879,["GJX@GJXAIOU",[[1,9349,"两个数组中有仙童的"]],[9349,9349],[9358,9358]]],[1570543356150,["GJX@GJXAIOU",[[-1,9355,"仙童的"]],[9358,9358],[9355,9355]]],[1570543358286,["GJX@GJXAIOU",[[1,9355,"相同的额数组"]],[9355,9355],[9361,9361]]],[1570543359034,["GJX@GJXAIOU",[[-1,9358,"额数组"]],[9361,9361],[9358,9358]]],[1570543366812,["GJX@GJXAIOU",[[1,9358,"数字，则只需要将"]],[9358,9358],[9366,9366]]],[1570543405176,["GJX@GJXAIOU",[[-1,9365,"将"]],[9366,9366],[9365,9365]]],[1570543421482,["GJX@GJXAIOU",[[1,9365,"先拷贝左边数组值，然后拷贝右边数组中值即可；"]],[9365,9365],[9387,9387]]],[1570543504534,["GJX@GJXAIOU",[[1,9436,"因为"]],[9436,9436],[9438,9438]]],[1570543561742,["GJX@GJXAIOU",[[1,9438," partition 过程就是交换，坑定"]],[9438,9438],[9458,9458]]],[1570543562818,["GJX@GJXAIOU",[[-1,9456,"坑定"]],[9458,9458],[9456,9456]]],[1570543566571,["GJX@GJXAIOU",[[1,9456,"肯定是无需"]],[9456,9456],[9461,9461]]],[1570543567775,["GJX@GJXAIOU",[[-1,9459,"无需"]],[9461,9461],[9459,9459]]],[1570543571554,["GJX@GJXAIOU",[[1,9459,"无序的；"]],[9459,9459],[9463,9463]]],[1570543611714,["GJX@GJXAIOU",[[1,9589,"   |   |   |   |   \n"]],[9588,9588],[9589,9592]]],[1570543611854,["GJX@GJXAIOU",[[1,9589,"\n"]],[9589,9592],[9593,9593]]],[1570543613054,["GJX@GJXAIOU",[[1,9593,"\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   "]],[9593,9593],[9633,9633]]],[1570543619338,["GJX@GJXAIOU",[[1,9505,"不行，"]],[9505,9505],[9508,9508]]],[1570543621528,["GJX@GJXAIOU",[[-1,9505,"不行，"]],[9508,9508],[9505,9505]]],[1570543641188,["GJX@GJXAIOU",[[1,9505,"因为在形成大根堆的时候，叶子结点主键"]],[9505,9505],[9523,9523]]],[1570543643721,["GJX@GJXAIOU",[[-1,9521,"主键"]],[9523,9523],[9521,9521]]],[1570543846477,["GJX@GJXAIOU",[[1,9521,"与根节点进行交换的时候就会序号乱，"]],[9521,9521],[9538,9538]]],[1570543863836,["GJX@GJXAIOU",[[1,9538,"例如：2，"]],[9538,9538],[9543,9543]]],[1570543864045,["GJX@GJXAIOU",[[-1,9542,"，"]],[9543,9543],[9542,9542]]],[1570543864138,["GJX@GJXAIOU",[[1,9542,",3"]],[9542,9542],[9544,9544]]],[1570543864975,["GJX@GJXAIOU",[[-1,9543,"3"]],[9544,9544],[9543,9543]]],[1570543865662,["GJX@GJXAIOU",[[1,9543,"，3"]],[9543,9543],[9545,9545]]],[1570543866409,["GJX@GJXAIOU",[[-1,9543,"，3"]],[9545,9545],[9543,9543]]],[1570543867811,["GJX@GJXAIOU",[[1,9543,"2，"]],[9543,9543],[9545,9545]]],[1570543868039,["GJX@GJXAIOU",[[-1,9544,"，"]],[9545,9545],[9544,9544]]],[1570543869896,["GJX@GJXAIOU",[[1,9544,",3，方"]],[9544,9544],[9548,9548]]],[1570543870967,["GJX@GJXAIOU",[[-1,9545,"3，方"]],[9548,9548],[9545,9545]]],[1570543876602,["GJX@GJXAIOU",[[1,9545,"3；当放入"]],[9545,9545],[9550,9550]]],[1570543879251,["GJX@GJXAIOU",[[1,9553," "]],[9550,9550],[9551,9551]]],[1570543879450,["GJX@GJXAIOU",[[1,9551,"3"]],[9551,9551],[9552,9552]]],[1570543879613,["GJX@GJXAIOU",[[1,9555," "]],[9552,9552],[9553,9553]]],[1570543884812,["GJX@GJXAIOU",[[1,9553,"的时候，连个"]],[9553,9553],[9559,9559]]],[1570543885425,["GJX@GJXAIOU",[[-1,9557,"连个"]],[9559,9559],[9557,9557]]],[1570543887395,["GJX@GJXAIOU",[[1,9557,"两个2"]],[9557,9557],[9560,9560]]],[1570543887429,["GJX@GJXAIOU",[[1,9559," "]],[9560,9560],[9561,9561]]],[1570543887578,["GJX@GJXAIOU",[[1,9564," "]],[9561,9561],[9562,9562]]],[1570543894541,["GJX@GJXAIOU",[[1,9562,"的顺序就改变了；"]],[9562,9562],[9570,9570]]],[1570543927949,["GJX@GJXAIOU",[[1,9661,"****"]],[9661,9661],[9663,9663]]],[1570543990369,["GJX@GJXAIOU",[[1,9663,"排序问题补充："]],[9663,9663],[9670,9670]]],[1570543992281,["GJX@GJXAIOU",[[1,9672,"\n  "]],[9672,9672],[9675,9675]]],[1570544129493,["GJX@GJXAIOU",[[1,9680,"归并排序的空间复杂度可以变成 ）"]],[9680,9680],[9696,9696]]],[1570544129975,["GJX@GJXAIOU",[[-1,9695,"）"]],[9696,9696],[9695,9695]]],[1570544147694,["GJX@GJXAIOU",[[1,9695,"O(1)，可以采用 “归并排序"]],[9695,9695],[9710,9710]]],[1570544158890,["GJX@GJXAIOU",[[1,9710," 内部缓存法”"]],[9710,9710],[9717,9717]]],[1570544259302,["GJX@GJXAIOU",[[1,9717,"师兄那"]],[9717,9717],[9720,9720]]],[1570544260248,["GJX@GJXAIOU",[[-1,9717,"师兄那"]],[9720,9720],[9717,9717]]],[1570544268040,["GJX@GJXAIOU",[[1,9717,"实现，但是仅仅要求"]],[9717,9717],[9726,9726]]],[1570544268943,["GJX@GJXAIOU",[[1,9726,"来哦"]],[9726,9726],[9728,9728]]],[1570544270034,["GJX@GJXAIOU",[[-1,9726,"来哦"]],[9728,9728],[9726,9726]]],[1570544274187,["GJX@GJXAIOU",[[1,9726,"了解即可；"]],[9726,9726],[9731,9731]]],[1570544274551,["GJX@GJXAIOU",[[1,9763,"\n   "]],[9731,9731],[9735,9735]]],[1570544277227,["GJX@GJXAIOU",[[-1,9678,"  "]],[9680,9680],[9678,9678]]],[1570544278197,["GJX@GJXAIOU",[[1,9678,"- "]],[9678,9678],[9680,9680]]],[1570544280193,["GJX@GJXAIOU",[[-1,9677," "]],[9678,9678],[9677,9677]]],[1570544282123,["GJX@GJXAIOU",[[1,9731,"-"]],[9731,9731],[9732,9732]]],[1570544282230,["GJX@GJXAIOU",[[1,9735," "]],[9732,9732],[9733,9733]]],[1570544326614,["GJX@GJXAIOU",[[1,9734,"快速排序可以做到"]],[9734,9734],[9742,9742]]],[1570544336788,["GJX@GJXAIOU",[[1,9742,"稳定性，采用“）1"]],[9742,9742],[9751,9751]]],[1570544337410,["GJX@GJXAIOU",[[-1,9749,"）1"]],[9751,9751],[9749,9749]]],[1570544338545,["GJX@GJXAIOU",[[1,9749,"01"]],[9749,9749],[9751,9751]]],[1570544339250,["GJX@GJXAIOU",[[1,9753," "]],[9751,9751],[9752,9752]]],[1570544340664,["GJX@GJXAIOU",[[1,9752,"stq"]],[9752,9752],[9755,9755]]],[1570544341368,["GJX@GJXAIOU",[[-1,9754,"q"]],[9755,9755],[9754,9754]]],[1570544341865,["GJX@GJXAIOU",[[1,9754,"at"]],[9754,9754],[9756,9756]]],[1570544342706,["GJX@GJXAIOU",[[-1,9755,"t"]],[9756,9756],[9755,9755]]],[1570544343131,["GJX@GJXAIOU",[[1,9755,"ble"]],[9755,9755],[9758,9758]]],[1570544343884,["GJX@GJXAIOU",[[1,9760," "]],[9758,9758],[9759,9759]]],[1570544347072,["GJX@GJXAIOU",[[1,9759,"sort\""]],[9759,9759],[9764,9764]]],[1570544347107,["GJX@GJXAIOU",[[-1,9763,"\""],[1,9764,"”"]],[9764,9764],[9764,9764]]],[1570544412492,["GJX@GJXAIOU",[[1,9764,";"]],[9764,9764],[9765,9765]]],[1570544415504,["GJX@GJXAIOU",[[-1,9764,";"]],[9765,9765],[9764,9764]]],[1570544416170,["GJX@GJXAIOU",[[1,9764,"；"]],[9764,9764],[9765,9765]]],[1570544471529,["GJX@GJXAIOU",[[1,9765,"\n"]],[9765,9765],[9766,9766]]],[1570544471920,["GJX@GJXAIOU",[[-1,9765,"\n"]],[9766,9766],[9765,9765]]],[1570544473020,["GJX@GJXAIOU",[[1,9765,"\n"]],[9765,9765],[9766,9766]]],[1570544485255,["GJX@GJXAIOU",[[1,9766,"问题：讲一个"]],[9766,9766],[9772,9772]]],[1570544487087,["GJX@GJXAIOU",[[-1,9769,"讲一个"]],[9772,9772],[9769,9769]]],[1570544508461,["GJX@GJXAIOU",[[1,9769,"将一个数组的奇数放在数组左边，偶数放在"]],[9769,9769],[9788,9788]]],[1570544547922,["GJX@GJXAIOU",[[1,9788,"数组右边，并且要求原始的相对次序不变，时间复杂度要求：）"]],[9788,9788],[9816,9816]]],[1570544548426,["GJX@GJXAIOU",[[-1,9815,"）"]],[9816,9816],[9815,9815]]],[1570544565569,["GJX@GJXAIOU",[[1,9815,"O(N)，空间复杂度要求：O（）"]],[9815,9815],[9831,9831]]],[1570544568055,["GJX@GJXAIOU",[[-1,9829,"（）"]],[9831,9831],[9829,9829]]],[1570544569200,["GJX@GJXAIOU",[[1,9829,"()"]],[9829,9829],[9831,9831]]],[1570544570444,["GJX@GJXAIOU",[[1,9830,"1"]],[9830,9830],[9831,9831]]],[1570544572004,["GJX@GJXAIOU",[[1,9832,"；"]],[9832,9832],[9833,9833]]],[1570544598740,["GJX@GJXAIOU",[[1,9833,"\n"]],[9833,9833],[9834,9834]]],[1570544600250,["GJX@GJXAIOU",[[1,9834,"****"]],[9834,9834],[9836,9836]]],[1570544601522,["GJX@GJXAIOU",[[1,9836,"解析："]],[9836,9836],[9839,9839]]],[1570544606480,["GJX@GJXAIOU",[[-1,9659,"  "]],[9661,9661],[9659,9659]]],[1570544610225,["GJX@GJXAIOU",[[1,9841," "]],[9839,9839],[9840,9840]]],[1570544613800,["GJX@GJXAIOU",[[-1,9871,"   |   |   |   |   "]],[9871,9890],[9871,9871]]],[1570544613995,["GJX@GJXAIOU",[[-1,9871,"\n"],[1,9872,"、"]],[9871,9871],[9872,9872]]],[1570544614166,["GJX@GJXAIOU",[[1,9872,"\n\n"]],[9872,9872],[9873,9873]]],[1570544614319,["GJX@GJXAIOU",[[1,9874,"\n"]],[9873,9873],[9874,9874]]],[1570544614435,["GJX@GJXAIOU",[[1,9875,"\n"]],[9874,9874],[9875,9875]]],[1570544614554,["GJX@GJXAIOU",[[1,9876,"\n"]],[9875,9875],[9876,9876]]],[1570544614856,["GJX@GJXAIOU",[[-1,9876,"\n"]],[9876,9876],[9875,9875]]],[1570544614993,["GJX@GJXAIOU",[[-1,9875,"\n"]],[9875,9875],[9874,9874]]],[1570544615112,["GJX@GJXAIOU",[[-1,9874,"\n"]],[9874,9874],[9873,9873]]],[1570544615246,["GJX@GJXAIOU",[[-1,9873,"\n"]],[9873,9873],[9872,9872]]],[1570544615721,["GJX@GJXAIOU",[[-1,9871,"、"]],[9872,9872],[9871,9871]]],[1570544616384,["GJX@GJXAIOU",[[1,9872,"\n"]],[9871,9871],[9872,9872]]],[1570544616528,["GJX@GJXAIOU",[[1,9873,"\n"]],[9872,9872],[9873,9873]]],[1570544616657,["GJX@GJXAIOU",[[1,9874,"\n"]],[9873,9873],[9874,9874]]],[1570544616770,["GJX@GJXAIOU",[[1,9875,"\n"]],[9874,9874],[9875,9875]]],[1570544616888,["GJX@GJXAIOU",[[1,9876,"\n"]],[9875,9875],[9876,9876]]],[1570544617025,["GJX@GJXAIOU",[[1,9877,"\n"]],[9876,9876],[9877,9877]]],[1570544617137,["GJX@GJXAIOU",[[1,9878,"\n"]],[9877,9877],[9878,9878]]],[1570544617265,["GJX@GJXAIOU",[[1,9879,"\n"]],[9878,9878],[9879,9879]]],[1570544626053,["GJX@GJXAIOU",[[1,9842,"因为每一个数不是奇数急救室"]],[9842,9842],[9855,9855]]],[1570544626974,["GJX@GJXAIOU",[[-1,9852,"急救室"]],[9855,9855],[9852,9852]]],[1570544642339,["GJX@GJXAIOU",[[1,9852,"就是偶数，因此也是可以抽象为一个 01 "]],[9852,9852],[9872,9872]]],[1570544644338,["GJX@GJXAIOU",[[1,9870," "]],[9870,9870],[9871,9871]]],[1570544645498,["GJX@GJXAIOU",[[1,9873," "]],[9872,9872],[9873,9873]]],[1570544652766,["GJX@GJXAIOU",[[1,9873,"问题，相当于把"]],[9873,9873],[9880,9880]]],[1570544653466,["GJX@GJXAIOU",[[1,9881," "]],[9880,9880],[9881,9881]]],[1570544653725,["GJX@GJXAIOU",[[1,9881,"0"]],[9881,9881],[9882,9882]]],[1570544653898,["GJX@GJXAIOU",[[1,9883," "]],[9882,9882],[9883,9883]]],[1570544660546,["GJX@GJXAIOU",[[1,9883,"类的放在左边，"]],[9883,9883],[9890,9890]]],[1570544665929,["GJX@GJXAIOU",[[1,9884,"（）"]],[9884,9884],[9886,9886]]],[1570544672354,["GJX@GJXAIOU",[[1,9885,"例如 《 "]],[9885,9885],[9890,9890]]],[1570544672958,["GJX@GJXAIOU",[[-1,9888,"《 "]],[9890,9890],[9888,9888]]],[1570544678773,["GJX@GJXAIOU",[[1,9888,"< 0.5的"]],[9888,9888],[9894,9894]]],[1570544678808,["GJX@GJXAIOU",[[1,9893," "]],[9894,9894],[9895,9895]]],[1570544685714,["GJX@GJXAIOU",[[1,9902,"把大于"]],[9902,9902],[9905,9905]]],[1570544686186,["GJX@GJXAIOU",[[1,9906," "]],[9905,9905],[9906,9906]]],[1570544687561,["GJX@GJXAIOU",[[1,9906,"0.5"]],[9906,9906],[9909,9909]]],[1570544687773,["GJX@GJXAIOU",[[1,9910," "]],[9909,9909],[9910,9910]]],[1570544697631,["GJX@GJXAIOU",[[1,9910,"的放在右边，即"]],[9910,9910],[9917,9917]]],[1570544698381,["GJX@GJXAIOU",[[1,9918," "]],[9917,9917],[9918,9918]]],[1570544698709,["GJX@GJXAIOU",[[1,9918,"1"]],[9918,9918],[9919,9919]]],[1570544698842,["GJX@GJXAIOU",[[1,9920," "]],[9919,9919],[9920,9920]]],[1570544699614,["GJX@GJXAIOU",[[1,9920,"类"]],[9920,9920],[9921,9921]]],[1570544712218,["GJX@GJXAIOU",[[1,9895,"，这里 0.5 是随便去"]],[9895,9895],[9907,9907]]],[1570544713050,["GJX@GJXAIOU",[[-1,9906,"去"]],[9907,9907],[9906,9906]]],[1570544714725,["GJX@GJXAIOU",[[1,9906,"取，急速"]],[9906,9906],[9910,9910]]],[1570544715382,["GJX@GJXAIOU",[[-1,9908,"急速"]],[9910,9910],[9908,9908]]],[1570544718804,["GJX@GJXAIOU",[[1,9908,"就是为了区分"]],[9908,9908],[9914,9914]]],[1570544728836,["GJX@GJXAIOU",[[1,9941,"；如果可以实现"]],[9941,9941],[9948,9948]]],[1570544731983,["GJX@GJXAIOU",[[-1,9942,"如果可以实现"]],[9948,9948],[9942,9942]]],[1570544746759,["GJX@GJXAIOU",[[1,9942,"且保证原来的相对顺序不变，抽象就是"]],[9942,9942],[9959,9959]]],[1570544750876,["GJX@GJXAIOU",[[1,9959,"kauipde"]],[9959,9959],[9966,9966]]],[1570544750911,["GJX@GJXAIOU",[[1,9959," "]],[9966,9966],[9967,9967]]],[1570544752966,["GJX@GJXAIOU",[[-1,9959," kauipde"]],[9967,9967],[9959,9959]]],[1570544768090,["GJX@GJXAIOU",[[1,9959,"快排的 partition 过程；因为 partition 服从"]],[9959,9959],[9991,9991]]],[1570544770537,["GJX@GJXAIOU",[[-1,9989,"服从"]],[9991,9991],[9989,9989]]],[1570544781613,["GJX@GJXAIOU",[[1,9989,"过程就是将一个数组分为"]],[9989,9989],[10000,10000]]],[1570544799614,["GJX@GJXAIOU",[[1,9975,"保证稳定"]],[9975,9975],[9979,9979]]],[1570544802978,["GJX@GJXAIOU",[[1,10004,"《"]],[10004,10004],[10005,10005]]],[1570544803537,["GJX@GJXAIOU",[[-1,10004,"《"]],[10005,10005],[10004,10004]]],[1570544804017,["GJX@GJXAIOU",[[1,10004,"<"]],[10004,10004],[10005,10005]]],[1570544805332,["GJX@GJXAIOU",[[1,10004," "]],[10004,10004],[10005,10005]]],[1570544808218,["GJX@GJXAIOU",[[1,10006,"= 和 ."]],[10006,10006],[10011,10011]]],[1570544808833,["GJX@GJXAIOU",[[-1,10010,"."]],[10011,10011],[10010,10010]]],[1570544811666,["GJX@GJXAIOU",[[1,10010,"> 连个"]],[10010,10010],[10014,10014]]],[1570544812522,["GJX@GJXAIOU",[[-1,10012,"连个"]],[10014,10014],[10012,10012]]],[1570544821789,["GJX@GJXAIOU",[[1,10012,"两个部分，也是 0  1 过程，乳沟"]],[10012,10012],[10030,10030]]],[1570544822361,["GJX@GJXAIOU",[[-1,10028,"乳沟"]],[10030,10030],[10028,10028]]],[1570544856448,["GJX@GJXAIOU",[[1,10028,"如果上述满足就可以实现快排稳定；只能采用 01 stable sort 解决；"]],[10028,10028],[10067,10067]]],[1570544864624,["GJX@GJXAIOU",[[1,9764,"- \n"]],[9763,9763],[9766,9766]]],[1570544868240,["GJX@GJXAIOU",[[1,9766,"荷兰国旗"]],[9766,9766],[9770,9770]]],[1570544886729,["GJX@GJXAIOU",[[1,9770,"问题不可能稳定，因为明显存在交换；"]],[9770,9770],[9787,9787]]],[1570544889398,["GJX@GJXAIOU",[[-1,9731," "]],[9732,9732],[9731,9731]]],[1570544894265,["GJX@GJXAIOU",[[-1,10095,"   "],[1,10098,"\n"]],[10098,10098],[10096,10096]]],[1570544894383,["GJX@GJXAIOU",[[1,10097,"\n"]],[10096,10096],[10097,10097]]],[1570544894512,["GJX@GJXAIOU",[[1,10098,"\n"]],[10097,10097],[10098,10098]]],[1570544895942,["GJX@GJXAIOU",[[-1,10098,"\n"]],[10098,10098],[10097,10097]]],[1570544896081,["GJX@GJXAIOU",[[-1,10097,"\n"]],[10097,10097],[10096,10096]]],[1570544927211,["GJX@GJXAIOU",[[1,10096,"## 认识比较器"]],[10096,10096],[10104,10104]]],[1570544927658,["GJX@GJXAIOU",[[1,10105,"\n"]],[10104,10104],[10105,10105]]],[1570544984745,["GJX@GJXAIOU",[[1,10105,"比较器作用：自己实现比较自己定义的对象的方法，然后通过将其传入系统中有序的结构就可以处理自己定义类型的比较；"]],[10105,10105],[10159,10159]]],[1570544990616,["GJX@GJXAIOU",[[1,10160,"\n"]],[10159,10159],[10160,10160]]],[1570544990740,["GJX@GJXAIOU",[[1,10161,"\n"]],[10160,10160],[10161,10161]]],[1570544990819,["GJX@GJXAIOU",[[1,10162,"\n"]],[10161,10161],[10162,10162]]],[1570544992773,["GJX@GJXAIOU",[[1,10162,"例如："]],[10162,10162],[10165,10165]]],[1570544995630,["GJX@GJXAIOU",[[-1,10161,"\n"]],[10161,10161],[10160,10160]]],[1570545008984,["GJX@GJXAIOU",[[1,10164,"使用优先级队列（）"]],[10164,10164],[10173,10173]]],[1570545013902,["GJX@GJXAIOU",[[1,10172,"实质上就是对"]],[10172,10172],[10178,10178]]],[1570545014510,["GJX@GJXAIOU",[[-1,10177,"对"]],[10178,10178],[10177,10177]]],[1570545015892,["GJX@GJXAIOU",[[1,10177,"堆"]],[10177,10177],[10178,10178]]],[1570545023353,["GJX@GJXAIOU",[[1,10179,"存放自定义独享"]],[10179,10179],[10186,10186]]],[1570545024038,["GJX@GJXAIOU",[[-1,10184,"独享"]],[10186,10186],[10184,10184]]],[1570545036587,["GJX@GJXAIOU",[[1,10184,"对象，然后自定义比较器是的"]],[10184,10184],[10197,10197]]],[1570545037334,["GJX@GJXAIOU",[[-1,10195,"是的"]],[10197,10197],[10195,10195]]],[1570545046523,["GJX@GJXAIOU",[[1,10195,"使得可以比较自定义的类型对象；"]],[10195,10195],[10210,10210]]],[1570545057393,["GJX@GJXAIOU",[[1,10136,"**"],[1,10144,"**"]],[10136,10144],[10136,10148]]],[1570581394129,["GJX@GJXAIOU",[[-1,10215,"   "],[1,10218,"\n"]],[10218,10218],[10216,10216]]],[1570581394284,["GJX@GJXAIOU",[[1,10217,"\n"]],[10216,10216],[10217,10217]]],[1570581395940,["GJX@GJXAIOU",[[1,10217,"## "]],[10217,10217],[10220,10220]]],[1570581406928,["GJX@GJXAIOU",[[1,10220,"非基于比较的排序"]],[10220,10220],[10228,10228]]],[1570581407305,["GJX@GJXAIOU",[[1,10229,"\n"]],[10228,10228],[10229,10229]]],[1570581413992,["GJX@GJXAIOU",[[1,10229,"### 桶排序"]],[10229,10229],[10236,10236]]],[1570581414537,["GJX@GJXAIOU",[[1,10237,"\n"]],[10236,10236],[10237,10237]]],[1570581453336,["GJX@GJXAIOU",[[1,10237,"桶排序仅仅是一种概念，整体思想是首先记录数据"]],[10237,10237],[10259,10259]]],[1570581489973,["GJX@GJXAIOU",[[1,10259,"各状况出现的词频，然后根据词频进行还原从而达到排序目的；"]],[10259,10259],[10287,10287]]],[1570581490708,["GJX@GJXAIOU",[[1,10288,"\n"]],[10287,10287],[10288,10288]]],[1570581510796,["GJX@GJXAIOU",[[1,10288,"它的具体实现有：计数排序、基数排序后"]],[10288,10288],[10306,10306]]],[1570581511346,["GJX@GJXAIOU",[[-1,10305,"后"]],[10306,10306],[10305,10305]]],[1570581512123,["GJX@GJXAIOU",[[1,10305,"；"]],[10305,10305],[10306,10306]]],[1570581512825,["GJX@GJXAIOU",[[1,10307,"\n"]],[10306,10306],[10307,10307]]],[1570581512993,["GJX@GJXAIOU",[[1,10308,"\n"]],[10307,10307],[10308,10308]]],[1570581513133,["GJX@GJXAIOU",[[1,10309,"\n"]],[10308,10308],[10309,10309]]],[1570581516537,["GJX@GJXAIOU",[[1,10309,"### 计数"]],[10309,10309],[10315,10315]]],[1570581517554,["GJX@GJXAIOU",[[1,10315,"排序"]],[10315,10315],[10317,10317]]],[1570581517925,["GJX@GJXAIOU",[[1,10318,"\n"]],[10317,10317],[10318,10318]]],[1570581576126,["GJX@GJXAIOU",[[1,10318,"示例：有一个"]],[10318,10318],[10324,10324]]],[1570581576927,["GJX@GJXAIOU",[[1,10324,"数组"]],[10324,10324],[10326,10326]]],[1570581585929,["GJX@GJXAIOU",[[1,10324,"含N"]],[10324,10324],[10326,10326]]],[1570581586356,["GJX@GJXAIOU",[[1,10325," "],[1,10326," 个"]],[10326,10326],[10328,10328]]],[1570581586392,["GJX@GJXAIOU",[[1,10327," "]],[10328,10328],[10329,10329]]],[1570581589820,["GJX@GJXAIOU",[[1,10329,"元素的"]],[10329,10329],[10332,10332]]],[1570581592611,["GJX@GJXAIOU",[[-1,10332," "]],[10333,10333],[10332,10332]]],[1570581597796,["GJX@GJXAIOU",[[1,10334,"，范围是"]],[10334,10334],[10338,10338]]],[1570581599362,["GJX@GJXAIOU",[[-1,10335,"范围是"]],[10338,10338],[10335,10335]]],[1570581604875,["GJX@GJXAIOU",[[1,10335,"元素值范围："]],[10335,10335],[10341,10341]]],[1570581605368,["GJX@GJXAIOU",[[-1,10340,"："]],[10341,10341],[10340,10340]]],[1570581606580,["GJX@GJXAIOU",[[1,10340,"为："]],[10340,10340],[10342,10342]]],[1570581696647,[null,[[-1,10328," "],[1,10329,"个"]],[10328,10328],[10330,10330]]],[1570581696647,[null,[[1,10328," "],[-1,10328,"个"]],[10330,10330],[10328,10328]]],[1570581637267,["GJX@GJXAIOU",[[-1,10335,"元素值范围为："]],[10335,10342],[10335,10335]]],[1570581641465,["GJX@GJXAIOU",[[-1,10324,"含 N 个"],[1,10331,"值范围为："]],[10324,10331],[10331,10331]]],[1570581647243,["GJX@GJXAIOU",[[1,10331,"0  "]],[10331,10331],[10333,10333]]],[1570581648335,["GJX@GJXAIOU",[[1,10333,"~"]],[10333,10333],[10334,10334]]],[1570581648711,["GJX@GJXAIOU",[[1,10335," "]],[10334,10334],[10335,10335]]],[1570581649981,["GJX@GJXAIOU",[[1,10335,"N"]],[10335,10335],[10336,10336]]],[1570581662521,["GJX@GJXAIOU",[[1,10341,"，数组"]],[10341,10341],[10344,10344]]],[1570581664320,["GJX@GJXAIOU",[[-1,10341,"，数组"]],[10344,10344],[10341,10341]]],[1570581675688,["GJX@GJXAIOU",[[1,10341,"数组长度为 N，将其排序；"]],[10341,10341],[10354,10354]]],[1570581676289,["GJX@GJXAIOU",[[1,10355,"\n"]],[10354,10354],[10355,10355]]],[1570581695635,["GJX@GJXAIOU",[[1,10355,"步骤：首先准备一个长度为 N + 1 "]],[10355,10355],[10374,10374]]],[1570581731022,["GJX@GJXAIOU",[[1,10374,"的数组；，"]],[10374,10374],[10379,10379]]],[1570581732497,["GJX@GJXAIOU",[[-1,10378,"，"]],[10379,10379],[10378,10378]]],[1570581748290,["GJX@GJXAIOU",[[1,10378,"数组下标分别为：0 ~ N；"]],[10378,10378],[10392,10392]]],[1570581752521,["GJX@GJXAIOU",[[1,10377,"help"]],[10377,10377],[10381,10381]]],[1570581752558,["GJX@GJXAIOU",[[1,10377," "]],[10381,10381],[10382,10382]]],[1570581756481,["GJX@GJXAIOU",[[-1,10381,"p"]],[10382,10382],[10381,10381]]],[1570581757532,["GJX@GJXAIOU",[[-1,10377," he"]],[10380,10380],[10377,10377]]],[1570581759900,["GJX@GJXAIOU",[[1,10375,"辅助"]],[10375,10375],[10377,10377]]],[1570581762533,["GJX@GJXAIOU",[[1,10380,"辅助"]],[10380,10380],[10382,10382]]],[1570581767067,["GJX@GJXAIOU",[[1,10397,"\n"]],[10396,10396],[10397,10397]]],[1570581800539,["GJX@GJXAIOU",[[1,10397,"然后遍历原数组，有一个 想"]],[10397,10397],[10410,10410]]],[1570581801336,["GJX@GJXAIOU",[[-1,10409,"想"]],[10410,10410],[10409,10409]]],[1570581805585,["GJX@GJXAIOU",[[1,10409,"X 值（）"]],[10409,10409],[10414,10414]]],[1570581814898,["GJX@GJXAIOU",[[1,10413,"0~N之间"]],[10413,10413],[10418,10418]]],[1570581814935,["GJX@GJXAIOU",[[1,10416," "]],[10418,10418],[10419,10419]]],[1570581876647,[null,[[-1,10379,"l"],[1,10380,"；"],[-1,10382,"；"],[1,10397,"\n"],[-1,10420,"\n"]],[10379,10379],[10420,10420]]],[1570581876647,[null,[[1,10379,"l"],[-1,10379,"；"],[1,10382,"；"],[-1,10396,"\n"],[1,10420,"\n"]],[10420,10420],[10379,10379]]],[1570581818938,["GJX@GJXAIOU",[[1,10413,"位于 "]],[10413,10413],[10415,10415]]],[1570581821182,["GJX@GJXAIOU",[[1,10413,"大小"]],[10413,10413],[10415,10415]]],[1570581826946,["GJX@GJXAIOU",[[1,10425,"，就在 "]],[10425,10425],[10429,10429]]],[1570581827544,["GJX@GJXAIOU",[[-1,10428," "]],[10429,10429],[10428,10428]]],[1570581830617,["GJX@GJXAIOU",[[1,10428,"附注属猪"]],[10428,10428],[10432,10432]]],[1570581831632,["GJX@GJXAIOU",[[-1,10428,"附注属猪"]],[10432,10432],[10428,10428]]],[1570581838608,["GJX@GJXAIOU",[[1,10428,"辅助数组下标为 N "]],[10428,10428],[10438,10438]]],[1570581839178,["GJX@GJXAIOU",[[-1,10436,"N "]],[10438,10438],[10436,10436]]],[1570581842006,["GJX@GJXAIOU",[[1,10436,"X的"]],[10436,10436],[10438,10438]]],[1570581842042,["GJX@GJXAIOU",[[1,10437," "]],[10438,10438],[10439,10439]]],[1570581865771,["GJX@GJXAIOU",[[1,10439,"对应元素值 + 1；一直遍历结束；"]],[10439,10439],[10456,10456]]],[1570581866186,["GJX@GJXAIOU",[[1,10457,"\n"]],[10456,10456],[10457,10457]]],[1570581875060,["GJX@GJXAIOU",[[1,10457,"最后将辅助数组中"]],[10457,10457],[10465,10465]]],[1570581936653,[null,[[-1,10379,"l"],[1,10380,"；"],[-1,10382,"；"],[1,10397,"\n"],[-1,10465,"\n"]],[10379,10379],[10465,10465]]],[1570581936653,[null,[[1,10379,"l"],[-1,10379,"；"],[1,10382,"；"],[-1,10396,"\n"],[1,10465,"\n"]],[10465,10465],[10379,10379]]],[1570581908522,["GJX@GJXAIOU",[[1,10465,"各个下标对应的元素值还原，示例：辅助数组为：``"]],[10465,10465],[10489,10489]]],[1570581909962,["GJX@GJXAIOU",[[1,10488,"[]"]],[10488,10488],[10490,10490]]],[1570581915636,["GJX@GJXAIOU",[[1,10489,"1,2,0,2"]],[10489,10489],[10496,10496]]],[1570581923365,["GJX@GJXAIOU",[[1,10498,"就相当于有1"]],[10498,10498],[10504,10504]]],[1570581923401,["GJX@GJXAIOU",[[1,10503," "]],[10504,10504],[10505,10505]]],[1570581924436,["GJX@GJXAIOU",[[1,10505," 个0"]],[10505,10505],[10508,10508]]],[1570581924472,["GJX@GJXAIOU",[[1,10507," "]],[10508,10508],[10509,10509]]],[1570581925219,["GJX@GJXAIOU",[[1,10509,"，"]],[10509,10509],[10510,10510]]],[1570581925989,["GJX@GJXAIOU",[[-1,10509,"，"]],[10510,10510],[10509,10509]]],[1570581927570,["GJX@GJXAIOU",[[1,10509,",2 个1"]],[10509,10509],[10514,10514]]],[1570581927608,["GJX@GJXAIOU",[[1,10513," "]],[10514,10514],[10515,10515]]],[1570581928242,["GJX@GJXAIOU",[[1,10515,"，"]],[10515,10515],[10516,10516]]],[1570581930703,["GJX@GJXAIOU",[[-1,10515,"，"]],[10516,10516],[10515,10515]]],[1570581931368,["GJX@GJXAIOU",[[1,10515,",0高"]],[10515,10515],[10518,10518]]],[1570581931404,["GJX@GJXAIOU",[[1,10517," "]],[10518,10518],[10519,10519]]],[1570581932130,["GJX@GJXAIOU",[[-1,10518,"高"]],[10519,10519],[10518,10518]]],[1570581934282,["GJX@GJXAIOU",[[1,10518,"个3"]],[10518,10518],[10520,10520]]],[1570581934320,["GJX@GJXAIOU",[[1,10519," "]],[10520,10520],[10521,10521]]],[1570581934866,["GJX@GJXAIOU",[[1,10521,"，"]],[10521,10521],[10522,10522]]],[1570581996653,[null,[[-1,10379,"l"],[1,10380,"；"],[-1,10382,"；"],[1,10397,"\n"],[-1,10522,"\n"]],[10379,10379],[10522,10522]]],[1570581996653,[null,[[1,10379,"l"],[-1,10379,"；"],[1,10382,"；"],[-1,10396,"\n"],[1,10522,"\n"]],[10522,10522],[10379,10379]]],[1570581937606,["GJX@GJXAIOU",[[-1,10521,"，"]],[10522,10522],[10521,10521]]],[1570581938389,["GJX@GJXAIOU",[[1,10521,",2个"]],[10521,10521],[10524,10524]]],[1570581938427,["GJX@GJXAIOU",[[1,10523," "]],[10524,10524],[10525,10525]]],[1570581939571,["GJX@GJXAIOU",[[1,10525,"2"]],[10525,10525],[10526,10526]]],[1570581939608,["GJX@GJXAIOU",[[1,10525," "]],[10526,10526],[10527,10527]]],[1570581940353,["GJX@GJXAIOU",[[-1,10526,"2"]],[10527,10527],[10526,10526]]],[1570581941435,["GJX@GJXAIOU",[[1,10526,"4；"]],[10526,10526],[10528,10528]]],[1570581942352,["GJX@GJXAIOU",[[-1,10527,"；"]],[10528,10528],[10527,10527]]],[1570581946008,["GJX@GJXAIOU",[[1,10527,"，因此结果Wie"]],[10527,10527],[10535,10535]]],[1570581946045,["GJX@GJXAIOU",[[1,10532," "]],[10535,10535],[10536,10536]]],[1570581946339,["GJX@GJXAIOU",[[1,10536,"："]],[10536,10536],[10537,10537]]],[1570581947544,["GJX@GJXAIOU",[[-1,10532," Wie："]],[10537,10537],[10532,10532]]],[1570581950740,["GJX@GJXAIOU",[[1,10532,"为：``"]],[10532,10532],[10536,10536]]],[1570581951963,["GJX@GJXAIOU",[[1,10535,"[]"]],[10535,10535],[10537,10537]]],[1570581956959,["GJX@GJXAIOU",[[1,10536,"01"]],[10536,10536],[10538,10538]]],[1570581959678,["GJX@GJXAIOU",[[1,10537,","]],[10537,10537],[10538,10538]]],[1570581966715,["GJX@GJXAIOU",[[1,10539,",1,4,4"]],[10539,10539],[10545,10545]]],[1570581969155,["GJX@GJXAIOU",[[1,10547,"；"]],[10547,10547],[10548,10548]]],[1570581969762,["GJX@GJXAIOU",[[1,10549,"\n"]],[10548,10548],[10549,10549]]],[1570581970233,["GJX@GJXAIOU",[[1,10550,"\n"]],[10549,10549],[10550,10550]]],[1570581981438,["GJX@GJXAIOU",[[1,10307,"****"]],[10307,10307],[10309,10309]]],[1570581983561,["GJX@GJXAIOU",[[-1,10309,"**"]],[10309,10309],[10307,10307]]],[1570581985384,["GJX@GJXAIOU",[[-1,10307,"**"]],[10309,10309],[10307,10307]]],[1570581987537,["GJX@GJXAIOU",[[1,10318,"\n"]],[10317,10317],[10318,10318]]],[1570581989815,["GJX@GJXAIOU",[[1,10318,"****"]],[10318,10318],[10320,10320]]],[1570581995572,["GJX@GJXAIOU",[[1,10320,"有多少个元素就需要"]],[10320,10320],[10329,10329]]],[1570582056654,[null,[[-1,10393,"l"],[1,10394,"；"],[-1,10396,"；"],[1,10411,"\n"],[-1,10562,"\n"]],[10393,10393],[10562,10562]]],[1570582056654,[null,[[1,10393,"l"],[-1,10393,"；"],[1,10396,"；"],[-1,10410,"\n"],[1,10562,"\n"]],[10562,10562],[10393,10393]]],[1570582000571,["GJX@GJXAIOU",[[1,10329,"多少个桶；"]],[10329,10329],[10334,10334]]],[1570582017442,["GJX@GJXAIOU",[[1,10570,"\n"]],[10569,10569],[10570,10570]]],[1570582017546,["GJX@GJXAIOU",[[1,10571,"\n"]],[10570,10570],[10571,10571]]],[1570582021837,["GJX@GJXAIOU",[[1,10571,"### 计数排序"]],[10571,10571],[10579,10579]]],[1570582022912,["GJX@GJXAIOU",[[-1,10575,"计数排序"]],[10579,10579],[10575,10575]]],[1570582029711,["GJX@GJXAIOU",[[1,10575,"基数排序"]],[10575,10575],[10579,10579]]],[1570582030147,["GJX@GJXAIOU",[[1,10580,"\n"]],[10579,10579],[10580,10580]]],[1570582030267,["GJX@GJXAIOU",[[1,10581,"\n"]],[10580,10580],[10581,10581]]],[1570582030402,["GJX@GJXAIOU",[[1,10582,"\n"]],[10581,10581],[10582,10582]]],[1570582032577,["GJX@GJXAIOU",[[1,10583,"\n"]],[10582,10582],[10583,10583]]],[1570582033681,["GJX@GJXAIOU",[[1,10584,"\n"]],[10583,10583],[10584,10584]]],[1570582033851,["GJX@GJXAIOU",[[1,10585,"\n"]],[10584,10584],[10585,10585]]],[1570582040515,["GJX@GJXAIOU",[[1,10585,"****"]],[10585,10585],[10587,10587]]],[1570582043429,["GJX@GJXAIOU",[[1,10587,"补充示例："]],[10587,10587],[10592,10592]]],[1570582048293,["GJX@GJXAIOU",[[1,10594," 戈丁一个"]],[10594,10594],[10599,10599]]],[1570582049136,["GJX@GJXAIOU",[[-1,10595,"戈丁一个"]],[10599,10599],[10595,10595]]],[1570582056509,["GJX@GJXAIOU",[[1,10595,"给定一个数组，求如果"]],[10595,10595],[10605,10605]]],[1570582116658,[null,[[-1,10398,"l"],[1,10399,"；"],[-1,10401,"；"],[1,10416,"\n"],[-1,10605,"\n"]],[10398,10398],[10605,10605]]],[1570582116658,[null,[[1,10398,"l"],[-1,10398,"；"],[1,10401,"；"],[-1,10415,"\n"],[1,10605,"\n"]],[10605,10605],[10398,10398]]],[1570582059117,["GJX@GJXAIOU",[[1,10605,"排序只有，"]],[10605,10605],[10610,10610]]],[1570582064856,["GJX@GJXAIOU",[[-1,10607,"只有，"]],[10610,10610],[10607,10607]]],[1570582067518,["GJX@GJXAIOU",[[1,10607,"之后响铃"]],[10607,10607],[10611,10611]]],[1570582068567,["GJX@GJXAIOU",[[-1,10609,"响铃"]],[10611,10611],[10609,10609]]],[1570582093219,["GJX@GJXAIOU",[[1,10609,"相邻两个元素的最大差值，要求时间复杂度为 O()"]],[10609,10609],[10633,10633]]],[1570582094693,["GJX@GJXAIOU",[[1,10632,"N"]],[10632,10632],[10633,10633]]],[1570582112570,["GJX@GJXAIOU",[[1,10634,"，且不能用非基于比较的排序；"]],[10634,10634],[10648,10648]]],[1570582113218,["GJX@GJXAIOU",[[1,10649,"\n"]],[10648,10648],[10649,10649]]],[1570582176656,[null,[[-1,10398,"l"],[1,10399,"；"],[-1,10401,"；"],[1,10416,"\n"],[-1,10648,"\n"]],[10398,10398],[10648,10648]]],[1570582176656,[null,[[1,10398,"l"],[-1,10398,"；"],[1,10401,"；"],[-1,10415,"\n"],[1,10648,"\n"]],[10648,10648],[10398,10398]]],[1570582124688,["GJX@GJXAIOU",[[1,10649,"****"]],[10649,10649],[10651,10651]]],[1570582129852,["GJX@GJXAIOU",[[1,10651,"解答："]],[10651,10651],[10654,10654]]],[1570582137594,["GJX@GJXAIOU",[[1,10657,"\n"]],[10656,10656],[10657,10657]]],[1570582139487,["GJX@GJXAIOU",[[1,10657,"****"]],[10657,10657],[10659,10659]]],[1570582142055,["GJX@GJXAIOU",[[-1,10659,"**"]],[10659,10659],[10657,10657]]],[1570582143808,["GJX@GJXAIOU",[[-1,10657,"**"]],[10659,10659],[10657,10657]]],[1570582152470,["GJX@GJXAIOU",[[1,10657,"  - 思想：急用"]],[10657,10657],[10666,10666]]],[1570582154287,["GJX@GJXAIOU",[[-1,10664,"急用"]],[10666,10666],[10664,10664]]],[1570582156720,["GJX@GJXAIOU",[[1,10664,"借用荣"]],[10664,10664],[10667,10667]]],[1570582157264,["GJX@GJXAIOU",[[-1,10665,"用荣"]],[10667,10667],[10665,10665]]],[1570582159821,["GJX@GJXAIOU",[[1,10665,"用同"]],[10665,10665],[10667,10667]]],[1570582160464,["GJX@GJXAIOU",[[-1,10666,"同"]],[10667,10667],[10666,10666]]],[1570582169234,["GJX@GJXAIOU",[[1,10666,"桶的思想，但是不使用桶排序；"]],[10666,10666],[10680,10680]]],[1570582170192,["GJX@GJXAIOU",[[1,10683,"- \n  "]],[10680,10680],[10685,10685]]],[1570582236658,[null,[[-1,10398,"l"],[1,10399,"；"],[-1,10401,"；"],[1,10416,"\n"],[-1,10681,"\n"],[1,10682," "],[-1,10686," "]],[10398,10398],[10686,10686]]],[1570582236658,[null,[[1,10398,"l"],[-1,10398,"；"],[1,10401,"；"],[-1,10415,"\n"],[1,10681,"\n"],[-1,10681," "],[1,10686," "]],[10686,10686],[10398,10398]]],[1570582214864,["GJX@GJXAIOU",[[-1,10657,"  "],[-1,10681,"  "]],[10659,10685],[10657,10681]]],[1570582219690,["GJX@GJXAIOU",[[1,10681,"原理："]],[10681,10681],[10684,10684]]],[1570582220384,["GJX@GJXAIOU",[[1,10685,"- \n"]],[10684,10684],[10687,10687]]],[1570582221379,["GJX@GJXAIOU",[[1,10685,"  "]],[10687,10687],[10689,10689]]],[1570582224395,["GJX@GJXAIOU",[[-1,10681,"原理"]],[10683,10683],[10681,10681]]],[1570582228447,["GJX@GJXAIOU",[[1,10681,"思路"]],[10681,10681],[10683,10683]]],[1570582296661,[null,[[-1,10398,"l"],[1,10399,"；"],[-1,10401,"；"],[1,10416,"\n"],[-1,10690," "]],[10398,10398],[10690,10690]]],[1570582296661,[null,[[1,10398,"l"],[-1,10398,"；"],[1,10401,"；"],[-1,10415,"\n"],[1,10690," "]],[10690,10690],[10398,10398]]],[1570582243979,["GJX@GJXAIOU",[[1,10689,"因为"]],[10689,10689],[10691,10691]]],[1570582248879,["GJX@GJXAIOU",[[-1,10688," 因为"]],[10691,10691],[10688,10688]]],[1570582258663,["GJX@GJXAIOU",[[1,10688," 准备桶，原数组中有N"]],[10688,10688],[10699,10699]]],[1570582258700,["GJX@GJXAIOU",[[1,10698," "]],[10699,10699],[10700,10700]]],[1570582259072,["GJX@GJXAIOU",[[1,10700,"个"]],[10700,10700],[10701,10701]]],[1570582259109,["GJX@GJXAIOU",[[1,10700," "]],[10701,10701],[10702,10702]]],[1570582269978,["GJX@GJXAIOU",[[1,10702,"元素，因此准备 N+1 个桶；"]],[10702,10702],[10717,10717]]],[1570582276435,["GJX@GJXAIOU",[[1,10720,"- \n  "]],[10717,10717],[10722,10722]]],[1570582293414,["GJX@GJXAIOU",[[1,10722,"遍历原数组，找到原数组中的最大值和"]],[10722,10722],[10739,10739]]],[1570582296093,["GJX@GJXAIOU",[[-1,10735,"最大值和"]],[10739,10739],[10735,10735]]],[1570582356662,[null,[[-1,10398,"l"],[1,10399,"；"],[-1,10401,"；"],[1,10416,"\n"],[-1,10736," "]],[10398,10398],[10736,10736]]],[1570582356662,[null,[[1,10398,"l"],[-1,10398,"；"],[1,10401,"；"],[-1,10415,"\n"],[1,10736," "]],[10736,10736],[10398,10398]]],[1570582312367,["GJX@GJXAIOU",[[1,10735,"最小值和最大值，分别放在第一个桶 和"]],[10735,10735],[10753,10753]]],[1570582313441,["GJX@GJXAIOU",[[-1,10751," 和"]],[10753,10753],[10751,10751]]],[1570582323910,["GJX@GJXAIOU",[[1,10751,"和第N"]],[10751,10751],[10754,10754]]],[1570582323946,["GJX@GJXAIOU",[[1,10753," "]],[10754,10754],[10755,10755]]],[1570582324548,["GJX@GJXAIOU",[[1,10755,"个"]],[10755,10755],[10756,10756]]],[1570582324585,["GJX@GJXAIOU",[[1,10755," "]],[10756,10756],[10757,10757]]],[1570582325980,["GJX@GJXAIOU",[[1,10757,"桶的"]],[10757,10757],[10759,10759]]],[1570582326627,["GJX@GJXAIOU",[[-1,10758,"的"]],[10759,10759],[10758,10758]]],[1570582327805,["GJX@GJXAIOU",[[1,10758,"中；"]],[10758,10758],[10760,10760]]],[1570582345081,["GJX@GJXAIOU",[[-1,10748,"一个"]],[10750,10750],[10748,10748]]],[1570582346740,["GJX@GJXAIOU",[[1,10748,"0"]],[10748,10748],[10749,10749]]],[1570582348164,["GJX@GJXAIOU",[[1,10748," "],[1,10749," 号"]],[10749,10749],[10751,10751]]],[1570582348201,["GJX@GJXAIOU",[[1,10750," "]],[10751,10751],[10752,10752]]],[1570582349600,["GJX@GJXAIOU",[[-1,10752," "]],[10753,10753],[10752,10752]]],[1570582352008,["GJX@GJXAIOU",[[-1,10758,"个"]],[10759,10759],[10758,10758]]],[1570582416661,[null,[[-1,10398,"l"],[1,10399,"；"],[-1,10401,"；"],[1,10416,"\n"],[-1,10751," "],[1,10752,"号"],[-1,10762," "]],[10398,10398],[10762,10762]]],[1570582416661,[null,[[1,10398,"l"],[-1,10398,"；"],[1,10401,"；"],[-1,10415,"\n"],[1,10751," "],[-1,10751,"号"],[1,10762," "]],[10762,10762],[10398,10398]]],[1570582401293,["GJX@GJXAIOU",[[1,10758,"号"]],[10758,10758],[10759,10759]]],[1570582409711,["GJX@GJXAIOU",[[-1,10360,"数组长度为 N，"]],[10360,10367],[10359,10359]]],[1570582476664,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,10755," "]],[10390,10390],[10755,10755]]],[1570582476664,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,10755," "]],[10755,10755],[10390,10390]]],[1570582441828,["GJX@GJXAIOU",[[1,10754,"如果最大值等于最下肢"]],[10754,10754],[10764,10764]]],[1570582442611,["GJX@GJXAIOU",[[-1,10761,"最下肢"]],[10764,10764],[10761,10761]]],[1570582451110,["GJX@GJXAIOU",[[1,10761,"最小值，直接返回0"]],[10761,10761],[10770,10770]]],[1570582451148,["GJX@GJXAIOU",[[1,10769," "]],[10770,10770],[10771,10771]]],[1570582451420,["GJX@GJXAIOU",[[1,10771,"；"]],[10771,10771],[10772,10772]]],[1570582452168,["GJX@GJXAIOU",[[-1,10771,"；"]],[10772,10772],[10771,10771]]],[1570582456501,["GJX@GJXAIOU",[[1,10771,"结束"]],[10771,10771],[10773,10773]]],[1570582456537,["GJX@GJXAIOU",[[1,10771," "]],[10773,10773],[10774,10774]]],[1570582456762,["GJX@GJXAIOU",[[1,10774,"；"]],[10774,10774],[10775,10775]]],[1570582536661,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,10776," "]],[10390,10390],[10776,10776]]],[1570582536661,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,10776," "]],[10776,10776],[10390,10390]]],[1570582502450,["GJX@GJXAIOU",[[1,10778,"- \n  "]],[10775,10775],[10780,10780]]],[1570582533334,["GJX@GJXAIOU",[[1,10780,"将新数组（）"]],[10780,10780],[10786,10786]]],[1570582535726,["GJX@GJXAIOU",[[1,10785,"桶"]],[10785,10785],[10786,10786]]],[1570582596668,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,10788," "]],[10390,10390],[10788,10788]]],[1570582596668,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,10788," "]],[10788,10788],[10390,10390]]],[1570582548040,["GJX@GJXAIOU",[[1,10787,"的 0 ~ N部分"]],[10787,10787],[10796,10796]]],[1570582548077,["GJX@GJXAIOU",[[1,10794," "]],[10796,10796],[10797,10797]]],[1570582550631,["GJX@GJXAIOU",[[1,10797,"华为为"]],[10797,10797],[10800,10800]]],[1570582554144,["GJX@GJXAIOU",[[-1,10795,"部分华为为"]],[10800,10800],[10795,10795]]],[1570582562901,["GJX@GJXAIOU",[[1,10795,"部分等分为 N+ 1 分"]],[10795,10795],[10807,10807]]],[1570582563551,["GJX@GJXAIOU",[[-1,10806,"分"]],[10807,10807],[10806,10806]]],[1570582582680,["GJX@GJXAIOU",[[1,10806,"份，原书中"]],[10806,10806],[10811,10811]]],[1570582583426,["GJX@GJXAIOU",[[-1,10809,"书中"]],[10811,10811],[10809,10809]]],[1570582585527,["GJX@GJXAIOU",[[1,10809,"数组汇总"]],[10809,10809],[10813,10813]]],[1570582586182,["GJX@GJXAIOU",[[-1,10811,"汇总"]],[10813,10813],[10811,10811]]],[1570582595926,["GJX@GJXAIOU",[[1,10811,"中值属于哪一个部分就放在"]],[10811,10811],[10823,10823]]],[1570582656666,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,10824," "]],[10390,10390],[10824,10824]]],[1570582656666,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,10824," "]],[10824,10824],[10390,10390]]],[1570582597694,["GJX@GJXAIOU",[[1,10823,"按个"]],[10823,10823],[10825,10825]]],[1570582598368,["GJX@GJXAIOU",[[-1,10823,"按个"]],[10825,10825],[10823,10823]]],[1570582616321,["GJX@GJXAIOU",[[1,10823,"哪一个桶中；示例：如果m"]],[10823,10823],[10835,10835]]],[1570582616359,["GJX@GJXAIOU",[[1,10834," "]],[10835,10835],[10836,10836]]],[1570582616803,["GJX@GJXAIOU",[[1,10836,"ing"]],[10836,10836],[10839,10839]]],[1570582617664,["GJX@GJXAIOU",[[-1,10838,"g"]],[10839,10839],[10838,10838]]],[1570582618429,["GJX@GJXAIOU",[[1,10838," "]],[10838,10838],[10839,10839]]],[1570582644427,["GJX@GJXAIOU",[[-1,10834," min "]],[10839,10839],[10834,10834]]],[1570582645974,["GJX@GJXAIOU",[[1,10834,"一个"]],[10834,10834],[10836,10836]]],[1570582648738,["GJX@GJXAIOU",[[-1,10834,"一个"]],[10836,10836],[10834,10834]]],[1570582650789,["GJX@GJXAIOU",[[1,10834,"异同"]],[10834,10834],[10836,10836]]],[1570582651363,["GJX@GJXAIOU",[[-1,10834,"异同"]],[10836,10836],[10834,10834]]],[1570582656382,["GJX@GJXAIOU",[[1,10834,"原数组一共 9 个数"]],[10834,10834],[10844,10844]]],[1570582716673,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,10845," "]],[10390,10390],[10845,10845]]],[1570582716673,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,10845," "]],[10845,10845],[10390,10390]]],[1570582663834,["GJX@GJXAIOU",[[1,10844,"，则准备1"]],[10844,10844],[10849,10849]]],[1570582663870,["GJX@GJXAIOU",[[1,10848," "]],[10849,10849],[10850,10850]]],[1570582686637,["GJX@GJXAIOU",[[1,10850,"0 个桶，且第一个桶中放大"]],[10850,10850],[10863,10863]]],[1570582687303,["GJX@GJXAIOU",[[-1,10862,"大"]],[10863,10863],[10862,10862]]],[1570582694090,["GJX@GJXAIOU",[[1,10862,"的是数组最小值0"]],[10862,10862],[10870,10870]]],[1570582694129,["GJX@GJXAIOU",[[1,10869," "]],[10870,10870],[10871,10871]]],[1570582695324,["GJX@GJXAIOU",[[1,10871,"（）"]],[10871,10871],[10873,10873]]],[1570582698384,["GJX@GJXAIOU",[[1,10872,"假定"]],[10872,10872],[10874,10874]]],[1570582708260,["GJX@GJXAIOU",[[1,10875,"，最后一个桶放的是最大值（）"]],[10875,10875],[10889,10889]]],[1570582710676,["GJX@GJXAIOU",[[1,10887,"9"]],[10887,10887],[10888,10888]]],[1570582710713,["GJX@GJXAIOU",[[1,10887," "]],[10888,10888],[10889,10889]]],[1570582710818,["GJX@GJXAIOU",[[1,10889,"9"]],[10889,10889],[10890,10890]]],[1570582713222,["GJX@GJXAIOU",[[1,10891,"假定"]],[10891,10891],[10893,10893]]],[1570582716060,["GJX@GJXAIOU",[[1,10894,"，则"]],[10894,10894],[10896,10896]]],[1570582776673,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,10897," "]],[10390,10390],[10897,10897]]],[1570582776674,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,10897," "]],[10897,10897],[10390,10390]]],[1570582720026,["GJX@GJXAIOU",[[1,10896,"将 0 ` 99"]],[10896,10896],[10904,10904]]],[1570582721161,["GJX@GJXAIOU",[[-1,10900,"` 99"]],[10904,10904],[10900,10900]]],[1570582723852,["GJX@GJXAIOU",[[1,10900,"~99"]],[10900,10900],[10903,10903]]],[1570582725367,["GJX@GJXAIOU",[[1,10901," "]],[10901,10901],[10902,10902]]],[1570582727802,["GJX@GJXAIOU",[[1,10904," hua"]],[10904,10904],[10908,10908]]],[1570582728991,["GJX@GJXAIOU",[[-1,10905,"hua"]],[10908,10908],[10905,10905]]],[1570582731636,["GJX@GJXAIOU",[[1,10905,"划分为"]],[10905,10905],[10908,10908]]],[1570582733299,["GJX@GJXAIOU",[[-1,10905,"划分为"]],[10908,10908],[10905,10905]]],[1570582749732,["GJX@GJXAIOU",[[1,10905,"等分为 10 份，则袁术"]],[10905,10905],[10917,10917]]],[1570582751744,["GJX@GJXAIOU",[[-1,10915,"袁术"]],[10917,10917],[10915,10915]]],[1570582761611,["GJX@GJXAIOU",[[1,10915,"原数组中出现 0 ~ 9 zhijain "]],[10915,10915],[10936,10936]]],[1570582763112,["GJX@GJXAIOU",[[-1,10928,"zhijain "]],[10936,10936],[10928,10928]]],[1570582771922,["GJX@GJXAIOU",[[1,10928,"直接的数放在0"]],[10928,10928],[10935,10935]]],[1570582771959,["GJX@GJXAIOU",[[1,10934," "]],[10935,10935],[10936,10936]]],[1570582773011,["GJX@GJXAIOU",[[1,10936,"号"]],[10936,10936],[10937,10937]]],[1570582773048,["GJX@GJXAIOU",[[1,10936," "]],[10937,10937],[10938,10938]]],[1570582774650,["GJX@GJXAIOU",[[1,10938,"桶，"]],[10938,10938],[10940,10940]]],[1570582836677,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,10941," "]],[10390,10390],[10941,10941]]],[1570582836677,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,10941," "]],[10941,10941],[10390,10390]]],[1570582778794,["GJX@GJXAIOU",[[1,10940,"出现1"]],[10940,10940],[10943,10943]]],[1570582778831,["GJX@GJXAIOU",[[1,10942," "]],[10943,10943],[10944,10944]]],[1570582788897,["GJX@GJXAIOU",[[1,10944,"0 ~ 19 之间的数放在1"]],[10944,10944],[10958,10958]]],[1570582788935,["GJX@GJXAIOU",[[1,10957," "]],[10958,10958],[10959,10959]]],[1570582793370,["GJX@GJXAIOU",[[1,10959,"号桶"]],[10959,10959],[10961,10961]]],[1570582793407,["GJX@GJXAIOU",[[1,10959," "]],[10961,10961],[10962,10962]]],[1570582796228,["GJX@GJXAIOU",[[1,10962,"。。。；"]],[10962,10962],[10966,10966]]],[1570582820348,["GJX@GJXAIOU",[[-1,10967,"   "],[1,10970,"\n"]],[10970,10970],[10968,10968]]],[1570582830660,["GJX@GJXAIOU",[[1,10968,"- 原理：因为0"]],[10968,10968],[10976,10976]]],[1570582830700,["GJX@GJXAIOU",[[1,10975," "]],[10976,10976],[10977,10977]]],[1570582835536,["GJX@GJXAIOU",[[1,10977," 号桶非空，N"]],[10977,10977],[10984,10984]]],[1570582896676,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,10984," "]],[10390,10390],[10984,10984]]],[1570582896676,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,10984," "]],[10984,10984],[10390,10390]]],[1570582837157,["GJX@GJXAIOU",[[1,10984,"号桶"]],[10984,10984],[10986,10986]]],[1570582837194,["GJX@GJXAIOU",[[1,10984," "]],[10986,10986],[10987,10987]]],[1570582847397,["GJX@GJXAIOU",[[1,10987,"非空，但是只有"]],[10987,10987],[10994,10994]]],[1570582956677,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,10994," "]],[10390,10390],[10994,10994]]],[1570582956677,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,10994," "]],[10994,10994],[10390,10390]]],[1570582898060,["GJX@GJXAIOU",[[1,10994," N个"]],[10994,10994],[10997,10997]]],[1570582898099,["GJX@GJXAIOU",[[1,10996," "]],[10997,10997],[10998,10998]]],[1570582905199,["GJX@GJXAIOU",[[1,10998,"数，因此重甲"]],[10998,10998],[11004,11004]]],[1570582905911,["GJX@GJXAIOU",[[-1,11002,"重甲"]],[11004,11004],[11002,11002]]],[1570582909981,["GJX@GJXAIOU",[[1,11002,"中间至少"]],[11002,11002],[11006,11006]]],[1570582914528,["GJX@GJXAIOU",[[-1,11002,"中间至少"]],[11006,11006],[11002,11002]]],[1570582915496,["GJX@GJXAIOU",[[1,11002,"****"]],[11002,11002],[11004,11004]]],[1570582924963,["GJX@GJXAIOU",[[1,11004,"中间至少有一个桶式"]],[11004,11004],[11013,11013]]],[1570582926769,["GJX@GJXAIOU",[[-1,11012,"式"]],[11013,11013],[11012,11012]]],[1570582928748,["GJX@GJXAIOU",[[1,11012,"是空的"]],[11012,11012],[11015,11015]]],[1570582931042,["GJX@GJXAIOU",[[1,11017,"，"]],[11017,11017],[11018,11018]]],[1570583016676,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11018," "]],[10390,10390],[11018,11018]]],[1570583016676,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11018," "]],[11018,11018],[10390,10390]]],[1570582974171,["GJX@GJXAIOU",[[1,11018,"同时任何连个响铃"]],[11018,11018],[11026,11026]]],[1570582977648,["GJX@GJXAIOU",[[-1,11022,"连个响铃"]],[11026,11026],[11022,11022]]],[1570582983011,["GJX@GJXAIOU",[[1,11022,"两个相邻的数可以能"]],[11022,11022],[11031,11031]]],[1570582985136,["GJX@GJXAIOU",[[-1,11030,"能"]],[11031,11031],[11030,11030]]],[1570583003418,["GJX@GJXAIOU",[[1,11030,"来自于同一个桶，也可能来自于不同的桶"]],[11030,11030],[11048,11048]]],[1570583076677,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11048," "]],[10390,10390],[11048,11048]]],[1570583076677,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11048," "]],[11048,11048],[10390,10390]]],[1570583025123,["GJX@GJXAIOU",[[1,11048,"；"]],[11048,11048],[11049,11049]]],[1570583026147,["GJX@GJXAIOU",[[1,11050,"- \n"]],[11049,11049],[11052,11052]]],[1570583027364,["GJX@GJXAIOU",[[1,11050,"  "]],[11052,11052],[11054,11054]]],[1570583054239,["GJX@GJXAIOU",[[1,11054,"为什么要设置一个空桶：因为至少有一个桶为空，则距离空桶左右最贱的"]],[11054,11054],[11086,11086]]],[1570583054839,["GJX@GJXAIOU",[[-1,11084,"贱的"]],[11086,11086],[11084,11084]]],[1570583062290,["GJX@GJXAIOU",[[1,11084,"近的两个非空桶"]],[11084,11084],[11091,11091]]],[1570583136680,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11049," "],[1,11050,"\n"],[-1,11091,"\n"]],[10390,10390],[11091,11091]]],[1570583136680,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11049," "],[-1,11049,"\n"],[1,11091,"\n"]],[11091,11091],[10390,10390]]],[1570583084436,["GJX@GJXAIOU",[[1,11091,"：fei"]],[11091,11091],[11095,11095]]],[1570583086935,["GJX@GJXAIOU",[[-1,11092,"fei"]],[11095,11095],[11092,11092]]],[1570583089741,["GJX@GJXAIOU",[[1,11092,"非空 ming"]],[11092,11092],[11099,11099]]],[1570583090449,["GJX@GJXAIOU",[[-1,11098,"g"]],[11099,11099],[11098,11098]]],[1570583106353,["GJX@GJXAIOU",[[1,11098," .... 非空 max 。。。空桶 。。。feik"]],[11098,11098],[11124,11124]]],[1570583107511,["GJX@GJXAIOU",[[-1,11120,"feik"]],[11124,11124],[11120,11120]]],[1570583110397,["GJX@GJXAIOU",[[1,11120,"非空m"]],[11120,11120],[11123,11123]]],[1570583110436,["GJX@GJXAIOU",[[1,11122," "]],[11123,11123],[11124,11124]]],[1570583112682,["GJX@GJXAIOU",[[1,11124,"in。。。"]],[11124,11124],[11129,11129]]],[1570583113535,["GJX@GJXAIOU",[[-1,11126,"。。。"]],[11129,11129],[11126,11126]]],[1570583114955,["GJX@GJXAIOU",[[1,11126,"...."]],[11126,11126],[11130,11130]]],[1570583115458,["GJX@GJXAIOU",[[-1,11129,"."]],[11130,11130],[11129,11129]]],[1570583120025,["GJX@GJXAIOU",[[1,11129,".非空 mainx"]],[11129,11129],[11138,11138]]],[1570583120850,["GJX@GJXAIOU",[[-1,11135,"inx"]],[11138,11138],[11135,11135]]],[1570583121091,["GJX@GJXAIOU",[[1,11135,"x"]],[11135,11135],[11136,11136]]],[1570583127790,["GJX@GJXAIOU",[[1,11104,"左"]],[11104,11104],[11105,11105]]],[1570583131452,["GJX@GJXAIOU",[[1,11092,"左"]],[11092,11092],[11093,11093]]],[1570583196682,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11049," "],[1,11050,"\n"],[-1,11138,"\n"]],[10390,10390],[11138,11138]]],[1570583196682,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11049," "],[-1,11049,"\n"],[1,11138,"\n"]],[11138,11138],[10390,10390]]],[1570583137371,["GJX@GJXAIOU",[[1,11122,"右"]],[11122,11122],[11123,11123]]],[1570583142006,["GJX@GJXAIOU",[[1,11133,"右"]],[11133,11133],[11134,11134]]],[1570583151579,["GJX@GJXAIOU",[[1,11140,"，则右非空m"]],[11140,11140],[11146,11146]]],[1570583151636,["GJX@GJXAIOU",[[1,11145," "]],[11146,11146],[11147,11147]]],[1570583151898,["GJX@GJXAIOU",[[1,11147,"ing"]],[11147,11147],[11150,11150]]],[1570583152568,["GJX@GJXAIOU",[[-1,11149,"g"]],[11150,11150],[11149,11149]]],[1570583163492,["GJX@GJXAIOU",[[1,11149," -  "]],[11149,11149],[11152,11152]]],[1570583163929,["GJX@GJXAIOU",[[1,11152,"fei"]],[11152,11152],[11155,11155]]],[1570583164674,["GJX@GJXAIOU",[[-1,11152,"fei"]],[11155,11155],[11152,11152]]],[1570583168244,["GJX@GJXAIOU",[[1,11152,"左非空"]],[11152,11152],[11155,11155]]],[1570583168628,["GJX@GJXAIOU",[[1,11156," "]],[11155,11155],[11156,11156]]],[1570583169385,["GJX@GJXAIOU",[[1,11156,"max"]],[11156,11156],[11159,11159]]],[1570583170337,["GJX@GJXAIOU",[[1,11160," "]],[11159,11159],[11160,11160]]],[1570583171010,["GJX@GJXAIOU",[[1,11160,"de"]],[11160,11160],[11162,11162]]],[1570583171108,["GJX@GJXAIOU",[[1,11163," "]],[11162,11162],[11163,11163]]],[1570583172098,["GJX@GJXAIOU",[[-1,11160,"de  "]],[11163,11163],[11159,11159]]],[1570583173012,["GJX@GJXAIOU",[[1,11159,"的"]],[11159,11159],[11160,11160]]],[1570583173051,["GJX@GJXAIOU",[[1,11159," "]],[11160,11160],[11161,11161]]],[1570583195846,["GJX@GJXAIOU",[[1,11161,"插值一定大于桶内插值，因为其值至少"]],[11161,11161],[11178,11178]]],[1570583256684,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11049," "],[1,11050,"\n"],[-1,11179,"\n"]],[10390,10390],[11179,11179]]],[1570583256684,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11049," "],[-1,11049,"\n"],[1,11179,"\n"]],[11179,11179],[10390,10390]]],[1570583218208,["GJX@GJXAIOU",[[1,11178,"是一个桶的长度，而桶内元素之间"]],[11178,11178],[11193,11193]]],[1570583221844,["GJX@GJXAIOU",[[1,11187,"同一个"]],[11187,11187],[11190,11190]]],[1570583233419,["GJX@GJXAIOU",[[1,11196,"的插值是不会大于桶长的，"]],[11196,11196],[11208,11208]]],[1570583436684,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11049," "],[1,11050,"\n"],[-1,11209,"\n"]],[10390,10390],[11209,11209]]],[1570583436684,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11049," "],[-1,11049,"\n"],[1,11209,"\n"]],[11209,11209],[10390,10390]]],[1570583388328,["GJX@GJXAIOU",[[1,11209,"为了证明：****"]],[11209,11209],[11216,11216]]],[1570583400354,["GJX@GJXAIOU",[[1,11216,"最大的插值一定不会来自于同一个桶"]],[11216,11216],[11232,11232]]],[1570583402906,["GJX@GJXAIOU",[[1,11234,"。"]],[11234,11234],[11235,11235]]],[1570583417351,["GJX@GJXAIOU",[[1,11238,"- \n  "]],[11235,11235],[11240,11240]]],[1570583427039,["GJX@GJXAIOU",[[-1,11237," - "]],[11239,11239],[11236,11236]]],[1570583432036,["GJX@GJXAIOU",[[1,10966,"、"]],[10966,10966],[10967,10967]]],[1570583432903,["GJX@GJXAIOU",[[-1,10966,"、"]],[10967,10967],[10966,10966]]],[1570583434739,["GJX@GJXAIOU",[[1,10967,"  - \n"]],[10966,10966],[10971,10971]]],[1570583496686,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11054," "],[1,11055,"\n"],[-1,11241,"\n\n "],[1,11244," \n"]],[10390,10390],[11246,11246]]],[1570583496686,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11054," "],[-1,11054,"\n"],[1,11241,"\n\n "],[-1,11241," \n"]],[11246,11246],[10390,10390]]],[1570583441072,["GJX@GJXAIOU",[[1,10971,"每个元素放入"]],[10971,10971],[10977,10977]]],[1570583444986,["GJX@GJXAIOU",[[-1,10971,"每个元素放入"]],[10977,10977],[10971,10971]]],[1570583467235,["GJX@GJXAIOU",[[1,10971,"每个桶只保留三个值：一个Boolean"]],[10971,10971],[10990,10990]]],[1570583467273,["GJX@GJXAIOU",[[1,10983," "]],[10990,10990],[10991,10991]]],[1570583468187,["GJX@GJXAIOU",[[1,10991,"值"]],[10991,10991],[10992,10992]]],[1570583468226,["GJX@GJXAIOU",[[1,10991," "]],[10992,10992],[10993,10993]]],[1570583473743,["GJX@GJXAIOU",[[1,10993,"，用于判断给"]],[10993,10993],[10999,10999]]],[1570583474183,["GJX@GJXAIOU",[[-1,10998,"给"]],[10999,10999],[10998,10998]]],[1570583488635,["GJX@GJXAIOU",[[1,10998,"该桶中是否有元素，一个min"]],[10998,10998],[11012,11012]]],[1570583488674,["GJX@GJXAIOU",[[1,11009," "]],[11012,11012],[11013,11013]]],[1570583492978,["GJX@GJXAIOU",[[1,11013,"，表示同种的"]],[11013,11013],[11019,11019]]],[1570583493879,["GJX@GJXAIOU",[[-1,11016,"同种的"]],[11019,11019],[11016,11016]]],[1570583556685,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11099," "],[1,11100,"\n"],[-1,11286,"\n\n "],[1,11289," \n"]],[10390,10390],[11291,11291]]],[1570583556686,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11099," "],[-1,11099,"\n"],[1,11286,"\n\n "],[-1,11286," \n"]],[11291,11291],[10390,10390]]],[1570583513419,["GJX@GJXAIOU",[[1,11016,"桶中的最小值，一个max"]],[11016,11016],[11028,11028]]],[1570583513456,["GJX@GJXAIOU",[[1,11025," "]],[11028,11028],[11029,11029]]],[1570583514918,["GJX@GJXAIOU",[[1,11029,"百世"]],[11029,11029],[11031,11031]]],[1570583514955,["GJX@GJXAIOU",[[1,11029," "]],[11031,11031],[11032,11032]]],[1570583516240,["GJX@GJXAIOU",[[-1,11030,"百世"]],[11032,11032],[11030,11030]]],[1570583543152,["GJX@GJXAIOU",[[1,11030,"，表示桶中的最大值；因此如果元素 X进入"]],[11030,11030],[11050,11050]]],[1570583543188,["GJX@GJXAIOU",[[1,11048," "]],[11050,11050],[11051,11051]]],[1570583545636,["GJX@GJXAIOU",[[1,11051," 7号桶"]],[11051,11051],[11055,11055]]],[1570583545674,["GJX@GJXAIOU",[[1,11053," "]],[11055,11055],[11056,11056]]],[1570583550219,["GJX@GJXAIOU",[[1,11056,"，如果7"]],[11056,11056],[11060,11060]]],[1570583550256,["GJX@GJXAIOU",[[1,11059," "]],[11060,11060],[11061,11061]]],[1570583551337,["GJX@GJXAIOU",[[1,11061,"号"]],[11061,11061],[11062,11062]]],[1570583551375,["GJX@GJXAIOU",[[1,11061," "]],[11062,11062],[11063,11063]]],[1570583554839,["GJX@GJXAIOU",[[1,11063,"桶之前没有"]],[11063,11063],[11068,11068]]],[1570583616687,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11151," "],[1,11152,"\n"],[-1,11338,"\n\n "],[1,11341," \n"]],[10390,10390],[11343,11343]]],[1570583616687,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11151," "],[-1,11151,"\n"],[1,11338,"\n\n "],[-1,11338," \n"]],[11343,11343],[10390,10390]]],[1570583566805,["GJX@GJXAIOU",[[1,11068,"元素，则首先将 Boolean值"]],[11068,11068],[11084,11084]]],[1570583566844,["GJX@GJXAIOU",[[1,11083," "]],[11084,11084],[11085,11085]]],[1570583583041,["GJX@GJXAIOU",[[1,11085,"置为 true，然后 ming"]],[11085,11085],[11100,11100]]],[1570583583849,["GJX@GJXAIOU",[[-1,11099,"g"]],[11100,11100],[11099,11099]]],[1570583587010,["GJX@GJXAIOU",[[1,11099," = x,"]],[11099,11099],[11104,11104]]],[1570583588519,["GJX@GJXAIOU",[[-1,11103,","]],[11104,11104],[11103,11103]]],[1570583593707,["GJX@GJXAIOU",[[1,11103,"，max = x;"]],[11103,11103],[11112,11112]]],[1570583594271,["GJX@GJXAIOU",[[-1,11111,";"]],[11112,11112],[11111,11111]]],[1570583611514,["GJX@GJXAIOU",[[1,11111,"；当又一个元素进入7"]],[11111,11111],[11121,11121]]],[1570583611552,["GJX@GJXAIOU",[[1,11120," "]],[11121,11121],[11122,11122]]],[1570583612275,["GJX@GJXAIOU",[[1,11122,"号"]],[11122,11122],[11123,11123]]],[1570583612316,["GJX@GJXAIOU",[[1,11122," "]],[11123,11123],[11124,11124]]],[1570583616185,["GJX@GJXAIOU",[[1,11124,"桶的时候，"]],[11124,11124],[11129,11129]]],[1570583676692,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11212," "],[1,11213,"\n"],[-1,11399,"\n\n "],[1,11402," \n"]],[10390,10390],[11404,11404]]],[1570583676692,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11212," "],[-1,11212,"\n"],[1,11399,"\n\n "],[-1,11399," \n"]],[11404,11404],[10390,10390]]],[1570583666115,["GJX@GJXAIOU",[[1,11129,"比较桶内元素的值，更新最大值和最小值，其他值扔掉；"]],[11129,11129],[11154,11154]]],[1570583669536,["GJX@GJXAIOU",[[1,11155,"  - \n"]],[11154,11154],[11159,11159]]],[1570583675219,["GJX@GJXAIOU",[[1,11159,"最后遍历多有"]],[11159,11159],[11165,11165]]],[1570583736703,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11248," "],[1,11249,"\n"],[-1,11435,"\n\n "],[1,11438," \n"]],[10390,10390],[11440,11440]]],[1570583736703,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11248," "],[-1,11248,"\n"],[1,11435,"\n\n "],[-1,11435," \n"]],[11440,11440],[10390,10390]]],[1570583676886,["GJX@GJXAIOU",[[-1,11163,"多有"]],[11165,11165],[11163,11163]]],[1570583685947,["GJX@GJXAIOU",[[1,11163,"所有的桶，如果是"]],[11163,11163],[11171,11171]]],[1570583687050,["GJX@GJXAIOU",[[-1,11170,"是"]],[11171,11171],[11170,11170]]],[1570583721532,["GJX@GJXAIOU",[[1,11170,"遇到空桶，跳到下一个进行判断，如果是非空桶，找到其坐标"]],[11170,11170],[11197,11197]]],[1570583723082,["GJX@GJXAIOU",[[-1,11195,"坐标"]],[11197,11197],[11195,11195]]],[1570583725099,["GJX@GJXAIOU",[[1,11195,"坐标"]],[11195,11195],[11197,11197]]],[1570583726409,["GJX@GJXAIOU",[[-1,11195,"坐标"]],[11197,11197],[11195,11195]]],[1570583731931,["GJX@GJXAIOU",[[1,11195,"左边最近的"]],[11195,11195],[11200,11200]]],[1570583796693,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11283," "],[1,11284,"\n"],[-1,11470,"\n\n "],[1,11473," \n"]],[10390,10390],[11475,11475]]],[1570583796693,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11283," "],[-1,11283,"\n"],[1,11470,"\n\n "],[-1,11470," \n"]],[11475,11475],[10390,10390]]],[1570583750109,["GJX@GJXAIOU",[[1,11200,"非空桶，将后一个非空的 min - qian"]],[11200,11200],[11222,11222]]],[1570583751600,["GJX@GJXAIOU",[[-1,11218,"qian"]],[11222,11222],[11218,11218]]],[1570583751898,["GJX@GJXAIOU",[[1,11218,"s"]],[11218,11218],[11219,11219]]],[1570583752287,["GJX@GJXAIOU",[[-1,11218,"s"]],[11219,11219],[11218,11218]]],[1570583756163,["GJX@GJXAIOU",[[1,11218,"前一个非空的m"]],[11218,11218],[11225,11225]]],[1570583756199,["GJX@GJXAIOU",[[1,11224," "]],[11225,11225],[11226,11226]]],[1570583760389,["GJX@GJXAIOU",[[1,11226,"ax，得到值"]],[11226,11226],[11232,11232]]],[1570583761967,["GJX@GJXAIOU",[[-1,11229,"得到值"]],[11232,11232],[11229,11229]]],[1570583764838,["GJX@GJXAIOU",[[1,11229,"插值就是"]],[11229,11229],[11233,11233]]],[1570583767737,["GJX@GJXAIOU",[[-1,11231,"就是"]],[11233,11233],[11231,11231]]],[1570583781466,["GJX@GJXAIOU",[[1,11231,"进行保存，有然后"]],[11231,11231],[11239,11239]]],[1570583782511,["GJX@GJXAIOU",[[-1,11236,"有然后"]],[11239,11239],[11236,11236]]],[1570583793404,["GJX@GJXAIOU",[[1,11236,"然后比较所有的插值，区最呆"]],[11236,11236],[11249,11249]]],[1570583793881,["GJX@GJXAIOU",[[-1,11248,"呆"]],[11249,11249],[11248,11248]]],[1570583794429,["GJX@GJXAIOU",[[1,11248,"大"]],[11248,11248],[11249,11249]]],[1570583795410,["GJX@GJXAIOU",[[-1,11246,"区最大"]],[11249,11249],[11246,11246]]],[1570583856695,[null,[[-1,10390,"l"],[1,10391,"；"],[-1,10393,"；"],[1,10408,"\n"],[-1,10743," "],[1,10744,"号"],[-1,11329," "],[1,11330,"\n"],[-1,11516,"\n\n "],[1,11519," \n"]],[10390,10390],[11521,11521]]],[1570583856695,[null,[[1,10390,"l"],[-1,10390,"；"],[1,10393,"；"],[-1,10407,"\n"],[1,10743," "],[-1,10743,"号"],[1,11329," "],[-1,11329,"\n"],[1,11516,"\n\n "],[-1,11516," \n"]],[11521,11521],[10390,10390]]],[1570583808632,["GJX@GJXAIOU",[[1,11246,"取最大的就是最大插值，"]],[11246,11246],[11257,11257]]]],null,"GJX@GJXAIOU"],["13111e71-bdd2-4d6d-b302-306156e4462a",1570584937366,"# AlgorithmEasyDay02\n\n**例题：**\n问题一：分割数组\n给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)；\n![示例]($resource/%E7%A4%BA%E4%BE%8B.png)\n其中 x 坐标为 L - 1，<=x 位置上放置的都是 <= num 值的数，然后依次向右遍历，如果该数大于 num，则 x 不动，直接判断下一个数，如果该数小于等于 num，则该数和 x + 1 位置上的数互换， x 向右移动一位，即 x + 1，然后继续判断下一个数；以此类推；\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-07-15:03\n */\npublic class SplitArray {\n    public static void sort(int[] sourceArray, int left, int right, int tagMum){\n        int less = left - 1;\n        while(left < right){\n            if(sourceArray[left] <= tagMum){\n                swap(sourceArray, left++, ++less);\n            }\n            if(sourceArray [left] > tagMum){\n                left++;\n            }\n        }\n        return ;\n    }\n\n    public static void swap(int[] sourceArray, int left, int right) {\n        if(left == right){\n            return;\n        }\n        sourceArray[left] = sourceArray[left] ^ sourceArray[right];\n        sourceArray[right] = sourceArray[left] ^ sourceArray[right];\n        sourceArray[left] = sourceArray[left] ^ sourceArray[right];\n    }\n\n    // 测试方法\n    public static void main(String[] args) {\n        int[] sourceArray ={1,2,8,4,9,3,1,4,3,2,7};\n        int left = 0;\n        int right = sourceArray.length - 1;\n        int tagMum = 6;\n\n        System.out.println(\"原数组为：\");\n        for (int i : sourceArray) {\n            System.out.print(i + \" \");\n        }\n\n        sort(sourceArray, left, right, tagMum);\n\n        System.out.println(\"\\n分割之后数组为：\");\n        for (int i : sourceArray) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n\n```\n\n\n问题二（荷兰国旗问题）\n给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)\n![示例2]($resource/%E7%A4%BA%E4%BE%8B2.png)\n\nx 坐标为 L - 1，y 坐标为 R + 1，两边分别表示小于 num 和大于 num 的值，当前位置坐标为 cur，然后依次向右遍历，如果该数小于 num，则该数和小于区域最右边下标（x）的下一个坐标元素交换，小于区域向右扩充（即 x + 1），如果该数等于 num ,则 cur 指向下一个元素，如果大于 num，则该数和大于区域最左边区域的前一个坐标元素交换，大于区域向左扩充一个（即 y - 1），然后这里**交换回来的数还需要按照上面的标准进行判断**，直到 cur 和 又边界相遇停止；\n\n```java\npackage sort.nowcoder.easy.day01;\n\npublic class NetherlandsFlag {\n\t/**\n\t * @param sourceArray：要分割的数组\n\t * @param left：小于 tagNum 区域最右边数\n\t * @param right：大于 tagNum 区域最左边数\n\t * @param tagNum：用于分割的参考数字\n\t * @return\n\t */\n\tpublic static int[] partition(int[] sourceArray, int left, int right, int tagNum) {\n\t\t// less 表示小于 tagNum 区域最右边数，more 是大于 tagNum 区域最左边数\n\t\tint less = left - 1;\n\t\tint more = right + 1;\n\t\twhile (left < more) {\n\t\t\tif (sourceArray[left] < tagNum) {\n\t\t\t\tswap(sourceArray, ++less, left++);\n\t\t\t} else if (sourceArray[left] > tagNum) {\n\t\t\t\tswap(sourceArray, --more, left);\n\t\t\t} else {\n\t\t\t\tleft++;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { less + 1, more - 1 };\n\t}\n\t\n\tpublic static void swap(int[] sourceArray, int left, int right) {\n\t\tint tmp = sourceArray[left];\n\t\tsourceArray[left] = sourceArray[right];\n\t\tsourceArray[right] = tmp;\n\t}\n}\n```\n\n\n\n## 二、快速排序\n### 经典快排\n首先以数组最后一个数值为基准，将小于等于该数值的全部放在数组前半部分，大于该数值的全部放在数组的后半部分，然后前半部分和后半部分分别以该部分最后一个元素为基准重复以上步骤；\n\n**改进**：使用荷兰国旗思想\n首先还是选取数组最后一个值为基准，但是遍历判断的时候最后一个值不再进行判断，即只有 L ~ R - 1 的值与基准进行比较，同时区域划分为三个区域：小于基准、等于基准、大于基准；然后将小于基准和大于基准部分进行再次取最后一个数，同上进行比较.....最后全部比较结束之后，将最后一个基准值放在大于该基准的范围的前一个位置；\n\n\n特点：\n- 经典快排和数据的状态有关：\n  - 当小于最后一个数值的元素远大于大于最后一个数组的元素个数时候，或者反之情况，时间复杂度都是：$O({N}^{2})$\n  - 如果数据状态较好，即大于和小于差不多的情况下，时间复杂度为：$T(N) = 2T(\\frac{N}{2}) + O(N) = O(N * log_{2}^{N})$\n\n经典快排的空间复杂度为：$O(N)$\n\n### 随机快速排序\n通过随机选一个数和最后一个数进行互换，使得每次划分标准都在改变；\n根据随机性，随机快速排序的时间复杂度是：$O(N * \\log_{2}^{N})$，同时需要空间复杂度为：$O(\\log_{2}^{N})$，这里的额外空间主要用于记录每次划分区域的断点；\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-04-20:08\n */\n\nimport java.util.Arrays;\n\npublic class QuickSort {\n    /**\n     *  首先调用该方法，可以设置排序的区间，默认为 0 ~ length-1；\n     * @param sourceArray：需要排序的数组\n     */\n    public static void quickSort(int[] sourceArray) {\n        if (sourceArray == null || sourceArray.length < 2) {\n            return;\n        }\n        quickSort(sourceArray, 0, sourceArray.length - 1);\n    }\n\n    /**\n     * @param sourceArray：需要排序的数组\n     * @param left：排序数组左边界，一般为：0\n     * @param right：排序数组右边界，一般为：length - 1;\n     *  less：小于参照元素区域的最右边边界：less = p[0] - 1;\n     *  more：大于参照元素区域的最左边边界：more = p[1] + 1;\n     *  p[0]：等于参照元素区域的最左边边界；\n     *  p[1]：等于参数元素区域的最右边边界；\n     *  小于参照元素区域：[Left ~ less];\n     *  等于参照元素区域：[p[0] ~ p[1]]；\n     *  大于参照元素区域：[more ~ right]；\n     */\n    public static void quickSort(int[] sourceArray, int left, int right) {\n        if (left < right) {\n            swap(sourceArray, left + (int) (Math.random() * (right - left + 1)), right);\n            // p 数组中： p[0] 表示等于区域的左边界，p[1] 表示等于区域的右边界，\n            // 左边区域：L ~ p[0] - 1;右边区域： p[1] + 1 ~ R;\n            int[] p = partition(sourceArray, left, right);\n            quickSort(sourceArray, left, p[0] - 1);\n            quickSort(sourceArray, p[1] + 1, right);\n        }\n    }\n\n    public static int[] partition(int[] sourceArray, int left, int right) {\n        int less = left - 1;\n        int more = right;\n        while (left < more) {\n            if (sourceArray[left] < sourceArray[right]) {\n                swap(sourceArray, ++less, left++);\n            } else if (sourceArray[left] > sourceArray[right]) {\n                swap(sourceArray, --more, left);\n            } else {\n                left++;\n            }\n        }\n        swap(sourceArray, more, right);\n        return new int[] { less + 1, more };\n    }\n\n    public static void swap(int[] sourceArray, int left, int right) {\n        int tmp = sourceArray[left];\n        sourceArray[left] = sourceArray[right];\n        sourceArray[right] = tmp;\n    }\n```\n\n\n\n\n## 堆排序\n\n### 堆\n堆是一个完全二叉树，可以采用数组进行实现；\n对于完全二叉树，结点 i 的左孩子序号为：2i + 1；右孩子序号为：2i + 2；父结点的序号为：$\\frac{i - 1}{2}$，\n\n分类：\n- 大根堆：每棵树（包括任意一棵子树）的最大值都是其头部（父结点）；\n- 小根堆：每棵树（包括任意一棵子树）的最小值都是其头部（父结点）；\n\n**完全二叉树**：对一棵具有 n 个节点的二叉树按照层序进行编号，如果编号 i （1<=i<=n）的结点与同样深度的满二叉树中编号为 i 的结点位置完全相同；\n**满二叉树**：所有的分支结点都存在左子树和右子树，且所有的叶子都在同一层；\n\n### 数组转换为大根堆\n以数组 [2,1,3,6,0,4]为例：\n首先取出第一元素 2，然后取出第二个元素 1，该元素比 2 小，放在左孩子位置，数组元素为：[2,1]；然后取出第三个元素 3，计算该元素的父结点：$\\frac{2 - 1}{2} = 0$，则与 0 位置元素 2 进行比较，发现 3 比较大，则在数组中将 3 和 2 两个元素互换，则数组变为：[3,1,2]；然后取出第四个元素 6，计算父结点下标为：$\\frac{3 - 1}{2} = 1$，则与 1 位置的元素 1 进行比较，发现 6 比较大，则将元素 1 和元素 6 互换，得到[3,6,2,1]，然后再比较元素 6 和其父结点：$\\frac{1 - 1}{2} = 0$，比较得出 6 比 3 大，然后再换，最后得到数组为：[6,3,2,1]，剩下元素依次类推......\n\n每加入一个节点其最多比较的次数和已经形成的二叉树高度有关（因为每次只和其父结点比较），因此最多时间复杂度为：$O(log_{2}^{N})$，所有整个转换过程时间复杂度为：$log_{2}^{1} + log_{2}^{2} + ..... + log_{2}^{N} = O(N)$\n\n\n**题目**\n吐泡泡：一个 XXX 会不停的吐出数字，求任意时刻的已经吐出的所有元素的中位数；\n\n**解答：**\n这里需要同时使用大根堆和小根堆，大根堆中存放着较小的 $\\frac{N}{2}$个元素，小根堆中存放较大的  $\\frac{N}{2}$个元素；\n\n这里以：5 4 6 7 为例\n首先将 5 放入大根堆，计算大根堆和小根堆的 Heapsize，插值为 1,不动， 然后因为 4 小于等于大根堆的堆顶，因此放入大根堆，再次计算 HeapSize，插值 > 1，然后将大根堆的堆顶放在小根堆，然后将大根堆剩余的调整为大根堆，然后元素 6 大于大根堆现在堆顶 4，因此放入小根堆；现在大根堆为 4，小根堆为 5,6；插值为 1，然后放入元素 7，同样大于大根堆堆顶，放入小根堆，然后插值> 1，将小根堆的堆顶放入大根堆末尾，小根堆重新排为：6,7；大根堆重新排为：5,4；中位数就是两个堆顶的平均值；\n\n\n### 堆排序\n首先将数组变成大根堆；\n然后将堆中最后一个和堆顶进行交换，堆大小减一，则最后一个不动了，然后将剩下的前面进行 Heapify 调整；\n然后再将堆的最后一个和堆顶进行交换，同上.....;\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-04-20:08\n */\nimport java.util.Arrays;\n\npublic class HeapSort {\n\n    public static void heapSort(int[] arr) {\n        if (arr == null || arr.length < 2) {\n            return;\n        }\n        // 首先将数组转化为大根堆；0 到  i 之间形成大根堆\n        for (int i = 0; i < arr.length; i++) {\n            heapInsert(arr, i);\n        }\n\n        // 不断将堆顶的元素和最后一个元素交换然后进行 heapify 过程\n        int size = arr.length;\n        swap(arr, 0, --size);\n        while (size > 0) {\n            heapify(arr, 0, size);\n            swap(arr, 0, --size);\n        }\n    }\n\n    public static void heapInsert(int[] arr, int index) {\n        // 如果插入的新节点值大于其父结点大小\n        while (arr[index] > arr[(index - 1) / 2]) {\n            swap(arr, index, (index - 1) / 2);\n            index = (index - 1) / 2;\n        }\n    }\n\n    /**\n     * size - 1 到 length - 1 位置上已经拍好\n     * @param arr：要排序的数组\n     * @param index：哪个节点位置上元素发生了变化，传入的初始值一直为0\n     * @param size：还没有排好序的数组长度\n     */\n    public static void heapify(int[] arr, int index, int size) {\n        // size 表示当前堆上节点数\n        int left = index * 2 + 1;\n        // 越界表示已经是叶子结点了\n        while (left < size) {\n            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;\n            largest = arr[largest] > arr[index] ? largest : index;\n            if (largest == index) {\n                break;\n            }\n            swap(arr, largest, index);\n            index = largest;\n            left = index * 2 + 1;\n        }\n    }\n\n    public static void swap(int[] arr, int left, int right) {\n        int tmp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = tmp;\n    }\n}    \n```\n\n\n**概念：**\n- HeapInsert：将新的节点加入堆中同时按照堆的结构进行向上调整的过程；\n-  HeapSize：堆的大小；对应数组中就是 0-i 位置;\n- Heapify：假设堆中（数组中）某个值发生了变化，让其整体再次调整为大根堆（或小根堆）原来的样子的过程；\n  首先找到变化的值的两个孩子，然后找到其中较大的一个与之交换，如果有交换，在新的位置上再次找现在的两个孩子进行比较，然后交换，一直到没有交换为止；\n- 堆减小的过程：以大根堆为例：首先将堆顶元素和堆的最后一个元素位置互换，这样原来堆顶的元素就放在了数组的最后，然后将堆的 Heapsize - 1，这样最后一个元素就应为超过了现在的 HeapSize 而越界，从而失效；然后将剩余的 0 ~ i - 1 位置的按照 Heapify 重新进行调整（因为堆顶的元素值发生了变化）为原来的堆结构；\n\n\n## 排序算法的稳定性\n\n首先总结现有排序算法稳定性\n算法名称 | 时间复杂度 | 算法种类 | 是否稳定 | 原因\n---|---|---|---|---\n冒泡排序|$O({N}^{2})$|基于比较|稳定 |在冒泡的时候，如果遇到前后相同的值两者不交换即可，只有前者比后者大才交换；\n插入排序|$O({N}^{2})$|基于比较|稳定 |同样在比较的时候，相同的值不交换即可；\n选择排序|$O({N}^{2})$|基于比较| 不稳定 |因为如果后面有小于前面的，就和前面的互换，如果有几个相同数，则相当于和最前面的数进行互换，这样顺序就乱了；\n归并排序|$O(N * log_{2}^{N})$ |基于比较  |稳定 |以为归并之前是左右两个数组，左边数组在原数组中就是在左边，右边数组原来就是右边，这样只需要如果左右两个数组中有相同的数字，则只需要先拷贝左边数组值，然后拷贝右边数组中值即可；\n快速排序 | $O(N * log_{2}^{N})$ |基于比较  |不稳定（也可以稳定） |因为 partition 过程就是交换，肯定是无序的；\n堆排序 | $O(N * log_{2}^{N})$ |基于比较  |不稳定 | 因为在形成大根堆的时候，叶子结点与根节点进行交换的时候就会序号乱，例如：2,2,3；当放入 3 的时候，两个 2 的顺序就改变了；   \n桶排序|$O(N)$|非基于比较 |稳定 |   \n基数排序|$O(N)$|非基于比较 |稳定 |   \n计数排序|$O(N)$|非基于比较 |稳定 |   \n\n   \n**排序问题补充：**\n   \n- 归并排序的空间复杂度可以变成 O(1)，可以采用 “归并排序 内部缓存法”实现，但是仅仅要求了解即可；\n- 快速排序可以做到稳定性，采用“01 stable sort”；\n- 荷兰国旗问题不可能稳定，因为明显存在交换；\n问题：将一个数组的奇数放在数组左边，偶数放在数组右边，并且要求原始的相对次序不变，时间复杂度要求：O(N)，空间复杂度要求：O(1)；\n**解析：**   因为每一个数不是奇数就是偶数，因此也是可以抽象为一个 0 1 问题，相当于把 0 类（例如 < 0.5 的，这里 0.5 是随便取，就是为了区分）的放在左边，把大于 0.5 的放在右边，即 1 类 ；且保证原来的相对顺序不变，抽象就是快排的 partition 过程保证稳定；因为 partition 过程就是将一个数组分为 <= 和 > 两个部分，也是 0  1 过程，如果上述满足就可以实现快排稳定；只能采用 01 stable sort 解决；\n   \n\n## 认识比较器\n比较器作用：自己实现比较自己定义的对象的方法，然后通过将其传入**系统中有序的结构**就可以处理自己定义类型的比较；\n\n例如：使用优先级队列（实质上就是堆）存放自定义对象，然后自定义比较器使得可以比较自定义的类型对象；\n\n\n## 非基于比较的排序\n### 桶排序\n桶排序仅仅是一种概念，整体思想是首先记录数据各状况出现的词频，然后根据词频进行还原从而达到排序目的；\n它的具体实现有：计数排序、基数排序；\n\n\n### 计数排序\n**有多少个元素就需要多少个桶；**\n示例：有一个元素值范围为：0 ~ N 的数组，将其排序；\n步骤：首先准备一个长度为 N + 1 的辅助数组；辅助数组下标分别为：0 ~ N；\n然后遍历原数组，有一个 X 值（大小位于 0~N 之间），就在辅助数组下标为 X 的对应元素值 + 1；一直遍历结束；\n最后将辅助数组中各个下标对应的元素值还原，示例：辅助数组为：`[1,2,0,2]`就相当于有 1 个 0,2 个 1,0 个 3,2 个 4，因此结果为：`[0,1,1,4,4]`；\n\n\n\n### 基数排序\n\n\n\n\n\n**补充示例：** 给定一个数组，求如果排序之后相邻两个元素的最大差值，要求时间复杂度为 O(N)，且不能用非基于比较的排序；\n**解答：**\n- 思想：借用桶的思想，但是不使用桶排序；\n- 思路：\n  - 准备桶，原数组中有 N 个元素，因此准备 N+1 个桶；\n  - 遍历原数组，找到原数组中的最小值和最大值，分别放在第 0 号桶和第 N 号桶中；如果最大值等于最小值，直接返回 0 结束；\n  - 将新数组（桶）的 0 ~ N 部分等分为 N+ 1 份，原数组中值属于哪一个部分就放在哪一个桶中；示例：如果原数组一共 9 个数，则准备 10 个桶，且第一个桶中放的是数组最小值 0（假定），最后一个桶放的是最大值 99（假定），则将 0 ~ 99 等分为 10 份，则原数组中出现 0 ~ 9 直接的数放在 0 号桶，出现 10 ~ 19 之间的数放在 1 号桶。。。；\n  - 每个桶只保留三个值：一个 Boolean 值，用于判断该桶中是否有元素，一个 min，表示桶中的最小值，一个 max ，表示桶中的最大值；因此如果元素 X 进入 7 号桶，如果 7 号桶之前没有元素，则首先将 Boolean 值置为 true，然后 min = x，max = x；当又一个元素进入 7 号桶的时候，比较桶内元素的值，更新最大值和最小值，其他值扔掉；\n  - 最后遍历所有的桶，如果遇到空桶，跳到下一个进行判断，如果是非空桶，找到其左边最近的非空桶，将后一个非空的 min - 前一个非空的 max，插值进行保存，然后比较所有的插值，取最大的就是最大插值，\n\n- 原理：因为 0 号桶非空，N 号桶非空，但是只有 N 个数，因此**中间至少有一个桶是空的**，同时任何两个相邻的数可以来自于同一个桶，也可能来自于不同的桶；\n  - 为什么要设置一个空桶：因为至少有一个桶为空，则距离空桶左右最近的两个非空桶：左非空 min .... 左非空 max 。。。空桶 。。。右非空 min....右非空 max，则右非空 min - 左非空 max 的插值一定大于桶内插值，因为其值至少是一个桶的长度，而同一个桶内元素之间的插值是不会大于桶长的， 为了证明：**最大的插值一定不会来自于同一个桶**。\n \n   \n   \n   \n\n\n\n\n\n\n\n\n\n",[[1570584928541,["GJX@GJXAIOU",[[1,11526,"****"]],[11526,11526],[11528,11528]]],[1570584929866,["GJX@GJXAIOU",[[1,11528,"但是"]],[11528,11528],[11530,11530]]],[1570584994789,["GJX@GJXAIOU",[[1,11530,"空桶仅仅是用于否定最终答案不是在同一个桶中，但是不能保证"]],[11530,11530],[11558,11558]]],[1570584999941,["GJX@GJXAIOU",[[-1,11554,"不能保证"]],[11558,11558],[11554,11554]]],[1570585004006,["GJX@GJXAIOU",[[1,11554,"不是"]],[11554,11554],[11556,11556]]],[1570585012779,["GJX@GJXAIOU",[[-1,11554,"不是"]],[11556,11556],[11554,11554]]],[1570585208979,["GJX@GJXAIOU",[[1,11554,"不是答案一定就是在空庭"]],[11554,11554],[11565,11565]]],[1570585210390,["GJX@GJXAIOU",[[-1,11564,"庭"]],[11565,11565],[11564,11564]]],[1570585229768,["GJX@GJXAIOU",[[1,11564,"桶的两边；"]],[11564,11564],[11569,11569]]],[1570585323054,["GJX@GJXAIOU",[[1,11571,"示例：非空：19"]],[11571,11571],[11579,11579]]],[1570585324217,["GJX@GJXAIOU",[[-1,11578,"9"]],[11579,11579],[11578,11578]]],[1570585326430,["GJX@GJXAIOU",[[1,11578,"3，"]],[11578,11578],[11580,11580]]],[1570585327332,["GJX@GJXAIOU",[[-1,11579,"，"]],[11580,11580],[11579,11579]]],[1570585349273,["GJX@GJXAIOU",[[1,11579,",19；空；非空3"]],[11579,11579],[11588,11588]]],[1570585349356,["GJX@GJXAIOU",[[1,11587," "]],[11588,11588],[11589,11589]]],[1570585349704,["GJX@GJXAIOU",[[1,11589,"0"]],[11589,11589],[11590,11590]]],[1570585354916,["GJX@GJXAIOU",[[-1,11587," "]],[11588,11588],[11587,11587]]],[1570585356148,["GJX@GJXAIOU",[[1,11587,"："]],[11587,11587],[11588,11588]]],[1570585359112,["GJX@GJXAIOU",[[1,11590,"，"]],[11590,11590],[11591,11591]]],[1570585441771,["GJX@GJXAIOU",[[1,11591,"39；非空："]],[11591,11591],[11597,11597]]],[1570585550381,["GJX@GJXAIOU",[[1,11597,"59，"]],[11597,11597],[11600,11600]]],[1570585552555,["GJX@GJXAIOU",[[-1,11599,"，"]],[11600,11600],[11599,11599]]],[1570585573957,["GJX@GJXAIOU",[[1,11599,",63；不是空桶左右俩个的插值最大；"]],[11599,11599],[11617,11617]]],[1570585588567,["GJX@GJXAIOU",[[1,11628,"## "]],[11631,11631],[11634,11634]]],[1570585596203,["GJX@GJXAIOU",[[1,11634,"工程中的综合"]],[11634,11634],[11640,11640]]],[1570585600302,["GJX@GJXAIOU",[[1,11640,"排序算法"]],[11640,11640],[11644,11644]]],[1570585607384,["GJX@GJXAIOU",[[-1,11632,"  "]],[11634,11634],[11632,11632]]],[1570585610613,["GJX@GJXAIOU",[[1,11634,"\n"]],[11634,11634],[11635,11635]]],[1570585612044,["GJX@GJXAIOU",[[-1,11634,"\n"]],[11635,11635],[11634,11634]]],[1570585634178,["GJX@GJXAIOU",[[1,11644,"首先会判断"]],[11644,11644],[11649,11649]]],[1570585691679,["GJX@GJXAIOU",[[1,11649,"数据"]],[11649,11649],[11651,11651]]],[1570585692363,["GJX@GJXAIOU",[[-1,11649,"数据"]],[11651,11651],[11649,11649]]],[1570585696018,["GJX@GJXAIOU",[[1,11649,"数组的长苏"]],[11649,11649],[11654,11654]]],[1570585697226,["GJX@GJXAIOU",[[-1,11652,"长苏"]],[11654,11654],[11652,11652]]],[1570585699194,["GJX@GJXAIOU",[[1,11652,"长苏"]],[11652,11652],[11654,11654]]],[1570585699789,["GJX@GJXAIOU",[[-1,11652,"长苏"]],[11654,11654],[11652,11652]]],[1570585702807,["GJX@GJXAIOU",[[1,11652,"长度（）"]],[11652,11652],[11656,11656]]],[1570585711101,["GJX@GJXAIOU",[[1,11655,"一般界限为6"]],[11655,11655],[11661,11661]]],[1570585711183,["GJX@GJXAIOU",[[1,11660," "]],[11661,11661],[11662,11662]]],[1570585712258,["GJX@GJXAIOU",[[1,11662,"0"]],[11662,11662],[11663,11663]]],[1570585720555,["GJX@GJXAIOU",[[1,11664,"；"]],[11664,11664],[11665,11665]]],[1570585721890,["GJX@GJXAIOU",[[1,11673,"\n"]],[11665,11665],[11666,11666]]],[1570585800174,["GJX@GJXAIOU",[[1,11666,"如果数组长度较短，一般使用"]],[11666,11666],[11679,11679]]],[1570585967273,["GJX@GJXAIOU",[[1,11682,"优化目标，现有暗杆"]],[11682,11682],[11691,11691]]],[1570585968965,["GJX@GJXAIOU",[[-1,11689,"暗杆"]],[11691,11691],[11689,11689]]],[1570586005325,["GJX@GJXAIOU",[[1,11689,"方案，自己优化目标，验证方案，参考文献，综述，新奇"]],[11689,11689],[11714,11714]]],[1570586006009,["GJX@GJXAIOU",[[-1,11712,"新奇"]],[11714,11714],[11712,11712]]],[1570586013768,["GJX@GJXAIOU",[[1,11712,"5-6篇"]],[11712,11712],[11716,11716]]],[1570586013838,["GJX@GJXAIOU",[[1,11715," "]],[11716,11716],[11717,11717]]],[1570586014603,["GJX@GJXAIOU",[[1,11717,"的"]],[11717,11717],[11718,11718]]],[1570586184692,["GJX@GJXAIOU",[[1,11679,"插入排序，虽然插入排序的时间复杂度为；"]],[11679,11679],[11698,11698]]],[1570586185764,["GJX@GJXAIOU",[[-1,11697,"；"]],[11698,11698],[11697,11697]]],[1570586188660,["GJX@GJXAIOU",[[1,11697,"：$$"]],[11697,11697],[11700,11700]]],[1570586191339,["GJX@GJXAIOU",[[1,11699,"O()"]],[11699,11699],[11702,11702]]],[1570586195569,["GJX@GJXAIOU",[[1,11701,"{N"]],[11701,11701],[11703,11703]]],[1570586199296,["GJX@GJXAIOU",[[1,11703,"}……{"]],[11703,11703],[11707,11707]]],[1570586201387,["GJX@GJXAIOU",[[-1,11703,"}……{"]],[11707,11707],[11703,11703]]],[1570586208542,["GJX@GJXAIOU",[[1,11703,"}^{2}"]],[11703,11703],[11708,11708]]],[1570586214273,["GJX@GJXAIOU",[[1,11710," "]],[11710,11710],[11711,11711]]],[1570586229414,["GJX@GJXAIOU",[[1,11751,"技术的关键定"]],[11751,11751],[11757,11757]]],[1570586230091,["GJX@GJXAIOU",[[-1,11756,"定"]],[11757,11757],[11756,11756]]],[1570586231586,["GJX@GJXAIOU",[[1,11756,"点"]],[11756,11756],[11757,11757]]],[1570586282760,["GJX@GJXAIOU",[[1,11711,"但是因为数据量较小，因此 $$"]],[11711,11711],[11726,11726]]],[1570586285746,["GJX@GJXAIOU",[[1,11725,"O)("]],[11725,11725],[11728,11728]]],[1570586287186,["GJX@GJXAIOU",[[-1,11726,")("]],[11728,11728],[11726,11726]]],[1570586288195,["GJX@GJXAIOU",[[1,11726,"()"]],[11726,11726],[11728,11728]]],[1570586295342,["GJX@GJXAIOU",[[1,11727,"{N}^{2}"]],[11727,11727],[11734,11734]]],[1570586313650,["GJX@GJXAIOU",[[1,11736," 比 $$"]],[11736,11736],[11741,11741]]],[1570586323834,["GJX@GJXAIOU",[[1,11740,"lon"]],[11740,11740],[11743,11743]]],[1570586324609,["GJX@GJXAIOU",[[-1,11742,"n"]],[11743,11743],[11742,11742]]],[1570586336720,["GJX@GJXAIOU",[[1,11742,"g_{2}^{N}"]],[11742,11742],[11751,11751]]],[1570586343194,["GJX@GJXAIOU",[[1,11752,"吧"]],[11752,11752],[11753,11753]]],[1570586344026,["GJX@GJXAIOU",[[-1,11752,"吧"]],[11753,11753],[11752,11752]]],[1570586350305,["GJX@GJXAIOU",[[1,11752,"不会插件"]],[11752,11752],[11756,11756]]],[1570586350969,["GJX@GJXAIOU",[[-1,11754,"插件"]],[11756,11756],[11754,11754]]],[1570586367180,["GJX@GJXAIOU",[[1,11754,"差距很大，"]],[11754,11754],[11759,11759]]],[1570586420567,["GJX@GJXAIOU",[[1,11759,"但是因为插入排序的常数项很低，英雌"]],[11759,11759],[11776,11776]]],[1570586421304,["GJX@GJXAIOU",[[-1,11774,"英雌"]],[11776,11776],[11774,11774]]],[1570586434051,["GJX@GJXAIOU",[[1,11774,"因此整体的时间复杂度"]],[11774,11774],[11784,11784]]],[1570586437532,["GJX@GJXAIOU",[[1,11784,"较低；"]],[11784,11784],[11787,11787]]],[1570586438402,["GJX@GJXAIOU",[[1,11790,"\n"]],[11787,11787],[11788,11788]]],[1570586442044,["GJX@GJXAIOU",[[1,11644,"- "]],[11644,11644],[11646,11646]]],[1570586444187,["GJX@GJXAIOU",[[1,11668,"- "]],[11668,11668],[11670,11670]]],[1570586444557,["GJX@GJXAIOU",[[1,11668,"  "]],[11670,11670],[11672,11672]]],[1570586463733,["GJX@GJXAIOU",[[1,11794,"  - 如果数组长度较长，"]],[11794,11794],[11807,11807]]],[1570586474718,["GJX@GJXAIOU",[[-1,11806,"，"]],[11807,11807],[11806,11806]]],[1570586476194,["GJX@GJXAIOU",[[1,11807,"  - \n"]],[11806,11806],[11811,11811]]],[1570586477252,["GJX@GJXAIOU",[[1,11809,"  "]],[11811,11811],[11813,11813]]],[1570586495318,["GJX@GJXAIOU",[[1,11813,"首先判断数组中装的数据类型"]],[11813,11813],[11826,11826]]],[1570586497621,["GJX@GJXAIOU",[[1,11827,"    - \n"]],[11826,11826],[11833,11833]]],[1570586498375,["GJX@GJXAIOU",[[1,11831,"  "]],[11833,11833],[11835,11835]]],[1570586524005,["GJX@GJXAIOU",[[1,11835,"如果是基础数据类型：使用快排，因为其祥同志"]],[11835,11835],[11856,11856]]],[1570586525170,["GJX@GJXAIOU",[[-1,11853,"祥同志"]],[11856,11856],[11853,11853]]],[1570586555084,["GJX@GJXAIOU",[[1,11853,"相同值没有区分，因此不必考虑"]],[11853,11853],[11867,11867]]],[1570586677601,["GJX@GJXAIOU",[[1,11867,"问到底哪些"]],[11867,11867],[11872,11872]]],[1570586680292,["GJX@GJXAIOU",[[-1,11867,"问到底哪些"]],[11872,11872],[11867,11867]]],[1570586682874,["GJX@GJXAIOU",[[1,11867,"稳定性；"]],[11867,11867],[11871,11871]]],[1570586683464,["GJX@GJXAIOU",[[1,11872,"      - \n"]],[11871,11871],[11880,11880]]],[1570586685450,["GJX@GJXAIOU",[[1,11880,"乳沟"]],[11880,11880],[11882,11882]]],[1570586686957,["GJX@GJXAIOU",[[-1,11880,"乳沟"]],[11882,11882],[11880,11880]]],[1570586695022,["GJX@GJXAIOU",[[1,11880,"如果是自定义数据类型：说过"]],[11880,11880],[11893,11893]]],[1570586697230,["GJX@GJXAIOU",[[-1,11891,"说过"]],[11893,11893],[11891,11891]]],[1570586714615,["GJX@GJXAIOU",[[1,11891,"使用归并排序，因为即使"]],[11891,11891],[11902,11902]]],[1570586774909,["GJX@GJXAIOU",[[1,11902,"相同值也是有区别的，要保证稳定性；"]],[11902,11902],[11919,11919]]],[1570586803498,["GJX@GJXAIOU",[[1,11920,"      - \n"]],[11919,11919],[11928,11928]]],[1570586805954,["GJX@GJXAIOU",[[-1,11924,"  "]],[11928,11928],[11926,11926]]],[1570586838669,["GJX@GJXAIOU",[[1,11926,"然后如果使用快排的话，因为快排使用根治"]],[11926,11926],[11945,11945]]],[1570586840071,["GJX@GJXAIOU",[[-1,11943,"根治"]],[11945,11945],[11943,11943]]],[1570586855982,["GJX@GJXAIOU",[[1,11943,"分治划分的思想，因此在"]],[11943,11943],[11954,11954]]],[1570586860522,["GJX@GJXAIOU",[[1,11954,"递归的时候"]],[11954,11954],[11959,11959]]],[1570586986258,["GJX@GJXAIOU",[[1,11959,"乳沟"]],[11959,11959],[11961,11961]]],[1570586986993,["GJX@GJXAIOU",[[-1,11959,"乳沟"]],[11961,11961],[11959,11959]]],[1570587007510,["GJX@GJXAIOU",[[1,11959,"如果划分多次之后数组长度较少"]],[11959,11959],[11973,11973]]],[1570587008144,["GJX@GJXAIOU",[[-1,11971,"较少"]],[11973,11973],[11971,11971]]],[1570587010274,["GJX@GJXAIOU",[[1,11971,"坚守"]],[11971,11971],[11973,11973]]],[1570587012196,["GJX@GJXAIOU",[[-1,11971,"坚守"]],[11973,11973],[11971,11971]]],[1570587021341,["GJX@GJXAIOU",[[1,11971,"减少到一定长度*"]],[11971,11971],[11979,11979]]],[1570587022374,["GJX@GJXAIOU",[[-1,11978,"*"]],[11979,11979],[11978,11978]]],[1570587023019,["GJX@GJXAIOU",[[1,11978,"（）"]],[11978,11978],[11980,11980]]],[1570587025367,["GJX@GJXAIOU",[[1,11979,"如果"]],[11979,11979],[11981,11981]]],[1570587026959,["GJX@GJXAIOU",[[-1,11979,"如果"]],[11981,11981],[11979,11979]]],[1570587029088,["GJX@GJXAIOU",[[1,11979,"例如6"]],[11979,11979],[11982,11982]]],[1570587029170,["GJX@GJXAIOU",[[1,11981," "]],[11982,11982],[11983,11983]]],[1570587029413,["GJX@GJXAIOU",[[1,11983,"0"]],[11983,11983],[11984,11984]]],[1570587035240,["GJX@GJXAIOU",[[1,11985,"，则"]],[11985,11985],[11987,11987]]],[1570587042384,["GJX@GJXAIOU",[[1,11987,"直接使用插入怕U型；"]],[11987,11987],[11997,11997]]],[1570587043822,["GJX@GJXAIOU",[[-1,11993,"怕U型；"]],[11997,11997],[11993,11993]]],[1570587045876,["GJX@GJXAIOU",[[1,11993,"排序；"]],[11993,11993],[11996,11996]]]],null,"GJX@GJXAIOU"],["5c0a9593-898b-4c18-af32-27800681563f",1570588349266,"# AlgorithmEasyDay02\n\n**例题：**\n问题一：分割数组\n给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)；\n![示例]($resource/%E7%A4%BA%E4%BE%8B.png)\n其中 x 坐标为 L - 1，<=x 位置上放置的都是 <= num 值的数，然后依次向右遍历，如果该数大于 num，则 x 不动，直接判断下一个数，如果该数小于等于 num，则该数和 x + 1 位置上的数互换， x 向右移动一位，即 x + 1，然后继续判断下一个数；以此类推；\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-07-15:03\n */\npublic class SplitArray {\n    public static void sort(int[] sourceArray, int left, int right, int tagMum){\n        int less = left - 1;\n        while(left < right){\n            if(sourceArray[left] <= tagMum){\n                swap(sourceArray, left++, ++less);\n            }\n            if(sourceArray [left] > tagMum){\n                left++;\n            }\n        }\n        return ;\n    }\n\n    public static void swap(int[] sourceArray, int left, int right) {\n        if(left == right){\n            return;\n        }\n        sourceArray[left] = sourceArray[left] ^ sourceArray[right];\n        sourceArray[right] = sourceArray[left] ^ sourceArray[right];\n        sourceArray[left] = sourceArray[left] ^ sourceArray[right];\n    }\n\n    // 测试方法\n    public static void main(String[] args) {\n        int[] sourceArray ={1,2,8,4,9,3,1,4,3,2,7};\n        int left = 0;\n        int right = sourceArray.length - 1;\n        int tagMum = 6;\n\n        System.out.println(\"原数组为：\");\n        for (int i : sourceArray) {\n            System.out.print(i + \" \");\n        }\n\n        sort(sourceArray, left, right, tagMum);\n\n        System.out.println(\"\\n分割之后数组为：\");\n        for (int i : sourceArray) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n\n```\n\n\n问题二（荷兰国旗问题）\n给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)\n![示例2]($resource/%E7%A4%BA%E4%BE%8B2.png)\n\nx 坐标为 L - 1，y 坐标为 R + 1，两边分别表示小于 num 和大于 num 的值，当前位置坐标为 cur，然后依次向右遍历，如果该数小于 num，则该数和小于区域最右边下标（x）的下一个坐标元素交换，小于区域向右扩充（即 x + 1），如果该数等于 num ,则 cur 指向下一个元素，如果大于 num，则该数和大于区域最左边区域的前一个坐标元素交换，大于区域向左扩充一个（即 y - 1），然后这里**交换回来的数还需要按照上面的标准进行判断**，直到 cur 和 又边界相遇停止；\n\n```java\npackage sort.nowcoder.easy.day01;\n\npublic class NetherlandsFlag {\n\t/**\n\t * @param sourceArray：要分割的数组\n\t * @param left：小于 tagNum 区域最右边数\n\t * @param right：大于 tagNum 区域最左边数\n\t * @param tagNum：用于分割的参考数字\n\t * @return\n\t */\n\tpublic static int[] partition(int[] sourceArray, int left, int right, int tagNum) {\n\t\t// less 表示小于 tagNum 区域最右边数，more 是大于 tagNum 区域最左边数\n\t\tint less = left - 1;\n\t\tint more = right + 1;\n\t\twhile (left < more) {\n\t\t\tif (sourceArray[left] < tagNum) {\n\t\t\t\tswap(sourceArray, ++less, left++);\n\t\t\t} else if (sourceArray[left] > tagNum) {\n\t\t\t\tswap(sourceArray, --more, left);\n\t\t\t} else {\n\t\t\t\tleft++;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { less + 1, more - 1 };\n\t}\n\t\n\tpublic static void swap(int[] sourceArray, int left, int right) {\n\t\tint tmp = sourceArray[left];\n\t\tsourceArray[left] = sourceArray[right];\n\t\tsourceArray[right] = tmp;\n\t}\n}\n```\n\n\n\n## 二、快速排序\n### 经典快排\n首先以数组最后一个数值为基准，将小于等于该数值的全部放在数组前半部分，大于该数值的全部放在数组的后半部分，然后前半部分和后半部分分别以该部分最后一个元素为基准重复以上步骤；\n\n**改进**：使用荷兰国旗思想\n首先还是选取数组最后一个值为基准，但是遍历判断的时候最后一个值不再进行判断，即只有 L ~ R - 1 的值与基准进行比较，同时区域划分为三个区域：小于基准、等于基准、大于基准；然后将小于基准和大于基准部分进行再次取最后一个数，同上进行比较.....最后全部比较结束之后，将最后一个基准值放在大于该基准的范围的前一个位置；\n\n\n特点：\n- 经典快排和数据的状态有关：\n  - 当小于最后一个数值的元素远大于大于最后一个数组的元素个数时候，或者反之情况，时间复杂度都是：$O({N}^{2})$\n  - 如果数据状态较好，即大于和小于差不多的情况下，时间复杂度为：$T(N) = 2T(\\frac{N}{2}) + O(N) = O(N * log_{2}^{N})$\n\n经典快排的空间复杂度为：$O(N)$\n\n### 随机快速排序\n通过随机选一个数和最后一个数进行互换，使得每次划分标准都在改变；\n根据随机性，随机快速排序的时间复杂度是：$O(N * \\log_{2}^{N})$，同时需要空间复杂度为：$O(\\log_{2}^{N})$，这里的额外空间主要用于记录每次划分区域的断点；\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-04-20:08\n */\n\nimport java.util.Arrays;\n\npublic class QuickSort {\n    /**\n     *  首先调用该方法，可以设置排序的区间，默认为 0 ~ length-1；\n     * @param sourceArray：需要排序的数组\n     */\n    public static void quickSort(int[] sourceArray) {\n        if (sourceArray == null || sourceArray.length < 2) {\n            return;\n        }\n        quickSort(sourceArray, 0, sourceArray.length - 1);\n    }\n\n    /**\n     * @param sourceArray：需要排序的数组\n     * @param left：排序数组左边界，一般为：0\n     * @param right：排序数组右边界，一般为：length - 1;\n     *  less：小于参照元素区域的最右边边界：less = p[0] - 1;\n     *  more：大于参照元素区域的最左边边界：more = p[1] + 1;\n     *  p[0]：等于参照元素区域的最左边边界；\n     *  p[1]：等于参数元素区域的最右边边界；\n     *  小于参照元素区域：[Left ~ less];\n     *  等于参照元素区域：[p[0] ~ p[1]]；\n     *  大于参照元素区域：[more ~ right]；\n     */\n    public static void quickSort(int[] sourceArray, int left, int right) {\n        if (left < right) {\n            swap(sourceArray, left + (int) (Math.random() * (right - left + 1)), right);\n            // p 数组中： p[0] 表示等于区域的左边界，p[1] 表示等于区域的右边界，\n            // 左边区域：L ~ p[0] - 1;右边区域： p[1] + 1 ~ R;\n            int[] p = partition(sourceArray, left, right);\n            quickSort(sourceArray, left, p[0] - 1);\n            quickSort(sourceArray, p[1] + 1, right);\n        }\n    }\n\n    public static int[] partition(int[] sourceArray, int left, int right) {\n        int less = left - 1;\n        int more = right;\n        while (left < more) {\n            if (sourceArray[left] < sourceArray[right]) {\n                swap(sourceArray, ++less, left++);\n            } else if (sourceArray[left] > sourceArray[right]) {\n                swap(sourceArray, --more, left);\n            } else {\n                left++;\n            }\n        }\n        swap(sourceArray, more, right);\n        return new int[] { less + 1, more };\n    }\n\n    public static void swap(int[] sourceArray, int left, int right) {\n        int tmp = sourceArray[left];\n        sourceArray[left] = sourceArray[right];\n        sourceArray[right] = tmp;\n    }\n```\n\n\n\n\n## 堆排序\n\n### 堆\n堆是一个完全二叉树，可以采用数组进行实现；\n对于完全二叉树，结点 i 的左孩子序号为：2i + 1；右孩子序号为：2i + 2；父结点的序号为：$\\frac{i - 1}{2}$，\n\n分类：\n- 大根堆：每棵树（包括任意一棵子树）的最大值都是其头部（父结点）；\n- 小根堆：每棵树（包括任意一棵子树）的最小值都是其头部（父结点）；\n\n**完全二叉树**：对一棵具有 n 个节点的二叉树按照层序进行编号，如果编号 i （1<=i<=n）的结点与同样深度的满二叉树中编号为 i 的结点位置完全相同；\n**满二叉树**：所有的分支结点都存在左子树和右子树，且所有的叶子都在同一层；\n\n### 数组转换为大根堆\n以数组 [2,1,3,6,0,4]为例：\n首先取出第一元素 2，然后取出第二个元素 1，该元素比 2 小，放在左孩子位置，数组元素为：[2,1]；然后取出第三个元素 3，计算该元素的父结点：$\\frac{2 - 1}{2} = 0$，则与 0 位置元素 2 进行比较，发现 3 比较大，则在数组中将 3 和 2 两个元素互换，则数组变为：[3,1,2]；然后取出第四个元素 6，计算父结点下标为：$\\frac{3 - 1}{2} = 1$，则与 1 位置的元素 1 进行比较，发现 6 比较大，则将元素 1 和元素 6 互换，得到[3,6,2,1]，然后再比较元素 6 和其父结点：$\\frac{1 - 1}{2} = 0$，比较得出 6 比 3 大，然后再换，最后得到数组为：[6,3,2,1]，剩下元素依次类推......\n\n每加入一个节点其最多比较的次数和已经形成的二叉树高度有关（因为每次只和其父结点比较），因此最多时间复杂度为：$O(log_{2}^{N})$，所有整个转换过程时间复杂度为：$log_{2}^{1} + log_{2}^{2} + ..... + log_{2}^{N} = O(N)$\n\n\n**题目**\n吐泡泡：一个 XXX 会不停的吐出数字，求任意时刻的已经吐出的所有元素的中位数；\n\n**解答：**\n这里需要同时使用大根堆和小根堆，大根堆中存放着较小的 $\\frac{N}{2}$个元素，小根堆中存放较大的  $\\frac{N}{2}$个元素；\n\n这里以：5 4 6 7 为例\n首先将 5 放入大根堆，计算大根堆和小根堆的 Heapsize，插值为 1,不动， 然后因为 4 小于等于大根堆的堆顶，因此放入大根堆，再次计算 HeapSize，插值 > 1，然后将大根堆的堆顶放在小根堆，然后将大根堆剩余的调整为大根堆，然后元素 6 大于大根堆现在堆顶 4，因此放入小根堆；现在大根堆为 4，小根堆为 5,6；插值为 1，然后放入元素 7，同样大于大根堆堆顶，放入小根堆，然后插值> 1，将小根堆的堆顶放入大根堆末尾，小根堆重新排为：6,7；大根堆重新排为：5,4；中位数就是两个堆顶的平均值；\n\n\n### 堆排序\n首先将数组变成大根堆；\n然后将堆中最后一个和堆顶进行交换，堆大小减一，则最后一个不动了，然后将剩下的前面进行 Heapify 调整；\n然后再将堆的最后一个和堆顶进行交换，同上.....;\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-04-20:08\n */\nimport java.util.Arrays;\n\npublic class HeapSort {\n\n    public static void heapSort(int[] arr) {\n        if (arr == null || arr.length < 2) {\n            return;\n        }\n        // 首先将数组转化为大根堆；0 到  i 之间形成大根堆\n        for (int i = 0; i < arr.length; i++) {\n            heapInsert(arr, i);\n        }\n\n        // 不断将堆顶的元素和最后一个元素交换然后进行 heapify 过程\n        int size = arr.length;\n        swap(arr, 0, --size);\n        while (size > 0) {\n            heapify(arr, 0, size);\n            swap(arr, 0, --size);\n        }\n    }\n\n    public static void heapInsert(int[] arr, int index) {\n        // 如果插入的新节点值大于其父结点大小\n        while (arr[index] > arr[(index - 1) / 2]) {\n            swap(arr, index, (index - 1) / 2);\n            index = (index - 1) / 2;\n        }\n    }\n\n    /**\n     * size - 1 到 length - 1 位置上已经拍好\n     * @param arr：要排序的数组\n     * @param index：哪个节点位置上元素发生了变化，传入的初始值一直为0\n     * @param size：还没有排好序的数组长度\n     */\n    public static void heapify(int[] arr, int index, int size) {\n        // size 表示当前堆上节点数\n        int left = index * 2 + 1;\n        // 越界表示已经是叶子结点了\n        while (left < size) {\n            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;\n            largest = arr[largest] > arr[index] ? largest : index;\n            if (largest == index) {\n                break;\n            }\n            swap(arr, largest, index);\n            index = largest;\n            left = index * 2 + 1;\n        }\n    }\n\n    public static void swap(int[] arr, int left, int right) {\n        int tmp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = tmp;\n    }\n}    \n```\n\n\n**概念：**\n- HeapInsert：将新的节点加入堆中同时按照堆的结构进行向上调整的过程；\n-  HeapSize：堆的大小；对应数组中就是 0-i 位置;\n- Heapify：假设堆中（数组中）某个值发生了变化，让其整体再次调整为大根堆（或小根堆）原来的样子的过程；\n  首先找到变化的值的两个孩子，然后找到其中较大的一个与之交换，如果有交换，在新的位置上再次找现在的两个孩子进行比较，然后交换，一直到没有交换为止；\n- 堆减小的过程：以大根堆为例：首先将堆顶元素和堆的最后一个元素位置互换，这样原来堆顶的元素就放在了数组的最后，然后将堆的 Heapsize - 1，这样最后一个元素就应为超过了现在的 HeapSize 而越界，从而失效；然后将剩余的 0 ~ i - 1 位置的按照 Heapify 重新进行调整（因为堆顶的元素值发生了变化）为原来的堆结构；\n\n\n## 排序算法的稳定性\n\n首先总结现有排序算法稳定性\n算法名称 | 时间复杂度 | 算法种类 | 是否稳定 | 原因\n---|---|---|---|---\n冒泡排序|$O({N}^{2})$|基于比较|稳定 |在冒泡的时候，如果遇到前后相同的值两者不交换即可，只有前者比后者大才交换；\n插入排序|$O({N}^{2})$|基于比较|稳定 |同样在比较的时候，相同的值不交换即可；\n选择排序|$O({N}^{2})$|基于比较| 不稳定 |因为如果后面有小于前面的，就和前面的互换，如果有几个相同数，则相当于和最前面的数进行互换，这样顺序就乱了；\n归并排序|$O(N * log_{2}^{N})$ |基于比较  |稳定 |以为归并之前是左右两个数组，左边数组在原数组中就是在左边，右边数组原来就是右边，这样只需要如果左右两个数组中有相同的数字，则只需要先拷贝左边数组值，然后拷贝右边数组中值即可；\n快速排序 | $O(N * log_{2}^{N})$ |基于比较  |不稳定（也可以稳定） |因为 partition 过程就是交换，肯定是无序的；\n堆排序 | $O(N * log_{2}^{N})$ |基于比较  |不稳定 | 因为在形成大根堆的时候，叶子结点与根节点进行交换的时候就会序号乱，例如：2,2,3；当放入 3 的时候，两个 2 的顺序就改变了；   \n桶排序|$O(N)$|非基于比较 |稳定 |   \n基数排序|$O(N)$|非基于比较 |稳定 |   \n计数排序|$O(N)$|非基于比较 |稳定 |   \n\n   \n**排序问题补充：**\n   \n- 归并排序的空间复杂度可以变成 O(1)，可以采用 “归并排序 内部缓存法”实现，但是仅仅要求了解即可；\n- 快速排序可以做到稳定性，采用“01 stable sort”；\n- 荷兰国旗问题不可能稳定，因为明显存在交换；\n问题：将一个数组的奇数放在数组左边，偶数放在数组右边，并且要求原始的相对次序不变，时间复杂度要求：O(N)，空间复杂度要求：O(1)；\n**解析：**   因为每一个数不是奇数就是偶数，因此也是可以抽象为一个 0 1 问题，相当于把 0 类（例如 < 0.5 的，这里 0.5 是随便取，就是为了区分）的放在左边，把大于 0.5 的放在右边，即 1 类 ；且保证原来的相对顺序不变，抽象就是快排的 partition 过程保证稳定；因为 partition 过程就是将一个数组分为 <= 和 > 两个部分，也是 0  1 过程，如果上述满足就可以实现快排稳定；只能采用 01 stable sort 解决；\n   \n\n## 认识比较器\n比较器作用：自己实现比较自己定义的对象的方法，然后通过将其传入**系统中有序的结构**就可以处理自己定义类型的比较；\n\n例如：使用优先级队列（实质上就是堆）存放自定义对象，然后自定义比较器使得可以比较自定义的类型对象；\n\n\n## 非基于比较的排序\n### 桶排序\n桶排序仅仅是一种概念，整体思想是首先记录数据各状况出现的词频，然后根据词频进行还原从而达到排序目的；\n它的具体实现有：计数排序、基数排序；\n\n\n### 计数排序\n**有多少个元素就需要多少个桶；**\n示例：有一个元素值范围为：0 ~ N 的数组，将其排序；\n步骤：首先准备一个长度为 N + 1 的辅助数组；辅助数组下标分别为：0 ~ N；\n然后遍历原数组，有一个 X 值（大小位于 0~N 之间），就在辅助数组下标为 X 的对应元素值 + 1；一直遍历结束；\n最后将辅助数组中各个下标对应的元素值还原，示例：辅助数组为：`[1,2,0,2]`就相当于有 1 个 0,2 个 1,0 个 3,2 个 4，因此结果为：`[0,1,1,4,4]`；\n\n\n\n### 基数排序\n\n\n\n\n\n**补充示例：** 给定一个数组，求如果排序之后相邻两个元素的最大差值，要求时间复杂度为 O(N)，且不能用非基于比较的排序；\n**解答：**\n- 思想：借用桶的思想，但是不使用桶排序；\n- 思路：\n  - 准备桶，原数组中有 N 个元素，因此准备 N+1 个桶；\n  - 遍历原数组，找到原数组中的最小值和最大值，分别放在第 0 号桶和第 N 号桶中；如果最大值等于最小值，直接返回 0 结束；\n  - 将新数组（桶）的 0 ~ N 部分等分为 N+ 1 份，原数组中值属于哪一个部分就放在哪一个桶中；示例：如果原数组一共 9 个数，则准备 10 个桶，且第一个桶中放的是数组最小值 0（假定），最后一个桶放的是最大值 99（假定），则将 0 ~ 99 等分为 10 份，则原数组中出现 0 ~ 9 直接的数放在 0 号桶，出现 10 ~ 19 之间的数放在 1 号桶。。。；\n  - 每个桶只保留三个值：一个 Boolean 值，用于判断该桶中是否有元素，一个 min，表示桶中的最小值，一个 max ，表示桶中的最大值；因此如果元素 X 进入 7 号桶，如果 7 号桶之前没有元素，则首先将 Boolean 值置为 true，然后 min = x，max = x；当又一个元素进入 7 号桶的时候，比较桶内元素的值，更新最大值和最小值，其他值扔掉；\n  - 最后遍历所有的桶，如果遇到空桶，跳到下一个进行判断，如果是非空桶，找到其左边最近的非空桶，将后一个非空的 min - 前一个非空的 max，插值进行保存，然后比较所有的插值，取最大的就是最大插值，\n\n- 原理：因为 0 号桶非空，N 号桶非空，但是只有 N 个数，因此**中间至少有一个桶是空的**，同时任何两个相邻的数可以来自于同一个桶，也可能来自于不同的桶；\n  - 为什么要设置一个空桶：因为至少有一个桶为空，则距离空桶左右最近的两个非空桶：左非空 min .... 左非空 max 。。。空桶 。。。右非空 min....右非空 max，则右非空 min - 左非空 max 的插值一定大于桶内插值，因为其值至少是一个桶的长度，而同一个桶内元素之间的插值是不会大于桶长的， 为了证明：**最大的插值一定不会来自于同一个桶**。**但是空桶仅仅是用于否定最终答案不是在同一个桶中，但是不是答案一定就是在空桶的两边；**示例：非空：13,19；空；非空：30，39；非空：59,63；不是空桶左右俩个的插值最大；\n \n   \n   \n##  工程中的综合排序算法\n\n- 首先会判断数组的长度（一般界限为 60）；\n  - 如果数组长度较短，一般使用插入排序，虽然插入排序的时间复杂度为：$O({N}^{2})$ 但是因为数据量较小，因此 $O({N}^{2})$ 比 $log_{2}^{N}$不会差距很大，但是因为插入排序的常数项很低，因此整体的时间复杂度较低；\n  - 如果数组长度较长\n    - 首先判断数组中装的数据类型\n      - 如果是基础数据类型：使用快排，因为其相同值没有区分，因此不必考虑稳定性；\n      - 如果是自定义数据类型：使用归并排序，因为即使相同值也是有区别的，要保证稳定性；\n    - 然后如果使用快排的话，因为快排使用分治划分的思想，因此在递归的时候如果划分多次之后数组长度减少到一定长度（例如 60），则直接使用插入排序；\n\n\n优化目标，现有方案，自己优化目标，验证方案，参考文献，综述，5-6 篇的\n技术的关键点\n\n\n\n",[[1570588319234,["GJX@GJXAIOU",[[1,12043,"先走"]],[12043,12043],[12045,12045]]],[1570588319891,["GJX@GJXAIOU",[[-1,12043,"先走"]],[12045,12045],[12043,12043]]],[1570588325316,["GJX@GJXAIOU",[[1,12043,"下周写完综述"]],[12043,12043],[12049,12049]]],[1570588328412,["GJX@GJXAIOU",[[1,12043,"\n"]],[12043,12043],[12044,12044]]],[1570588330761,["GJX@GJXAIOU",[[1,12053,"\n"]],[12050,12050],[12051,12051]]]],null,"GJX@GJXAIOU"],["58758239-653c-4407-9cb5-306ec86f9edc",1570675219610,"# AlgorithmEasyDay02\n\n**例题：**\n问题一：分割数组\n给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)；\n![示例]($resource/%E7%A4%BA%E4%BE%8B.png)\n其中 x 坐标为 L - 1，<=x 位置上放置的都是 <= num 值的数，然后依次向右遍历，如果该数大于 num，则 x 不动，直接判断下一个数，如果该数小于等于 num，则该数和 x + 1 位置上的数互换， x 向右移动一位，即 x + 1，然后继续判断下一个数；以此类推；\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-07-15:03\n */\npublic class SplitArray {\n    public static void sort(int[] sourceArray, int left, int right, int tagMum){\n        int less = left - 1;\n        while(left < right){\n            if(sourceArray[left] <= tagMum){\n                swap(sourceArray, left++, ++less);\n            }\n            if(sourceArray [left] > tagMum){\n                left++;\n            }\n        }\n        return ;\n    }\n\n    public static void swap(int[] sourceArray, int left, int right) {\n        if(left == right){\n            return;\n        }\n        sourceArray[left] = sourceArray[left] ^ sourceArray[right];\n        sourceArray[right] = sourceArray[left] ^ sourceArray[right];\n        sourceArray[left] = sourceArray[left] ^ sourceArray[right];\n    }\n\n    // 测试方法\n    public static void main(String[] args) {\n        int[] sourceArray ={1,2,8,4,9,3,1,4,3,2,7};\n        int left = 0;\n        int right = sourceArray.length - 1;\n        int tagMum = 6;\n\n        System.out.println(\"原数组为：\");\n        for (int i : sourceArray) {\n            System.out.print(i + \" \");\n        }\n\n        sort(sourceArray, left, right, tagMum);\n\n        System.out.println(\"\\n分割之后数组为：\");\n        for (int i : sourceArray) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n\n```\n\n\n问题二（荷兰国旗问题）\n给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。\n要求额外空间复杂度O(1)，时间复杂度O(N)\n![示例2]($resource/%E7%A4%BA%E4%BE%8B2.png)\n\nx 坐标为 L - 1，y 坐标为 R + 1，两边分别表示小于 num 和大于 num 的值，当前位置坐标为 cur，然后依次向右遍历，如果该数小于 num，则该数和小于区域最右边下标（x）的下一个坐标元素交换，小于区域向右扩充（即 x + 1），如果该数等于 num ,则 cur 指向下一个元素，如果大于 num，则该数和大于区域最左边区域的前一个坐标元素交换，大于区域向左扩充一个（即 y - 1），然后这里**交换回来的数还需要按照上面的标准进行判断**，直到 cur 和 又边界相遇停止；\n\n```java\npackage sort.nowcoder.easy.day01;\n\npublic class NetherlandsFlag {\n\t/**\n\t * @param sourceArray：要分割的数组\n\t * @param left：小于 tagNum 区域最右边数\n\t * @param right：大于 tagNum 区域最左边数\n\t * @param tagNum：用于分割的参考数字\n\t * @return\n\t */\n\tpublic static int[] partition(int[] sourceArray, int left, int right, int tagNum) {\n\t\t// less 表示小于 tagNum 区域最右边数，more 是大于 tagNum 区域最左边数\n\t\tint less = left - 1;\n\t\tint more = right + 1;\n\t\twhile (left < more) {\n\t\t\tif (sourceArray[left] < tagNum) {\n\t\t\t\tswap(sourceArray, ++less, left++);\n\t\t\t} else if (sourceArray[left] > tagNum) {\n\t\t\t\tswap(sourceArray, --more, left);\n\t\t\t} else {\n\t\t\t\tleft++;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { less + 1, more - 1 };\n\t}\n\t\n\tpublic static void swap(int[] sourceArray, int left, int right) {\n\t\tint tmp = sourceArray[left];\n\t\tsourceArray[left] = sourceArray[right];\n\t\tsourceArray[right] = tmp;\n\t}\n}\n```\n\n\n\n## 二、快速排序\n### 经典快排\n首先以数组最后一个数值为基准，将小于等于该数值的全部放在数组前半部分，大于该数值的全部放在数组的后半部分，然后前半部分和后半部分分别以该部分最后一个元素为基准重复以上步骤；\n\n**改进**：使用荷兰国旗思想\n首先还是选取数组最后一个值为基准，但是遍历判断的时候最后一个值不再进行判断，即只有 L ~ R - 1 的值与基准进行比较，同时区域划分为三个区域：小于基准、等于基准、大于基准；然后将小于基准和大于基准部分进行再次取最后一个数，同上进行比较.....最后全部比较结束之后，将最后一个基准值放在大于该基准的范围的前一个位置；\n\n\n特点：\n- 经典快排和数据的状态有关：\n  - 当小于最后一个数值的元素远大于大于最后一个数组的元素个数时候，或者反之情况，时间复杂度都是：$O({N}^{2})$\n  - 如果数据状态较好，即大于和小于差不多的情况下，时间复杂度为：$T(N) = 2T(\\frac{N}{2}) + O(N) = O(N * log_{2}^{N})$\n\n经典快排的空间复杂度为：$O(N)$\n\n### 随机快速排序\n通过随机选一个数和最后一个数进行互换，使得每次划分标准都在改变；\n根据随机性，随机快速排序的时间复杂度是：$O(N * \\log_{2}^{N})$，同时需要空间复杂度为：$O(\\log_{2}^{N})$，这里的额外空间主要用于记录每次划分区域的断点；\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-04-20:08\n */\n\nimport java.util.Arrays;\n\npublic class QuickSort {\n    /**\n     *  首先调用该方法，可以设置排序的区间，默认为 0 ~ length-1；\n     * @param sourceArray：需要排序的数组\n     */\n    public static void quickSort(int[] sourceArray) {\n        if (sourceArray == null || sourceArray.length < 2) {\n            return;\n        }\n        quickSort(sourceArray, 0, sourceArray.length - 1);\n    }\n\n    /**\n     * @param sourceArray：需要排序的数组\n     * @param left：排序数组左边界，一般为：0\n     * @param right：排序数组右边界，一般为：length - 1;\n     *  less：小于参照元素区域的最右边边界：less = p[0] - 1;\n     *  more：大于参照元素区域的最左边边界：more = p[1] + 1;\n     *  p[0]：等于参照元素区域的最左边边界；\n     *  p[1]：等于参数元素区域的最右边边界；\n     *  小于参照元素区域：[Left ~ less];\n     *  等于参照元素区域：[p[0] ~ p[1]]；\n     *  大于参照元素区域：[more ~ right]；\n     */\n    public static void quickSort(int[] sourceArray, int left, int right) {\n        if (left < right) {\n            swap(sourceArray, left + (int) (Math.random() * (right - left + 1)), right);\n            // p 数组中： p[0] 表示等于区域的左边界，p[1] 表示等于区域的右边界，\n            // 左边区域：L ~ p[0] - 1;右边区域： p[1] + 1 ~ R;\n            int[] p = partition(sourceArray, left, right);\n            quickSort(sourceArray, left, p[0] - 1);\n            quickSort(sourceArray, p[1] + 1, right);\n        }\n    }\n\n    public static int[] partition(int[] sourceArray, int left, int right) {\n        int less = left - 1;\n        int more = right;\n        while (left < more) {\n            if (sourceArray[left] < sourceArray[right]) {\n                swap(sourceArray, ++less, left++);\n            } else if (sourceArray[left] > sourceArray[right]) {\n                swap(sourceArray, --more, left);\n            } else {\n                left++;\n            }\n        }\n        swap(sourceArray, more, right);\n        return new int[] { less + 1, more };\n    }\n\n    public static void swap(int[] sourceArray, int left, int right) {\n        int tmp = sourceArray[left];\n        sourceArray[left] = sourceArray[right];\n        sourceArray[right] = tmp;\n    }\n```\n\n\n\n\n## 堆排序\n\n### 堆\n堆是一个完全二叉树，可以采用数组进行实现；\n对于完全二叉树，结点 i 的左孩子序号为：2i + 1；右孩子序号为：2i + 2；父结点的序号为：$\\frac{i - 1}{2}$，\n\n分类：\n- 大根堆：每棵树（包括任意一棵子树）的最大值都是其头部（父结点）；\n- 小根堆：每棵树（包括任意一棵子树）的最小值都是其头部（父结点）；\n\n**完全二叉树**：对一棵具有 n 个节点的二叉树按照层序进行编号，如果编号 i （1<=i<=n）的结点与同样深度的满二叉树中编号为 i 的结点位置完全相同；\n**满二叉树**：所有的分支结点都存在左子树和右子树，且所有的叶子都在同一层；\n\n### 数组转换为大根堆\n以数组 [2,1,3,6,0,4]为例：\n首先取出第一元素 2，然后取出第二个元素 1，该元素比 2 小，放在左孩子位置，数组元素为：[2,1]；然后取出第三个元素 3，计算该元素的父结点：$\\frac{2 - 1}{2} = 0$，则与 0 位置元素 2 进行比较，发现 3 比较大，则在数组中将 3 和 2 两个元素互换，则数组变为：[3,1,2]；然后取出第四个元素 6，计算父结点下标为：$\\frac{3 - 1}{2} = 1$，则与 1 位置的元素 1 进行比较，发现 6 比较大，则将元素 1 和元素 6 互换，得到[3,6,2,1]，然后再比较元素 6 和其父结点：$\\frac{1 - 1}{2} = 0$，比较得出 6 比 3 大，然后再换，最后得到数组为：[6,3,2,1]，剩下元素依次类推......\n\n每加入一个节点其最多比较的次数和已经形成的二叉树高度有关（因为每次只和其父结点比较），因此最多时间复杂度为：$O(log_{2}^{N})$，所有整个转换过程时间复杂度为：$log_{2}^{1} + log_{2}^{2} + ..... + log_{2}^{N} = O(N)$\n\n\n**题目**\n吐泡泡：一个 XXX 会不停的吐出数字，求任意时刻的已经吐出的所有元素的中位数；\n\n**解答：**\n这里需要同时使用大根堆和小根堆，大根堆中存放着较小的 $\\frac{N}{2}$个元素，小根堆中存放较大的  $\\frac{N}{2}$个元素；\n\n这里以：5 4 6 7 为例\n首先将 5 放入大根堆，计算大根堆和小根堆的 Heapsize，插值为 1,不动， 然后因为 4 小于等于大根堆的堆顶，因此放入大根堆，再次计算 HeapSize，插值 > 1，然后将大根堆的堆顶放在小根堆，然后将大根堆剩余的调整为大根堆，然后元素 6 大于大根堆现在堆顶 4，因此放入小根堆；现在大根堆为 4，小根堆为 5,6；插值为 1，然后放入元素 7，同样大于大根堆堆顶，放入小根堆，然后插值> 1，将小根堆的堆顶放入大根堆末尾，小根堆重新排为：6,7；大根堆重新排为：5,4；中位数就是两个堆顶的平均值；\n\n\n### 堆排序\n首先将数组变成大根堆；\n然后将堆中最后一个和堆顶进行交换，堆大小减一，则最后一个不动了，然后将剩下的前面进行 Heapify 调整；\n然后再将堆的最后一个和堆顶进行交换，同上.....;\n\n```java\npackage sort.nowcoder.easy.day01;\n\n/**\n * @author GJXAIOU\n * @create 2019-10-04-20:08\n */\nimport java.util.Arrays;\n\npublic class HeapSort {\n\n    public static void heapSort(int[] arr) {\n        if (arr == null || arr.length < 2) {\n            return;\n        }\n        // 首先将数组转化为大根堆；0 到  i 之间形成大根堆\n        for (int i = 0; i < arr.length; i++) {\n            heapInsert(arr, i);\n        }\n\n        // 不断将堆顶的元素和最后一个元素交换然后进行 heapify 过程\n        int size = arr.length;\n        swap(arr, 0, --size);\n        while (size > 0) {\n            heapify(arr, 0, size);\n            swap(arr, 0, --size);\n        }\n    }\n\n    public static void heapInsert(int[] arr, int index) {\n        // 如果插入的新节点值大于其父结点大小\n        while (arr[index] > arr[(index - 1) / 2]) {\n            swap(arr, index, (index - 1) / 2);\n            index = (index - 1) / 2;\n        }\n    }\n\n    /**\n     * size - 1 到 length - 1 位置上已经拍好\n     * @param arr：要排序的数组\n     * @param index：哪个节点位置上元素发生了变化，传入的初始值一直为0\n     * @param size：还没有排好序的数组长度\n     */\n    public static void heapify(int[] arr, int index, int size) {\n        // size 表示当前堆上节点数\n        int left = index * 2 + 1;\n        // 越界表示已经是叶子结点了\n        while (left < size) {\n            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;\n            largest = arr[largest] > arr[index] ? largest : index;\n            if (largest == index) {\n                break;\n            }\n            swap(arr, largest, index);\n            index = largest;\n            left = index * 2 + 1;\n        }\n    }\n\n    public static void swap(int[] arr, int left, int right) {\n        int tmp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = tmp;\n    }\n}    \n```\n\n\n**概念：**\n- HeapInsert：将新的节点加入堆中同时按照堆的结构进行向上调整的过程；\n-  HeapSize：堆的大小；对应数组中就是 0-i 位置;\n- Heapify：假设堆中（数组中）某个值发生了变化，让其整体再次调整为大根堆（或小根堆）原来的样子的过程；\n  首先找到变化的值的两个孩子，然后找到其中较大的一个与之交换，如果有交换，在新的位置上再次找现在的两个孩子进行比较，然后交换，一直到没有交换为止；\n- 堆减小的过程：以大根堆为例：首先将堆顶元素和堆的最后一个元素位置互换，这样原来堆顶的元素就放在了数组的最后，然后将堆的 Heapsize - 1，这样最后一个元素就应为超过了现在的 HeapSize 而越界，从而失效；然后将剩余的 0 ~ i - 1 位置的按照 Heapify 重新进行调整（因为堆顶的元素值发生了变化）为原来的堆结构；\n\n\n## 排序算法的稳定性\n\n首先总结现有排序算法稳定性\n算法名称 | 时间复杂度 | 算法种类 | 是否稳定 | 原因\n---|---|---|---|---\n冒泡排序|$O({N}^{2})$|基于比较|稳定 |在冒泡的时候，如果遇到前后相同的值两者不交换即可，只有前者比后者大才交换；\n插入排序|$O({N}^{2})$|基于比较|稳定 |同样在比较的时候，相同的值不交换即可；\n选择排序|$O({N}^{2})$|基于比较| 不稳定 |因为如果后面有小于前面的，就和前面的互换，如果有几个相同数，则相当于和最前面的数进行互换，这样顺序就乱了；\n归并排序|$O(N * log_{2}^{N})$ |基于比较  |稳定 |以为归并之前是左右两个数组，左边数组在原数组中就是在左边，右边数组原来就是右边，这样只需要如果左右两个数组中有相同的数字，则只需要先拷贝左边数组值，然后拷贝右边数组中值即可；\n快速排序 | $O(N * log_{2}^{N})$ |基于比较  |不稳定（也可以稳定） |因为 partition 过程就是交换，肯定是无序的；\n堆排序 | $O(N * log_{2}^{N})$ |基于比较  |不稳定 | 因为在形成大根堆的时候，叶子结点与根节点进行交换的时候就会序号乱，例如：2,2,3；当放入 3 的时候，两个 2 的顺序就改变了；   \n桶排序|$O(N)$|非基于比较 |稳定 |   \n基数排序|$O(N)$|非基于比较 |稳定 |   \n计数排序|$O(N)$|非基于比较 |稳定 |   \n\n   \n**排序问题补充：**\n   \n- 归并排序的空间复杂度可以变成 O(1)，可以采用 “归并排序 内部缓存法”实现，但是仅仅要求了解即可；\n- 快速排序可以做到稳定性，采用“01 stable sort”；\n- 荷兰国旗问题不可能稳定，因为明显存在交换；\n问题：将一个数组的奇数放在数组左边，偶数放在数组右边，并且要求原始的相对次序不变，时间复杂度要求：O(N)，空间复杂度要求：O(1)；\n**解析：**   因为每一个数不是奇数就是偶数，因此也是可以抽象为一个 0 1 问题，相当于把 0 类（例如 < 0.5 的，这里 0.5 是随便取，就是为了区分）的放在左边，把大于 0.5 的放在右边，即 1 类 ；且保证原来的相对顺序不变，抽象就是快排的 partition 过程保证稳定；因为 partition 过程就是将一个数组分为 <= 和 > 两个部分，也是 0  1 过程，如果上述满足就可以实现快排稳定；只能采用 01 stable sort 解决；\n   \n\n## 认识比较器\n比较器作用：自己实现比较自己定义的对象的方法，然后通过将其传入**系统中有序的结构**就可以处理自己定义类型的比较；\n\n例如：使用优先级队列（实质上就是堆）存放自定义对象，然后自定义比较器使得可以比较自定义的类型对象；\n\n\n## 非基于比较的排序\n### 桶排序\n桶排序仅仅是一种概念，整体思想是首先记录数据各状况出现的词频，然后根据词频进行还原从而达到排序目的；\n它的具体实现有：计数排序、基数排序；\n\n\n### 计数排序\n**有多少个元素就需要多少个桶；**\n示例：有一个元素值范围为：0 ~ N 的数组，将其排序；\n步骤：首先准备一个长度为 N + 1 的辅助数组；辅助数组下标分别为：0 ~ N；\n然后遍历原数组，有一个 X 值（大小位于 0~N 之间），就在辅助数组下标为 X 的对应元素值 + 1；一直遍历结束；\n最后将辅助数组中各个下标对应的元素值还原，示例：辅助数组为：`[1,2,0,2]`就相当于有 1 个 0,2 个 1,0 个 3,2 个 4，因此结果为：`[0,1,1,4,4]`；\n\n\n\n### 基数排序\n\n\n\n\n\n**补充示例：** 给定一个数组，求如果排序之后相邻两个元素的最大差值，要求时间复杂度为 O(N)，且不能用非基于比较的排序；\n**解答：**\n- 思想：借用桶的思想，但是不使用桶排序；\n- 思路：\n  - 准备桶，原数组中有 N 个元素，因此准备 N+1 个桶；\n  - 遍历原数组，找到原数组中的最小值和最大值，分别放在第 0 号桶和第 N 号桶中；如果最大值等于最小值，直接返回 0 结束；\n  - 将新数组（桶）的 0 ~ N 部分等分为 N+ 1 份，原数组中值属于哪一个部分就放在哪一个桶中；示例：如果原数组一共 9 个数，则准备 10 个桶，且第一个桶中放的是数组最小值 0（假定），最后一个桶放的是最大值 99（假定），则将 0 ~ 99 等分为 10 份，则原数组中出现 0 ~ 9 直接的数放在 0 号桶，出现 10 ~ 19 之间的数放在 1 号桶。。。；\n  - 每个桶只保留三个值：一个 Boolean 值，用于判断该桶中是否有元素，一个 min，表示桶中的最小值，一个 max ，表示桶中的最大值；因此如果元素 X 进入 7 号桶，如果 7 号桶之前没有元素，则首先将 Boolean 值置为 true，然后 min = x，max = x；当又一个元素进入 7 号桶的时候，比较桶内元素的值，更新最大值和最小值，其他值扔掉；\n  - 最后遍历所有的桶，如果遇到空桶，跳到下一个进行判断，如果是非空桶，找到其左边最近的非空桶，将后一个非空的 min - 前一个非空的 max，插值进行保存，然后比较所有的插值，取最大的就是最大插值，\n\n- 原理：因为 0 号桶非空，N 号桶非空，但是只有 N 个数，因此**中间至少有一个桶是空的**，同时任何两个相邻的数可以来自于同一个桶，也可能来自于不同的桶；\n  - 为什么要设置一个空桶：因为至少有一个桶为空，则距离空桶左右最近的两个非空桶：左非空 min .... 左非空 max 。。。空桶 。。。右非空 min....右非空 max，则右非空 min - 左非空 max 的插值一定大于桶内插值，因为其值至少是一个桶的长度，而同一个桶内元素之间的插值是不会大于桶长的， 为了证明：**最大的插值一定不会来自于同一个桶**。**但是空桶仅仅是用于否定最终答案不是在同一个桶中，但是不是答案一定就是在空桶的两边；**示例：非空：13,19；空；非空：30，39；非空：59,63；不是空桶左右俩个的插值最大；\n \n   \n   \n##  工程中的综合排序算法\n\n- 首先会判断数组的长度（一般界限为 60）；\n  - 如果数组长度较短，一般使用插入排序，虽然插入排序的时间复杂度为：$O({N}^{2})$ 但是因为数据量较小，因此 $O({N}^{2})$ 比 $log_{2}^{N}$不会差距很大，但是因为插入排序的常数项很低，因此整体的时间复杂度较低；\n  - 如果数组长度较长\n    - 首先判断数组中装的数据类型\n      - 如果是基础数据类型：使用快排，因为其相同值没有区分，因此不必考虑稳定性；\n      - 如果是自定义数据类型：使用归并排序，因为即使相同值也是有区别的，要保证稳定性；\n    - 然后如果使用快排的话，因为快排使用分治划分的思想，因此在递归的时候如果划分多次之后数组长度减少到一定长度（例如 60），则直接使用插入排序；\n\n\n优化目标，现有方案，自己优化目标，验证方案，参考文献，综述，5-6 篇的\n技术的关键点\n\n下周写完综述\n\n\n\n",[[1570675196236,["GJX@GJXAIOU",[[-1,9671,"   "]],[9674,9674],[9671,9671]]],[1570675196652,["GJX@GJXAIOU",[[-1,9671,"\n"]],[9671,9671],[9670,9670]]],[1570675475225,["GJX@GJXAIOU",[[1,10159,"****"]],[10159,10159],[10161,10161]]],[1570675480003,["GJX@GJXAIOU",[[1,10161,"就是自己只需要师兄那"]],[10161,10161],[10171,10171]]],[1570675482829,["GJX@GJXAIOU",[[-1,10166,"需要师兄那"]],[10171,10171],[10166,10166]]],[1570675491379,["GJX@GJXAIOU",[[1,10166,"需要实现自定义比较规则"]],[10166,10166],[10177,10177]]],[1570675494677,["GJX@GJXAIOU",[[1,10233,"\n"]],[10231,10231],[10232,10232]]],[1570675495791,["GJX@GJXAIOU",[[1,10232,"```"]],[10232,10232],[10235,10235]]],[1570675495828,["GJX@GJXAIOU",[[1,10235,"language\n```\n"]],[10235,10235],[10235,10243]]],[1570675496754,["GJX@GJXAIOU",[[-1,10235,"language"],[1,10243,"j"]],[10235,10243],[10236,10236]]],[1570675497118,["GJX@GJXAIOU",[[1,10236,"ava"]],[10236,10236],[10239,10239]]],[1570675497197,["GJX@GJXAIOU",[[1,10240,"\n"]],[10239,10239],[10240,10240]]],[1570675509300,["GJX@GJXAIOU",[[1,10240,"package sort.nowcoder.easy.day01;\n\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class MyComparator {\n\n\t// 使用了内部类\n\tpublic static class Student {\n\t\tpublic String name;\n\t\tpublic int id;\n\t\tpublic int age;\n\n\t\tpublic Student(String name, int id, int age) {\n\t\t\tthis.name = name;\n\t\t\tthis.id = id;\n\t\t\tthis.age = age;\n\t\t}\n    }\n\n\t// 重载比较器\n\tpublic static class IdAscendingComparator implements Comparator<Student> {\n\t\t@Override\n\t\tpublic int compare(Student o1, Student o2) {\n            // 返回值：负数：前面的放在前面，整数：后面的放在前面，0：两者相等；\n\t\t\treturn o1.id - o2.id;\n            /**\n             * 上面的 return 等价于\n             * if(o1.id < o2.id){\n             *      return -1;\n             * }else if(o1.id > o2.id){\n             *     return 1;\n             * }else{\n             *     return 0;\n             * }\n             */\n\t\t}\n\n\t}\n\n\t// 按照 id 降序排列\n\tpublic static class IdDescendingComparator implements Comparator<Student> {\n\t\t@Override\n\t\tpublic int compare(Student o1, Student o2) {\n\t\t\treturn o2.id - o1.id;\n\t\t}\n\n\t}\n\n\tpublic static class AgeAscendingComparator implements Comparator<Student> {\n\t\t@Override\n\t\tpublic int compare(Student o1, Student o2) {\n\t\t\treturn o1.age - o2.age;\n\t\t}\n\n\t}\n\n\tpublic static class AgeDescendingComparator implements Comparator<Student> {\n\t\t@Override\n\t\tpublic int compare(Student o1, Student o2) {\n\t\t\treturn o2.age - o1.age;\n\t\t}\n\n\t}\n\n\tpublic static void printStudents(Student[] students) {\n\t\tfor (Student student : students) {\n\t\t\tSystem.out.println(\"Name : \" + student.name + \", Id : \" + student.id + \", Age : \" + student.age);\n\t\t}\n\t\tSystem.out.println(\"===========================\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tStudent student1 = new Student(\"A\", 1, 23);\n\t\tStudent student2 = new Student(\"B\", 2, 21);\n\t\tStudent student3 = new Student(\"C\", 3, 22);\n\n\t\tStudent[] students = new Student[] { student3, student2, student1 };\n\t\tprintStudents(students);\n\n\t\tArrays.sort(students, new IdAscendingComparator());\n\t\tprintStudents(students);\n\n\t\tArrays.sort(students, new IdDescendingComparator());\n\t\tprintStudents(students);\n\n\t\tArrays.sort(students, new AgeAscendingComparator());\n\t\tprintStudents(students);\n\n\t\tArrays.sort(students, new AgeDescendingComparator());\n\t\tprintStudents(students);\n\n\n        // 使用系统提供的堆：优先级队列进行排序： TreeMap 实现\n        PriorityQueue<Student> heap =  new PriorityQueue<>(new IdAscendingComparator());\n        // 添加自定义的类型\n        heap.add(student1);\n        heap.add(student2);\n        heap.add(student3);\n\n\t\tSystem.out.println(\"==========优先级队列按照 Id 排序=================\");\n        while (!heap.isEmpty()){\n            // 逐个弹出栈顶，内部实现就是 heapify\n            Student student = heap.poll();\n            System.out.println(\"Name : \" + student.name + \", Id : \" + student.id + \", Age : \" + student.age);\n        }\n\t}\n}\n"]],[10240,10240],[13039,13039]]],[1570675773879,["GJX@GJXAIOU",[[1,13214,"()"]],[13214,13214],[13216,13216]]],[1570675777265,["GJX@GJXAIOU",[[1,13215,"shu"]],[13215,13215],[13218,13218]]],[1570675778020,["GJX@GJXAIOU",[[-1,13215,"shu"]],[13218,13218],[13215,13215]]],[1570675782833,["GJX@GJXAIOU",[[1,13215,"数组最大值 + 1 "]],[13215,13215],[13225,13225]]],[1570676088078,["GJX@GJXAIOU",[[1,13404,"\n"]],[13401,13401],[13402,13402]]],[1570676088206,["GJX@GJXAIOU",[[1,13405,"\n"]],[13402,13402],[13403,13403]]],[1570676799584,["GJX@GJXAIOU",[[1,13402,"···"]],[13402,13402],[13405,13405]]],[1570676800642,["GJX@GJXAIOU",[[-1,13402,"···"]],[13405,13405],[13402,13402]]],[1570676801910,["GJX@GJXAIOU",[[1,13402,"```"]],[13402,13402],[13405,13405]]],[1570676801989,["GJX@GJXAIOU",[[1,13405,"language\n```\n"]],[13405,13405],[13405,13413]]],[1570676802553,["GJX@GJXAIOU",[[-1,13405,"language"],[1,13413,"j"]],[13405,13413],[13406,13406]]],[1570676802986,["GJX@GJXAIOU",[[1,13406,"ava"]],[13406,13406],[13409,13409]]],[1570676803078,["GJX@GJXAIOU",[[1,13410,"\n"]],[13409,13409],[13410,13410]]],[1570676806128,["GJX@GJXAIOU",[[1,13410,"package sort.nowcoder.easy.day01;\n\nimport java.util.Arrays;\n\n/**\n * 这里是使用计数排序实现桶排序思想\n */\npublic class BucketSort {\n\tprivate static final int withoutSortLength = 2;\n\tpublic static void bucketSort(int[] arr) {\n\t\tif (arr == null || arr.length < withoutSortLength) {\n\t\t\treturn;\n\t\t}\n\t\t// 首先找到要排序数组中的最大值\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tmax = Math.max(max, arr[i]);\n\t\t}\n\t\t// 新建 max + 1 个桶，然后遍历原数组，数组中元素值为X，则 X号桶中值 + 1；\n\t\tint[] bucket = new int[max + 1];\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tbucket[arr[i]]++;\n\t\t}\n\t\t// 遍历将 bucket 中按照个数进行还原\n\t\tint i = 0;\n\t\tfor (int j = 0; j < bucket.length; j++) {\n\t\t\twhile (bucket[j]-- > 0) {\n\t\t\t\tarr[i++] = j;\n\t\t\t}\n\t\t}\n\t}"]],[13410,13410],[14107,14107]]],[1570676809581,["GJX@GJXAIOU",[[1,14108,"\t\n"]],[14107,14107],[14109,14109]]],[1570676812853,["GJX@GJXAIOU",[[1,14108,"}"]],[14108,14108],[14109,14109]]],[1570676829644,["GJX@GJXAIOU",[[-1,15174," "],[1,15175,"\n"]],[15175,15175],[15175,15175]]],[1570676829814,["GJX@GJXAIOU",[[1,15176,"\n"]],[15175,15175],[15176,15176]]],[1570677000310,["GJX@GJXAIOU",[[-1,13551,"withoutSortLength"],[1,13568,"WITHOUT_SORT_LENGTH"],[-1,13652,"withoutSortLength"],[1,13669,"WITHOUT_SORT_LENGTH"]],[13526,13687],[13691,13691]]],[1570677508956,["GJX@GJXAIOU",[[1,15179,"```"]],[15179,15179],[15182,15182]]],[1570677508997,["GJX@GJXAIOU",[[1,15182,"language\n```\n"]],[15182,15182],[15182,15190]]],[1570677509788,["GJX@GJXAIOU",[[-1,15182,"language"],[1,15190,"j"]],[15182,15190],[15183,15183]]],[1570677510033,["GJX@GJXAIOU",[[1,15183,"sa"]],[15183,15183],[15185,15185]]],[1570677511338,["GJX@GJXAIOU",[[-1,15183,"sa"]],[15185,15185],[15183,15183]]],[1570677512094,["GJX@GJXAIOU",[[1,15183,"ava"]],[15183,15183],[15186,15186]]],[1570677512203,["GJX@GJXAIOU",[[1,15187,"\n"]],[15186,15186],[15187,15187]]],[1570677516103,["GJX@GJXAIOU",[[1,15187,"package sort.nowcoder.easy.day01;\n\nimport java.util.Arrays;\n\npublic class MaxGap {\n\tprivate static final int WITHOUT_SORT_LENGTH = 2;\n\tpublic static int maxGap(int[] nums) {\n\t\tif (nums == null || nums.length < WITHOUT_SORT_LENGTH) {\n\t\t\treturn 0;\n\t\t}\n\t\tint len = nums.length;\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\t// 找到数组中的最大值和最小值\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t}\n\t\tif (min == max) {\n\t\t\treturn 0;\n\t\t}\n\t\t// 下面三个数组是描述 len + 1 个桶中每个桶的三个必备信息\n\t\tboolean[] hasNum = new boolean[len + 1];\n\t\tint[] maxs = new int[len + 1];\n\t\tint[] mins = new int[len + 1];\n\t\tint bid = 0;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t    // 确定该数去第几号桶\n\t\t\tbid = bucket(nums[i], len, min, max);\n\t\t\t// 该桶中的三个信息进行更新\n\t\t\tmins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];\n\t\t\tmaxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];\n\t\t\thasNum[bid] = true;\n\t\t}\n\t\t// 找到每一个非空桶和离他最近的非空桶的插值：用当前min - 前一个max；\n\t\tint res = 0;\n\t\tint lastMax = maxs[0];\n\t\tint i = 1;\n\t\tfor (; i <= len; i++) {\n\t\t\tif (hasNum[i]) {\n\t\t\t\tres = Math.max(res, mins[i] - lastMax);\n\t\t\t\tlastMax = maxs[i];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static int bucket(long num, long len, long min, long max) {\n\t\treturn (int) ((num - min) * len / (max - min));\n\t}"]],[15187,15187],[16479,16479]]],[1570677519011,["GJX@GJXAIOU",[[1,16480,"\t\n"]],[16479,16479],[16481,16481]]],[1570677519518,["GJX@GJXAIOU",[[1,16481,"}"]],[16481,16481],[16482,16482]]],[1570677520881,["GJX@GJXAIOU",[[-1,16480,"\t"]],[16481,16481],[16480,16480]]]],null,"GJX@GJXAIOU"]]}