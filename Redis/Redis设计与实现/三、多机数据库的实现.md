# 多级数据库的实现

## 一、Redis （主从）复制功能

从服务器（slave) 可以通过 slaveOf 命令或者 slaveof 选项，去复制另一个服务器（主服务器，master）。

**主从复制结合哨兵模式能解决单点故障问题，提高 Redis 可用性。主节点提供写操作，从节点仅提供读操作**。

**主从复制的作用：**

- **数据冗余**：实现数据冗余备份，这样一台节点挂了之后，其上的数据不至于丢失。
- **故障恢复**：当主节点出现问题时，其从节点可以被提升为主节点继续提供服务，实现快速的故障恢复；
- **负载均衡**：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。

### 主从复制的过程和原理

**Redis主从复制默认是异步实现的**，避免客户端的等待。
![](Redis.resource/image-20200602094035427.png)

**复制过程：**

- 开启：从节点执行 `slavaof[masterIP][masterPort]`，保存主节点信息；如 `A> SLAVEOF  B的IP  B的端口`   =》 A 成为 B 的从服务器

- 从节点的定时任务发现主节点信息，建立和主节点的 Socket 连接；从节点发送 Ping 信号，主节点返回 Pong，连接建立后，主节点将所有数据发送给从节点（**全量复制**）。

- 完成了复制的建立过程后，主节点持续的把写命令发送给从节点（**增量复制**），保证主从数据一致性。

  全量复制是从结点因为**故障恢复或者新添加从结点时**出现的初始化阶段的数据复制。增量复制是主从结点正常工作之后的每个时刻进行的数据复制方式。

Redis中，从服务器对主服务器的复制可以分为以下两种情况：

- 初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同；

- 断线后复制：处于**命令传播阶段**的主从服务器因为网络原因而中断了复制，但从服务器通过自动重新连接连上了主服务器，并继续复制主服务器；

  **旧版复制功能，在主从服务器断线重连之后，从库会向主库发送 SYNC 命令，主库接收到之后会触发 BGSAVE，然后将所有的键形成 RDB 文件发送给从库，再次完成同步**。为了解决旧版复制功能在处理断线重复机制情况时的低效问题，Redis 从 2.8 版本开始，使用PSYNC 命令代替 SYNC 命令来执行复制时的同步操作：

### Redis 新复制功能的实现

Redis 的复制功能分为同步（Psync）和命令传播（command propagate）两个操作，而同步针对不同的阶段划分为两种；

- **完整重同步**用于将**从服务器的数据库状态更新至主服务器当前所处的数据库状态**。【用于初次复制阶段】

  从服务器对主服务器的同步操作需要通过向主服务器发送 SYNC 命令来完成，该命令的执行步骤：

  - 从服务器向主服务器发送 SYNC 命令。

  - 主服务器收到 SYNC 命令后执行 BGSAVE 命令， 在后台生成一个 RDB 文件， **并使用一个缓冲区记录从现在开始执行的所有写命令。**

  - 主服务器将生成的 RDB 文件发送给从服务器， 从服务器接收并载入这个 RDB 文件， 将自己的数据库状态更新至主服务器执行 BGSAVE 命令时的数据库状态。

  - 主服务器将记录在缓冲区里面的所有写命令发送给从服务器， 从服务器执行这些写命令， 将自己的数据库状态更新至主服务器数据库当前所处的状态。

- 部分重同步（partial resynchronization）：用于处理断线后同步机制，当从服务器在断线后重新连接主服务器时，从服务器向主服务器发送 PSYNC 命令，然后主库返回 + CONTIUNE 回复，表示执行部分重同步，从库接收到 + CONTIUNE 之后，准备执行部分重同步，然后主库只向从服务器发送**后面变动的指令即可**，就可以将数据更新至主服务器当前所处的状态；

- **命令传播**操作则用于**在主服务器的数据库状态被修改， 导致主从服务器的数据库状态出现不一致时， 让主从服务器的数据库重新回到一致状态。**

  主服务器会将自己执行的写命令（即造成主从服务器不一致的那条写命令）发送给从服务器执行， 当从服务器执行了相同的写命令之后， 主从服务器将再次回到一致状态。

#### 部分重同步的实现

PSYNC 功能由以下三个部分构成：

- 主服务器和各个从服务器都维持自身的复制偏移量

  如果主库发送给从库 N 个字节，则主库偏移量 + N，如果从库收到，则从库偏移量 + N；对比两者的复制偏移量则可以判断是否处于一致状态。

- 主服务器的复制积压缓冲区（replication backlog）

  复制积压缓冲区是由**主服务器**维护的一个固定长度先入先出队列（默认 1 MB，可以修改），当主服务器进行**命令传播时候**，不仅会将命令发送给所有的从服务器，也会将命令入队到复制积压缓冲区中。在该缓冲区中为队列中**每个字节记录响应的复制偏移量**。

  所以当上面重连之后从库通过 PSYNC 命令发送自身复制偏移量给主库，主库根据该偏移量决定同步方式：

  如果该偏移量之后的数据在复制积压缓冲区中，则采用部分重同步操作。如果不存在了则采用完整重同步操作。

- 服务器的运行 ID(run ID)

  主从库服务器在启动时候就会生成唯一的运行 ID，当从库对主库进行初次复制的时候，主库会将自身运行 ID 发送给从库进行保存。当断线重连之后判断保存的 ID 和连接的 ID 是否一致，如果一致则是部分重同步，如果不一致则没有连接过，采用完整重同步。

#### 心跳检测

在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：`REPLCONF ACK <replication_off>`，其中 `replication_offset` 是从服务器当前的复制偏移量。
发送 REPLCONF ACK 命令对于主从服务器有三个作用：

- 检测主从服务器的网络连接状态
- 辅助实现 min-slaves 选项
- 检测命令丢失：主从服务器的复制偏移量是否一致

**主从复制存在的问题：**

一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址、命令所有从节点去复制新的主节点，整个过程需要人工干预。

解决方案：**哨兵**

## 二、Sentinel（哨兵）

由一个或者多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及他们属下对应的所有从服务器，并在被监视的主服务器下线的时候自动将该主服务器的某个从服务器升级为从服务器。 

#### （一）哨兵的主要功能

- **监控**：包括主节点存活检测、主从运行情况检测。
- **提醒**：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。
- **自动故障转移**：主从切换。哨兵模式的最小配置是一主一从。

#### （二）哨兵启动和初始化

Redis 启动并初始化 Sentinel：`redis-sentinel /path/to/your/sentinel.conf`。当一个 Sentinel 启动时， 它需要执行以下步骤：

- 初始化服务器。

  因为 Sentinel 本质是一个运行在特殊模式下的 Redis 服务器，初始化过程和普通的部分一样，但不会载入 RDB 或者 AOF 文件。

- 将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码。

  比如普通服务器使用 6379 作为端口号，但是 Sentinel 使用 26379 作为端口，还有特殊的命令表等。

- 初始化 Sentinel 状态。

  服务器会创建一个 sentinelState 结构保存所有和 Sentinel 功能相关的状态，而普通服务器是 RedisServer 结构。

- 根据给定的配置文件， 初始化 Sentinel 的监视主服务器列表。

  上面的 sentinelState 结构中的字典类型的变量 masters 记录了所有被 Sentinel 监视的主服务器的相关信息。

  - 字典的键是被监视主服务器的名字。
  - 字典的值则是被监视主服务器对应的 sentinelRedisInstance 结构（每个结构都是一个被 Sentinel 监视的 Redis 服务器实例，该实例可以是主服务器、从服务器或者另一个 Sentinel）。

- 创建连向主服务器的网络连接。

  Sentinel 将成为主服务器的客户端， 它可以向主服务器发送命令， 并从命令回复中获取相关的信息。对于每个被 Sentinel 监视的主服务器来说， Sentinel 会创建两个连向主服务器的异步网络连接：

  - 一个是命令连接， 这个连接专门用于向主服务器发送命令， 并接收命令回复。
  - 另一个是订阅连接， 这个连接专门用于订阅主服务器的 `__sentinel__:hello` 频道。【因为 Redis 服务器不会保存任何信息，但是客户端可能不在线，所以为了不丢失 hello 频道的信息，但是采用一个订阅连接来接收该频道信息。】

#### （三）获取主服务器、从服务器、哨兵服务器信息

- 获得主服务器信息
  Sentinel 每隔 10s 通过命令连接向主服务器发 `info` 命令，Sentinel 从该命令的返回信息中获取两方面信息：

  关于主服务器本身的信息和主服务属下的所有从服务器信息。

- 获取从服务器信息

  通过主服务器的`info`信息中包含的从服务器信息，Sentinel 再向从服务器建立 2 个连接（命令连接和订阅连接），然后同样以每十秒一次的频率向从服务器发送 INFO 信息，自然就获得了从服务器的信息【最重要的就是从服务器的优先级和从服务器的**复制偏移量**，更新到自己的 slave 字典中。

- 获得其他 Sentinel 的信息
  Sentinel 通过暴露自己的方式让其他哨兵感知到的从而知道其它哨兵，Sentinel 会向主从服务器 `sentinel:hellp` 频道都发布消息，消息内容会包含 sentinel 自身信息和监控的主机信息，那么其他的 sentinel 通过订阅这个频道，可以知道其他 sentinel 的信息。从而使得监视同一个主服务器的多个 Sentinel 可以走动发现对方。发现后就可以互相创建命令连接，最终跟新自身的 sentinel 字典。

#### （四）高可用的方案（哨兵的完整工作过程）

- **检测主观下线**
  每个 Sentinel 每隔 1s 向所有与它创建了命令连接的实例（主、从、其他哨兵）发送 ping，如果在 `down-after-nukkuseconds` 时间内都是返回无效回复，就会被判定为主观下线，然后在结构的 flags 标志改为 `SRI_S_DOWN`

- **检测客观下线**
  当 Sentinel 判定一台服务器主观下线后，会去向其他的 Sentinel 询问（其他哨兵也会像上面一样去探测），如果反馈达到一定数量（数量 quorum 由配置文件配置），则被判定为客观下线。

- **选举 Sentinel 的 leader**

  如果主服务器被判定客观下线，监视这个下线主服务器的各个 Sentinel 会进行协商选出领头 Sentinel 来对下线主服务器执行故障转移操作。

  Sentinel选举是基于 raft 算法选出 leader 的，参考文档：https://www.jianshu.com/writer#/notebooks/28197258/notes/57839517/preview

- **故障转移**
  当选出 Sentinel 的 leader 后，就可以执行故障转移高可用

  - 步骤一：在从服务器里，挑选一个转换为新的主服务器
    挑选的依据主要是根据是否存活，优先级高低，**最大偏移量大小**，运行 id  大小（小的优先），依次选下去。
    发送命令 `slaveof no one` 后，从就会变成主，在此期间，Sentinel 每隔 1s 向服务器发送 info 命令直到info 返回的 role 是 master 了，就确认从已经正确切换成主。
  - 步骤二：修改从服务器的复制目标为新的主服务器
    通过向其他的从服务器发送新的 `slaveof` 命令
  - 让已下线的主设置为新的主服务的从，如果旧主重新上线就变成了新主的从
    保存在自身结构中，这样下掉的主回来就变成新的从了，同样是执行 SLAVEOF 命令

#### （五）哨兵模式的缺陷

在哨兵模式中，仍然只有一个 Master 节点。当并发写请求较大时，哨兵模式并不能缓解写压力。

只有主节点才具有写能力，如果在一个集群中，能够配置多个主节点，就可以缓解写压力了。这个就是 redis-cluster 集群模式。



##  三、集群（Cluster）

**哨兵模式着眼于高可用**：在 Master 宕机时会自动将 Slave 提升为 Master，继续提供服务。

**集群模式着眼于扩展性**：在单个 Redis 内存不足时，使用 Cluster 进行分片存储。Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。

### （一）集群模式

- 由多个 Redis 服务器组成的分布式网络服务集群，Redis 集群中无中心节点，各个节点之间会互相通信，两两相连；
- 集群之中有**多个 Master 主节点**，每一个主节点都可读可写；可以给每一个主节点添加从节点，主节点和从节点遵循主从模型的特性

### （二）集群分片策略

Redis-cluster 分片策略用来解决 key 存储位置。

![image-20200602095139785](Redis.resource/image-20200602095139785.png)

**集群将整个数据库分为 16384 个槽位 slot，所有 key-value 数据都存储在这些 slot 中的某一个上**。一个 slot 槽位可以存放多个数据，key 的槽位计算公式为：`slot_number=crc16(key)%16384`，其中 crc16 为 16 位的循环冗余校验和函数。

**集群中的每个主节点都可以处理 0 个至 16383 个槽**，当 16384 个槽都有节点在负责处理时，集群进入上线状态，并开始处理客户端发送的数据命令请求。

### （三）集群 redirect 转向

由于 Redis 集群无中心节点，**请求会随机发给任意主节点**；

**主节点只会处理自己负责槽位的命令请求，其它槽位的命令请求，该主节点会返回客户端一个转向错误。
客户端根据错误中包含的地址和端口重新向正确的负责的主节点发起命令请求。**

![image-20200602095231276](Redis.resource/image-20200602095231276.png)

### 节点

- 一个 Redis 集群通常由多个节点组成，刚开始时，每个节点是相互独立的，我们必须将各个独立的节点连接起来。

- 节点通过握手来将其他节点添加到自己所处的集群中。如通过 `127.0.0.1:7000>CLUSTER MEET 127.0.0.1 7001` 可以将 7001 添加到节点 7000 所在的集群里。

- 一个节点就是一个运行在集群模式下的 Redis 服务器， Redis 服务器在启动时会根据 `cluster-enabled` 配置选项的是否为 `yes` 来决定是否开启服务器的集群模式。

  除此之外， 节点会继续使用 `redisServer` 结构来保存服务器的状态， 使用 `redisClient` 结构来保存客户端的状态，至于那些只有在集群模式下才会用到的数据， 节点将它们保存到了 `cluster.h/clusterNode` 结构、 `cluster.h/clusterLink` 结构以及 `cluster.h/clusterState` 结构里面；

  - `clusterNode` 结构保存了一个节点的当前状态， 比如节点的创建时间， 节点的名字， 节点当前的配置纪元， 节点的 IP 和地址等。每个节点都会使用一个 `clusterNode` 结构来记录自己的状态， 并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的`clusterNode` 结构， 以此来记录其他节点的状态：

  - 每个节点都保存着一个 `clusterState` 结构， 这个结构记录了在当前节点的视角下， 集群目前所处的状态 —— 比如集群是在线还是下线， 集群包含多少个节点， 集群当前的配置纪元；

### （三）CLUSTER MEET 命令的实现

通过向节点 A 发送 CLUSTER MEET 命令， 客户端可以让接收命令的节点 A 将另一个节点 B 添加到节点 A 当前所在的集群里面，过程和图见下：

- 节点 A 会为节点 B 创建一个 `clusterNode` 结构， 并将该结构添加到自己的 `clusterState.nodes` 字典里面。

- 然后节点 A 将根据 CLUSTER MEET 命令给定的 IP 地址和端口号， 向节点 B 发送一条 `MEET` 消息（message）。

- 如果一切顺利， 节点 B 将接收到节点 A 发送的 `MEET` 消息， 节点 B 会为节点 A 创建一个 `clusterNode` 结构， 并将该结构添加到自己的 `clusterState.nodes` 字典里面。

- 之后， 节点 B 将向节点 A 返回一条 `PONG` 消息。

- 如果一切顺利， 节点 A 将接收到节点 B 返回的 `PONG` 消息， 通过这条 `PONG` 消息节点 A 可以知道节点 B 已经成功地接收到了自己发送的 `MEET` 消息。

- 之后， 节点 A 将向节点 B 返回一条 `PING` 消息。

- 如果一切顺利， 节点 B 将接收到节点 A 返回的 `PING` 消息， 通过这条 `PING` 消息节点 B 可以知道节点 A 已经成功地接收到了自己返回的 `PONG` 消息， 握手完成。

![img](Redis.resource/2015-09-13_55f528a75c69b.png)

之后， 节点 A 会将节点 B 的信息通过 Gossip 协议传播给集群中的其他节点， 让其他节点也与节点 B 进行握手， 最终， 经过一段时间之后， 节点 B 会被集群中的所有节点认识。

### （四）槽指派

- **Redis 集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为 16384 个槽（slot）**。

- 数据库中每个键都属于其中一个槽，每个节点可以处理 0-16383 个槽。

- 当16384个槽都有节点在处理时，集群处于上线状态，只要有一个槽没有得到处理，那么集群处于下线状态。

  `127.0.0.1:7000>CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000` 可以将槽 0-5000 指派给节点 7000 负责。

- 每个节点的 clusterNode 结构的 slots 属性（是一个二进制数组）都会记录哪些槽指派给了自己，哪些槽指派给了其他节点。同时会将自己的 slots 数组通过消息发送给集群中的其他节点，告知其他节点自己负责处理哪些槽。

- clusterState 结构中的 slots 记录了集群中所有槽的指派信息。

### （五）在集群中执行命令流程

- 客户端向节点发送键命令，节点首先要计算这个键属于哪个槽。计算方式是计算键的 CRC-16 校验和然后 & 16383 得到一个介于 0 到 16383 的整数作为 key 的槽号。

- 如果是自己负责这个槽，那么直接执行命令，如果不是，向客户端返回一个 MOVED 错误，指引客户端转向正确的节点。确定 i 漕之后，判断方式是节点检查自己的 clusterState.slots 数组的项 i ，如果值是 clusterState.myself 则是当前节点负责，节点可以执行客户端发送的命令，如果不等会根据数组中项 i 的值指向的 clusterNode 结构记录的 IP 和端口号转向正确的漕。

- 集群节点保存键值对以及键值对过期时间的方式和单机一致，区别就是节点只能使用 0 号数据库，单机没有限制。

### （六）重新分片

重写分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点。**该操作可以在线进行**，源节点和目标节点都可以继续处理命令请求。如果客户端向源节点发送一个与数据库 key 相关的命令，并且要处理的 Key 正好在正在迁移的槽时候：源节点会现在自己数据库中进行查找，有就执行，没有就返回一个 ASK 错误并且指引客户端转向导入槽的目标节点。

### （七）ASK错误

重新分片期间可能会出现这种情况：属于迁移槽的一部分键值对保存在源节点里，而另一部分保存在目标节点里。

如果节点 A 正在迁移槽 i 到节点 B，那么当节点 A 没能在自己数据库中找到命令指定的数据库键时，节点会向客户端返回一个 ASK 错误，指引客户端到节点 B 继续查找。

###  （八）复制与故障转移

Redis 集群的节点分为主节点（可能有多个）和从节点。主节点用于处理槽，从节点用于复制某个主节点，并在被复制的主节点下线后，替代主节点。

集群中的每个节点会定期向其他节点发送 PING 消息，以此来检测对方是否在线，如果没有收到回应则标记为疑似下线。同时因为集群中各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，当半数以上负责处理槽的**主节点**都标记为疑似下线，则这个主节点会被标记为下线并向集群广播。

1. **故障转移**

当从节点发现自己正在复制的主节点进入已下线的状态，则会进行故障迁移。

- 下线主节点的所有从节点，会有一个成为主节点

- 选中的从节点会执行 slaveof no one 命令，成为新的主节点

- 新的主节点撤销所有对原来主节点的槽指派，并将这些槽都指派给自己

- 新的主节点向集群广播一条 PONG 消息。让其他节点知道自己成为了主节点并接管了原来下线的主节点的所有槽指派

- 新的主节点开始接受和处理客户端的命令请求，转移完成

2.**选举新节点**

- 配置纪元是一个自增变量，初始值是0

- 当集群某个节点开始一次故障转移时，配置纪元的值会加一

- 在一个配置纪元中，主节点只有一次投票机会。它会把票投给第一个要求它投票的节点

- 当从节点知道自己的主节点已下线后，会广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求其他主节点为它投票

- 如果主节点有投票权（它正在负责处理槽），并且没有投过票给其他节点，那它会给第一个要求投票的节点返回CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息

- 每个参选的从节点都会受到ACK消息，如果自己收到的ACK消息大于可投票的节点的半数，这个节点就会成为新的主节点。

- 如果在一个配置纪元里面，没有从节点收到足够多的票数（例如3个主节点，挂了一个，剩下2个，2个从节点各自收到一个投票）。那集群就会进入一个新的配置纪元。再次进行选举。

==有点不太明白。怎么进入新的纪元？谁来决定是否进入新的纪元？==

选举算法和哨兵的类似，也是Raft算法